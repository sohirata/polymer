SUBROUTINE GRIDHF
    
! Perform a first-quantized, grid-based, Hartree-Fock self-consistent
! field calculations largely adopting Becke-Dickson algorithms.
    
   USE CONSTANTS
   USE CONTROL
   USE STRUCTURE
   USE INTEGRAL
   USE BASISSET
   USE DFT
   USE SINANOGLU

   IMPLICIT NONE
   INTEGER :: ITER
   INTEGER,PARAMETER :: MAXITER=100
   DOUBLE PRECISION :: ICPUS,ICPUE
   DOUBLE COMPLEX,ALLOCATABLE   :: R(:,:,:,:)      ! RADIAL FUNCTIONS
   DOUBLE COMPLEX,ALLOCATABLE   :: RR(:,:,:,:)     ! RADIAL FUNCTIONS ACTED ON BY SOME OPERATOR
   DOUBLE COMPLEX,ALLOCATABLE   :: FR(:,:,:,:)
   DOUBLE PRECISION,ALLOCATABLE :: FOCK(:,:)
   DOUBLE PRECISION,ALLOCATABLE :: ER(:),EI(:),EVR(:,:),EVL(:,:),EWK(:)
   DOUBLE PRECISION,ALLOCATABLE :: TEMP(:,:),TORB(:,:)
   INTEGER :: INFO
   DOUBLE PRECISION :: OV,D,PREVIOUS,CURRENT
   INTEGER :: I,J,K,L,M,IA
   DOUBLE PRECISION,EXTERNAL :: SINGLEENERGY
   DOUBLE PRECISION,EXTERNAL :: OVERLAP
   DOUBLE PRECISION,EXTERNAL :: HFENERGY
   DOUBLE PRECISION,EXTERNAL :: HFENERGY_DIRECT
   INTEGER :: L1,M1,LMR1,L2,M2,LMR2
!double precision,allocatable :: orb1(:,:),orb2(:,:),orb3(:,:),corb1(:),corb2(:)

   IF (KVCX /= 0) CALL PABORT('SINANOGLU CALCULATION IS FOR MOLECULES ONLY')
   IF (KVCY /= 0) CALL PABORT('SINANOGLU CALCULATION IS FOR MOLECULES ONLY')
   IF (KVCZ /= 0) CALL PABORT('SINANOGLU CALCULATION IS FOR MOLECULES ONLY')
   WRITE(6,'(/,A,/)') 'GRID-BASED HARTREE-FOCK CALCULATION WILL BE PERFORMED'
   WRITE(6,'(A,F15.8,A)') 'CONVERGENCE TOLERANCE = ',DOPTN(14),' (USE SCFCONV TO CHANGE)'

   SALG=IOPTN(95)
   IF (SALG==1) THEN
    WRITE(6,'(A)') 'SEVEN-POINT LINEAR'
   ELSE IF (SALG==-1) THEN
    WRITE(6,'(A)') 'TWO-POINT LINEAR'
   ELSE IF (SALG==2) THEN
    WRITE(6,'(A)') 'SEVEN-POINT LOGARITHM'
   ELSE IF (SALG==-2) THEN
    WRITE(6,'(A)') 'TWO-POINT LOGARITHM'
   ELSE IF (SALG==3) THEN
    WRITE(6,'(A)') 'SEVEN-POINT BECKE'
   ELSE IF (SALG==-3) THEN
    WRITE(6,'(A)') 'TWO-POINT BECKE'
   ELSE
    CALL PABORT('UNKNOWN ALGORITHM')
   ENDIF
   CALL PFLUSH(6)

   ! CREATE A FACTORIAL LIST
   ALLOCATE(FACTORIAL(0:80),SGN(-80:80))
   FACTORIAL(0)=1.0D0
   DO I=1,80
    FACTORIAL(I)=FACTORIAL(I-1)*DFLOAT(I)
   ENDDO
   DO I=-80,80
    SGN(I)=(-1.0D0)**I
   ENDDO

   ! CREATE A GRID
   ALLOCATE(NGRID(NATOM),GRIDX(MAXNGRID,NATOM),GRIDY(MAXNGRID,NATOM),GRIDZ(MAXNGRID,NATOM))
!  ALLOCATE(GRIDXA(MAXNGRID*NATOM),GRIDYA(MAXNGRID*NATOM),GRIDZA(MAXNGRID*NATOM))
   ALLOCATE(ATOMW(MAXNGRID,NATOM),FUZZY(MAXNGRID,NATOM),GRIDW(MAXNGRID,NATOM))
   CALL PCPU_TIME(ICPUS)
   CALL SG_CONSTRUCT_GRID
   CALL PCPU_TIME(ICPUE)
write(*,*) 'construct grid cpu = ',icpue-icpus
   CALL PFLUSH(6)
   CALL PCPU_TIME(ICPUS)
   CALL GRID_WEIGHT
   CALL PCPU_TIME(ICPUE)
write(*,*) 'grid weight cpu = ',icpue-icpus
   CALL PFLUSH(6)
!k=0
!do i=1,natom
! do j=1,ngrid(i)
!  if (fuzzy(j,i) > 0.5d0) k=k+1
! enddo
!enddo
!write(40,*) k
!write(40,*) rg," x ",ag," x ",natom
!k=0
!do i=1,natom
! do j=1,ngrid(i)
!  if (fuzzy(j,i) > 0.5d0) write(40,*) catom(iatom(i)),gridx(j,i),gridy(j,i),gridz(j,i)
! enddo
!enddo

   ! CONSTRUCT AUXILIARY SLATER BASIS
   CALL PCPU_TIME(ICPUS)
   IF (.TRUE.) THEN
    CALL CONSTRUCTAO(IOPTN(103))
!   CALL CONSTRUCTAO2
   ELSE
    CALL CONSTRUCTAOLIGHT
   ENDIF
   CALL PCPU_TIME(ICPUE)
write(*,*) 'AO total cpu = ',icpue-icpus
write(*,*) 'nao = ',nao
   CALL PFLUSH(6)
   CALL PCPU_TIME(ICPUS)
write(*,*) 'DAO not needed at HF'
   CALL PFLUSH(6)
!  CALL CONSTRUCTDAO
   CALL PCPU_TIME(ICPUE)
write(*,*) 'DAO total cpu = ',icpue-icpus
   CALL PFLUSH(6)

   ! ALLOCATE ARRAYS
   ALLOCATE(ORBITALS(MAXNGRID,NATOM,NAO))
   ALLOCATE(ORBITALS_SAVE(MAXNGRID,NATOM,IOCC))
!  ALLOCATE(DXORBITALS(MAXNGRID,NATOM,NAO))
!  ALLOCATE(DYORBITALS(MAXNGRID,NATOM,NAO))
!  ALLOCATE(DZORBITALS(MAXNGRID,NATOM,NAO))
   ALLOCATE(RORB(0:LMAX,-LMAX:LMAX,RG,NATOM,NAO))
!  ALLOCATE(RXORB(0:LMAX,-LMAX:LMAX,RG,NATOM,NAO))
!  ALLOCATE(RYORB(0:LMAX,-LMAX:LMAX,RG,NATOM,NAO))
!  ALLOCATE(RZORB(0:LMAX,-LMAX:LMAX,RG,NATOM,NAO))
   ALLOCATE(RHO(MAXNGRID,NATOM))
   ALLOCATE(RRHO(0:LMAX,-LMAX:LMAX,RG,NATOM))
   ALLOCATE(RN(0:LMAX,-LMAX:LMAX,RG,NATOM))
   ALLOCATE(RJ(0:LMAX,-LMAX:LMAX,RG,NATOM))
   ALLOCATE(R(0:LMAX,-LMAX:LMAX,RG,NATOM))
   ALLOCATE(RR(0:LMAX,-LMAX:LMAX,RG,NATOM))
   ALLOCATE(ER(NAO),EI(NAO),EVR(NAO,NAO),EVL(NAO,NAO),EWK(4*NAO))
   ALLOCATE(FOCK(NAO,NAO))
   ALLOCATE(POTENTIALJ(MAXNGRID,NATOM),POTENTIALN(MAXNGRID,NATOM),PREVIOUS_J(MAXNGRID,NATOM))
   ALLOCATE(SG_EPSILON(MAXNGRID*NATOM))

   ! CONSTRUCT INITIAL GUESS
   CALL PCPU_TIME(ICPUS)
   CALL GUESSORB
   CALL PCPU_TIME(ICPUE)
write(*,*) 'Guess cpu = ',icpue-icpus
   CALL PFLUSH(6)
   CALL PCPU_TIME(ICPUS)
   CALL EXPANDORB
   CALL PCPU_TIME(ICPUE)
write(*,*) 'Expand cpu = ',icpue-icpus
   CALL PFLUSH(6)
   CALL PCPU_TIME(ICPUS)
write(*,*) 'DORB not needed at HF'
   CALL PFLUSH(6)
!  CALL CONSTRUCTDORB
   CALL PCPU_TIME(ICPUE)
write(*,*) 'DORB cpu = ',icpue-icpus
   CALL PFLUSH(6)
   CALL PCPU_TIME(ICPUS)
   CALL CONSTRUCTRHO
   CALL PCPU_TIME(ICPUE)
write(*,*) 'RHO cpu = ',icpue-icpus
   CALL PFLUSH(6)

   ! CONSTRUCT COULOMB POTENTIAL
   CALL PCPU_TIME(ICPUS)
   CALL CONSTRUCTN
   CALL PCPU_TIME(ICPUE)
write(*,*) 'N cpu = ',icpue-icpus
   CALL PFLUSH(6)
   CALL PCPU_TIME(ICPUS)
!write(*,*) 'Conventional J without interpolation'
!  CALL CONSTRUCTJ(RRHO,RJ)
!  DO IA=1,NATOM
!   CALL PACKYLM(POTENTIALJ(:,IA),RJ(:,:,:,IA),IA,IA)
!  ENDDO
!write(*,*) 'Partial wave expansion J'
!  CALL CONSTRUCTJ_PARTIALWAVE(RRHO,RJ)
!write(*,*) 'New interpolated J'
   CALL CONSTRUCTJ_NEW(RHO,POTENTIALJ)
   DO IA=1,NATOM
    CALL EXPAND2YLM(POTENTIALJ(:,IA),RJ(:,:,:,IA),IA,IA)
   ENDDO
   PREVIOUS_J=POTENTIALJ
   CALL PCPU_TIME(ICPUE)
write(*,*) 'J cpu = ',icpue-icpus
   CALL PFLUSH(6)

   ! COMPUTE ORBITAL KINETIC, COULOMB & EXCHANGE FOR INITIAL GUESS
   ALLOCATE(TEMP(NCGS,NCGS),TORB(MAXNGRID,NATOM))
   DO I=1,IOCC
!  DO I=1,MIN(IALL(0)-IVIRTCORE,NAO)

    WRITE(6,*)
    WRITE(6,'(A,I3)') 'INITIAL GUESS ORBITAL:',I

    ! OVERLAP
    R=RORB(:,:,:,:,I)
    CALL COMPARE(R,R,S_C,I,'OVERLAP (YLM)     ')
    CALL COMPARE_DIRECT(ORBITALS(:,:,I),ORBITALS(:,:,I),S_C,I,'OVERLAP (DIR)     ')

    ! KINETIC
    CALL KINETICYLM(R,RR)
    CALL COMPARE(R,RR,T_C,I,'KINETIC (YLM 2ND) ')

    ! ALTERNATIVE KINETIC
!   OV=0.5D0*SINGLEENERGY(RXORB(:,:,:,:,I),RXORB(:,:,:,:,I))
!   OV=OV+0.5D0*SINGLEENERGY(RYORB(:,:,:,:,I),RYORB(:,:,:,:,I))
!   OV=OV+0.5D0*SINGLEENERGY(RZORB(:,:,:,:,I),RZORB(:,:,:,:,I))
!   WRITE(6,'(A,F15.10,A)') 'KINETIC (YLM 1ST)  = ',OV,' HARTREE'

    ! KINETIC (DIRECT)
    CALL KINETIC_DIRECT(ORBITALS(:,:,I),TORB)
    OV=OVERLAP(ORBITALS(:,:,I),TORB)
    WRITE(6,'(A,F15.10,A)') 'KINETIC (DIR 2ND)  = ',OV,' HARTREE'

    ! ALTERNATIVE KINETIC (DIRECT)
!   OV=0.5D0*OVERLAP(DXORBITALS(:,:,I),DXORBITALS(:,:,I))
!   OV=OV+0.5D0*OVERLAP(DYORBITALS(:,:,I),DYORBITALS(:,:,I))
!   OV=OV+0.5D0*OVERLAP(DZORBITALS(:,:,I),DZORBITALS(:,:,I))
!   WRITE(6,'(A,F15.10,A)') 'KINETIC (DIR 1ST)  = ',OV,' HARTREE'

    ! NUCLEAR
    CALL EXTERNLYLM(R,RR)
    CALL COMPARE(R,RR,N_C(:,:,0,0,0),I,'NUCLEAR (YLM)     ')

    ! NUCLEAR (DIRECT)
    CALL EXTERNL_DIRECT(ORBITALS(:,:,I),TORB)
    OV=OVERLAP(ORBITALS(:,:,I),TORB)
    WRITE(6,'(A,F15.10,A)') 'NUCLEAR (DIR)      = ',OV,' HARTREE'

    ! COULOMB
    CALL COULOMBYLM(R,RR)
    CALL COMPARE(R,RR,C_C(:,:,0,0,0),I,'COULOMB (YLM)     ')

    ! COULOMB (DIRECT)
    CALL COULOMB_DIRECT(ORBITALS(:,:,I),TORB)
    OV=OVERLAP(ORBITALS(:,:,I),TORB)
    WRITE(6,'(A,F15.10,A)') 'COULOMB (DIR)      = ',OV,' HARTREE'

    ! ALTERNATIVE COULOMB
!   CALL CONSTRUCTJ_PARTIALWAVE(RRHO,RR)
!   OV=0.5D0*SINGLEENERGY(R,RR)
!   WRITE(6,'(A,F15.10,A)') 'COULOMB (PARTIALW) = ',OV,' HARTREE'

    ! EXCHANGE
    TEMP(:,:)=-0.5D0*X_C(:,:,0,0,0)
    CALL EXCHANGEYLM(R,RR)
    CALL COMPARE(R,RR,TEMP,I,'EXCHANGE (YLM)    ')

    ! EXCHANGE (DIRECT)
    CALL EXCHANGE_DIRECT(ORBITALS(:,:,I),TORB)
    OV=OVERLAP(ORBITALS(:,:,I),TORB)
    WRITE(6,'(A,F15.10,A)') 'EXCHANGE (DIR)     = ',OV,' HARTREE'

    ! FOCK
    TEMP(:,:)=T_C(:,:,0,0,0)+C_C(:,:,0,0,0)+N_C(:,:,0,0,0)-0.5D0*X_C(:,:,0,0,0)
    CALL FOCKYLM(R,RR)
    CALL COMPARE(R,RR,TEMP,I,'FOCK              ')

    ! FOCK (DIRECT)
    CALL FOCK_DIRECT(ORBITALS(:,:,I),TORB)
    OV=OVERLAP(ORBITALS(:,:,I),TORB)
    WRITE(6,'(A,F15.10,A)') 'FOCK (DIR)         = ',OV,' HARTREE'

   ENDDO

   ! HARTREE-FOCK ENERGY
   PREVIOUS=HFENERGY()
   WRITE(6,'(/,A,F15.10,A)') 'INITIAL HF (YLM) ENERGY  = ',PREVIOUS,' HARTREE'

   PREVIOUS=HFENERGY_DIRECT()
   WRITE(6,'(  A,F15.10,A)') 'INITIAL HF (DIR) ENERGY  = ',PREVIOUS,' HARTREE'
   CALL PFLUSH(6)

   DEALLOCATE(TEMP,TORB)

   ! ITERATION
   WRITE(6,'(A)') ' '
   WRITE(6,'(A)') '----------------------------------------------'
   WRITE(6,'(A)') ' ITR  HOMO ENERGY       HF ENERGY    CPU / SEC'
   WRITE(6,'(A)') '----------------------------------------------'

   ALLOCATE(TEMP(MAXNGRID,NATOM))

   DO ITER=1,MAXITER

    IF (ITER == MAXITER) CALL PABORT('MAXITER REACHED')

    ! BUILD FOCK MATRIX
    CALL PCPU_TIME(ICPUS)
! --- now defunct YLM method from here
!   DO I=1,NAO
!    R(:,:,:,:)=AORB(:,:,:,:,I)
!    CALL FOCKYLM(R,RR)
!    DO J=1,NAO
!     FOCK(I,J)=SINGLEENERGY(AORB(:,:,:,:,J),RR)
!    ENDDO
!   ENDDO
! --- to here
    DO I=1,NAO
     CALL FOCK_DIRECT(AOBASIS(:,:,I),TEMP)
     DO J=1,NAO
      FOCK(I,J)=OVERLAP(AOBASIS(:,:,J),TEMP)
     ENDDO
    ENDDO
    ! SYMMETRIZE FOCK
    D=0.0D0
    DO I=1,NAO
     DO J=1,NAO
     IF (DABS(FOCK(J,I)-FOCK(I,J)) > D) D=DABS(FOCK(J,I)-FOCK(I,J))
     ENDDO
    ENDDO
    IF (ITER == 1) THEN
     WRITE(6,'(A,F15.10)') 'ASYMMETRY IN FOCK = ',D
     WRITE(6,'(A)') 'WARNING! FOCK MATRIX SYMMETRIZED!'
     CALL PFLUSH(6)
    ENDIF
    DO I=1,NAO
     DO J=1,NAO
      D=(FOCK(I,J)+FOCK(J,I))/2.0D0
      FOCK(I,J)=D
      FOCK(J,I)=D
     ENDDO
    ENDDO
    CALL PCPU_TIME(ICPUE)

    ! DIAGONALIZE FOCK
    CALL DGEEV('N','V',NAO,FOCK,NAO,ER,EI,EVL,NAO,EVR,NAO,EWK,4*NAO,INFO)
    IF (INFO /= 0) CALL PABORT('DGEEV FAILED')
    CALL SORT_EIGENVALUES(NAO,NAO,ER,EI,EVL,EVR)
    CALL SCHMIDT_EIGENVECTORS(NAO,EVR) ! VERY IMPORTANT !
    DO I=1,NAO
     SG_EPSILON(I)=ER(I)
     ORBITALS(:,:,I)=0.0D0
     DO J=1,NAO
      DO IA=1,NATOM
       DO K=1,NGRID(IA)
        ORBITALS(K,IA,I)=ORBITALS(K,IA,I)+AOBASIS(K,IA,J)*EVR(J,I)
       ENDDO
      ENDDO
     ENDDO
    ENDDO
    DO I=1,IOCC
     DO IA=1,NATOM
      DO K=1,NGRID(IA)
       ORBITALS_SAVE(K,IA,I)=ORBITALS(K,IA,I)
      ENDDO
     ENDDO
    ENDDO
    CALL EXPANDORB
!   CALL CONSTRUCTDORB
    CALL CONSTRUCTRHO
!   CALL CONSTRUCTJ(RRHO,RJ)
!   DO IA=1,NATOM
!    CALL PACKYLM(POTENTIALJ(:,IA),RJ(:,:,:,IA),IA,IA)
!   ENDDO
    CALL CONSTRUCTJ_NEW(RHO,POTENTIALJ)
    DO IA=1,NATOM
     CALL EXPAND2YLM(POTENTIALJ(:,IA),RJ(:,:,:,IA),IA,IA)
    ENDDO
!   POTENTIALJ=POTENTIALJ*1.0D0/3.0D0+PREVIOUS_J*2.0D0/3.0D0
    PREVIOUS_J=POTENTIALJ
    CURRENT=HFENERGY_DIRECT()
    WRITE(6,'(I3,F14.8,F19.12,F10.1)') ITER,ER(IOCC),CURRENT,ICPUE-ICPUS
    CALL PFLUSH(6)
    IF (DABS(CURRENT-PREVIOUS) < DOPTN(14)) EXIT
    PREVIOUS=CURRENT

   ENDDO

   WRITE(6,'(A)') '----------------------------------------------'
   DO I=1,IOCC
    WRITE(6,'(A,I3,A,F18.12,A)') 'ORBITAL ENERGY (',I,') = ',ER(I),' HARTREE'
   ENDDO
   WRITE(6,'(A,F18.12,A)')  'CONVERGED HF ENERGY  = ',CURRENT,' HARTREE'
   CALL PFLUSH(6)

   DEALLOCATE(TEMP,ER,EI,EVR,EVL,EWK,FOCK)
   DEALLOCATE(AOBASIS,ORBITALS,RORB)

   RETURN
END SUBROUTINE



SUBROUTINE GRIDMP2

! Perform a first-quantized, grid-based, second-order Moeller-Plesset
! perturbation calculations largely adopting Becke-Dickson algorithms.

   USE CONSTANTS
   USE CONTROL
   USE STRUCTURE
   USE INTEGRAL
   USE BASISSET
   USE DFT
   USE SINANOGLU

   IMPLICIT NONE
   INTEGER,PARAMETER :: MAXITER=10
   INTEGER,PARAMETER :: MAXVECS=5
   DOUBLE PRECISION :: ICPUS,ICPUE
   INTEGER :: ISPIN
   INTEGER :: ITER,NVEC
   DOUBLE PRECISION,EXTERNAL :: OVERLAP
   DOUBLE PRECISION,EXTERNAL :: HFENERGY_DIRECT
   DOUBLE COMPLEX,ALLOCATABLE   :: RTEMP(:,:,:,:)  ! RADIAL FUNCTIONS ACTED ON BY SOME OPERATOR
   DOUBLE PRECISION,ALLOCATABLE :: EXCH(:,:,:)     ! FULL GRID EXCHANGE OPERATOR
   DOUBLE PRECISION,ALLOCATABLE :: EXCH_BASIS(:,:) ! EXCHANGE OPERATOR IN BASIS
!  DOUBLE PRECISION,ALLOCATABLE :: POISSON(:,:,:)  ! FULL GRID INVERSE DEL SQUARED
   DOUBLE PRECISION,ALLOCATABLE :: SEED(:,:,:,:)   ! SEED FUNCTION IN GRID
!  DOUBLE PRECISION,ALLOCATABLE :: SEED_HALF(:,:,:)! SEED FUNCTION IN GRID/BASIS
   DOUBLE PRECISION,ALLOCATABLE :: SEED_BASIS(:,:) ! SEED FUNCTION IN BASIS
   DOUBLE PRECISION,ALLOCATABLE :: RHS(:,:,:,:)    ! RIGHT-HAND SIDE OF SINANOGLU EQUATION IN GRID
   DOUBLE PRECISION,ALLOCATABLE :: RHS_BASIS(:,:)  ! RIGHT-HAND SIDE OF SINANOGLU EQUATION IN BASIS
!  DOUBLE PRECISION,ALLOCATABLE :: TEMP1(:,:,:,:)  ! TEMP ARRAY
!  DOUBLE PRECISION,ALLOCATABLE :: TEMP2(:,:,:,:)  ! TEMP ARRAY
!  DOUBLE PRECISION,ALLOCATABLE :: TEMP3(:,:,:,:)  ! TEMP ARRAY
   DOUBLE PRECISION :: TEMP1,TEMP2,TEMP3
   DOUBLE PRECISION,ALLOCATABLE :: TEMP4(:,:,:)    ! TEMP ARRAY
   DOUBLE PRECISION,ALLOCATABLE :: TEMP5(:,:)      ! TEMP ARRAY
   DOUBLE PRECISION,ALLOCATABLE :: PAIRE(:,:,:)    ! PAIR ENERGY
!  DOUBLE PRECISION,ALLOCATABLE :: PAIREA(:,:,:)   ! PAIR ENERGY
   DOUBLE PRECISION,ALLOCATABLE :: TIJ(:,:,:)      ! TRIAL PAIR FUNCTION IN BASIS
   DOUBLE PRECISION,ALLOCATABLE :: UIJ(:,:,:)      ! PRODUCT PAIR FUNCTION IN BASIS
   DOUBLE PRECISION,ALLOCATABLE :: TIJNEW(:,:)     ! TRIAL PAIR FUNCTION IN BASIS
   DOUBLE PRECISION,ALLOCATABLE :: UIJNEW(:,:)     ! PRODUCT PAIR FUNCTION IN BASIS
   DOUBLE PRECISION,ALLOCATABLE :: PIJ(:,:)        ! FULL PAIR FUNCTION IN BASIS
!  DOUBLE PRECISION,ALLOCATABLE :: PAIR_HALF(:,:,:)! PAIR FUNCTION IN GRID/BASIS
!  DOUBLE PRECISION,ALLOCATABLE :: PAIR(:,:,:,:)   ! FULL PAIR FUNCTION IN GRID
!  DOUBLE PRECISION,ALLOCATABLE :: PAIRMINUSSEED(:,:,:,:)   ! (PAIR FUNCTION - SEED FUNCTION) IN GRID
   DOUBLE PRECISION,ALLOCATABLE :: ORB1(:,:)       ! ORBITAL PAIR PRODUCT ON GRID
   DOUBLE PRECISION,ALLOCATABLE :: ORB2(:,:)       ! ORBITAL PAIR PRODUCT ON GRID
!  DOUBLE PRECISION,ALLOCATABLE :: ORB3(:,:)       ! ORBITAL PAIR PRODUCT ON GRID
!  DOUBLE PRECISION,ALLOCATABLE :: CORB1(:)        ! ORBITAL EXPANSION OF ORB1
!  DOUBLE PRECISION,ALLOCATABLE :: CORB2(:)        ! ORBITAL EXPANSION OF ORB2
   DOUBLE PRECISION :: X1,Y1,Z1,X2,Y2,Z2,U1
   DOUBLE PRECISION :: OV,PE1,PE2,PE3,PE4,PE0
   DOUBLE PRECISION,ALLOCATABLE :: A(:,:),B(:),C(:,:)
   DOUBLE PRECISION :: D
   INTEGER,ALLOCATABLE :: INDX(:)
   INTEGER :: INFO
   INTEGER :: I,J,K,L,II,JJ,KK,LL,IG,JG,KG,LG,IA,JA,KA,LA
   DOUBLE PRECISION,ALLOCATABLE :: ERI(:,:,:,:)
!double precision,allocatable :: poisson_basis(:,:,:)
   DOUBLE PRECISION,ALLOCATABLE :: FOCK(:,:)
   DOUBLE PRECISION,ALLOCATABLE :: ER(:),EI(:),EVR(:,:),EVL(:,:),EWK(:)
   DOUBLE PRECISION :: R12,RECIPROCALR12

!  DOUBLE PRECISION,ALLOCATABLE :: ER(:),EI(:),EVR(:,:),EVL(:,:),EWK(:)
!  ALLOCATE(ER(NAO),EI(NAO),EVR(NAO,NAO),EVL(NAO,NAO),EWK(4*NAO))

   IF (KVCX /= 0) CALL PABORT('SINANOGLU CALCULATION IS FOR MOLECULES ONLY')
   IF (KVCY /= 0) CALL PABORT('SINANOGLU CALCULATION IS FOR MOLECULES ONLY')
   IF (KVCZ /= 0) CALL PABORT('SINANOGLU CALCULATION IS FOR MOLECULES ONLY')
   DO IA=1,NATOM
    IF (MAXNGRID /= NGRID(IA)) CALL PABORT('DIFFERENTLY SIZED GRIDS FOR DIFFERENT ATOMS')
   ENDDO
   WRITE(6,'(/,A)') 'GRID-BASED SECOND-ORDER SINANOGLU CALCULATION WILL BE PERFORMED'
   IF (COPTN(102)=='F12') THEN
    WRITE(6,'(/,A)') 'TENNO EXPONENTIAL GEMINAL (F12)'
   ELSE IF (COPTN(102)=='R12') THEN
    WRITE(6,'(/,A)') 'KUTZELNIGG LINEAR GEMINAL (R12)'
   ELSE 
    CALL PABORT('UNKNOWN GEMINAL SPECIFIED')
   ENDIF
   WRITE(6,'(A,F15.8,A)') 'CONVERGENCE TOLERANCE = ',DOPTN(67),' (USE CICONV TO CHANGE)'

   ! PERFORM LARGER-SCALE HF
   CALL PCPU_TIME(ICPUS)
   CALL CONSTRUCTAO(LMAX/2)
   CALL PCPU_TIME(ICPUE)
 write(*,*) 'ao cpu =',icpue-icpus
 write(*,*) 'nao = ',nao
   ALLOCATE(ORBITALS(MAXNGRID,NATOM,NAO))
   ALLOCATE(RORB(0:LMAX,-LMAX:LMAX,RG,NATOM,NAO))
   ALLOCATE(ER(NAO),EI(NAO),EVR(NAO,NAO),EVL(NAO,NAO),EWK(4*NAO),FOCK(NAO,NAO))
   ALLOCATE(ORB1(MAXNGRID,NATOM),ORB2(MAXNGRID,NATOM))
   DO I=1,IOCC
    DO IA=1,NATOM
     DO K=1,NGRID(IA)
      ORBITALS(K,IA,I)=ORBITALS_SAVE(K,IA,I)
     ENDDO
    ENDDO
   ENDDO
   CALL EXPANDORB

   ! CONSTRUCT FOCK
   CALL PCPU_TIME(ICPUS)
!  CALL CONSTRUCTRHO
!  CALL CONSTRUCTJ(RRHO,RJ)
!  DO IA=1,NATOM
!   CALL PACKYLM(POTENTIALJ(:,IA),RJ(:,:,:,IA),IA,IA)
!  ENDDO
   DO I=1,NAO
    CALL FOCK_DIRECT(AOBASIS(:,:,I),ORB1)
    DO J=1,NAO
     FOCK(I,J)=OVERLAP(AOBASIS(:,:,J),ORB1)
    ENDDO
   ENDDO
   CALL PCPU_TIME(ICPUE)
 write(*,*) 'construct fock =',icpue-icpus
   ! SYMMETRIZE FOCK
   CALL PCPU_TIME(ICPUS)
   D=0.0D0
   DO I=1,NAO
    DO J=1,NAO
     IF (DABS(FOCK(J,I)-FOCK(I,J)) > D) D=DABS(FOCK(J,I)-FOCK(I,J))
    ENDDO
   ENDDO
   WRITE(6,'(A,F15.10)') 'ASYMMETRY IN FOCK = ',D
   WRITE(6,'(A)') 'WARNING! FOCK MATRIX SYMMETRIZED!'
   CALL PFLUSH(6)
   DO I=1,NAO
    DO J=1,NAO
     D=(FOCK(I,J)+FOCK(J,I))/2.0D0
     FOCK(I,J)=D
     FOCK(J,I)=D
    ENDDO
   ENDDO
   CALL PCPU_TIME(ICPUE)
 write(*,*) 'symmetrize fock =',icpue-icpus
   ! DIAGONALIZE FOCK
   CALL PCPU_TIME(ICPUS)
   CALL DGEEV('N','V',NAO,FOCK,NAO,ER,EI,EVL,NAO,EVR,NAO,EWK,4*NAO,INFO)
   IF (INFO /= 0) CALL PABORT('DGEEV FAILED')
   CALL SORT_EIGENVALUES(NAO,NAO,ER,EI,EVL,EVR)
   CALL SCHMIDT_EIGENVECTORS(NAO,EVR) ! VERY IMPORTANT !
   DO I=1,NAO
    SG_EPSILON(I)=ER(I)
    ORBITALS(:,:,I)=0.0D0
    DO J=1,NAO
     DO IA=1,NATOM
      DO K=1,NGRID(IA)
       ORBITALS(K,IA,I)=ORBITALS(K,IA,I)+AOBASIS(K,IA,J)*EVR(J,I)
      ENDDO
     ENDDO
    ENDDO
   ENDDO
   CALL CONSTRUCTRHO
!  CALL CONSTRUCTJ(RRHO,RJ)
!  DO IA=1,NATOM
!   CALL PACKYLM(POTENTIALJ(:,IA),RJ(:,:,:,IA),IA,IA)
!  ENDDO
   CALL CONSTRUCTJ_NEW(RHO,POTENTIALJ)
   DO IA=1,NATOM
    CALL EXPAND2YLM(POTENTIALJ(:,IA),RJ(:,:,:,IA),IA,IA)
   ENDDO
   CALL PCPU_TIME(ICPUE)
   D=HFENERGY_DIRECT()
   WRITE(6,'(A)') '---------------------------------------------------'
   WRITE(6,'(A,F19.12,A,F8.1,A)') 'HF ENERGY = ',D,' HARTREE',ICPUE-ICPUS,' SEC'
   WRITE(6,'(A)') '---------------------------------------------------'
   CALL PFLUSH(6)

   ! CONSTRUCT DERIVATIVES OF ORBITALS
   CALL PCPU_TIME(ICPUS)
   ALLOCATE(DXORBITALS(MAXNGRID,NATOM,NAO))
   ALLOCATE(DYORBITALS(MAXNGRID,NATOM,NAO))
   ALLOCATE(DZORBITALS(MAXNGRID,NATOM,NAO))
   ALLOCATE(RXORB(0:LMAX,-LMAX:LMAX,RG,NATOM,NAO))
   ALLOCATE(RYORB(0:LMAX,-LMAX:LMAX,RG,NATOM,NAO))
   ALLOCATE(RZORB(0:LMAX,-LMAX:LMAX,RG,NATOM,NAO))
   CALL EXPANDORB
   CALL CONSTRUCTDORB
   CALL PCPU_TIME(ICPUE)
   WRITE(6,'(A,F10.1,A)') 'ORBITAL DERIVATIVES CONSTRUCTED   ',ICPUE-ICPUS,' SEC'
   CALL PCPU_TIME(ICPUS)

   ! BUILD FULL BASIS INVERSE DEL-SQUARED MATRIX
!write(*,*) 'now poisson is wrt AOBASIS2',nao2
!   DO I=1,NAO2
!    CALL POISSON_DIRECT(AOBASIS2(:,:,I),POISSON(:,:,I))
!   ENDDO
!write(*,*) 'now poisson_basis is wrt orbitals',nao
!  DO I=1,NAO
!   CALL POISSON_DIRECT(ORBITALS(:,:,I),POISSON_BASIS(:,:,I))
!  ENDDO
!  CALL PCPU_TIME(ICPUE)
!  WRITE(6,'(A,F10.1,A)') 'INVERSE DEL-SQUARED CONSTRUCTED   ',ICPUE-ICPUS,' SEC'
!  CALL PCPU_TIME(ICPUS)
!  CALL PFLUSH(6)

   ALLOCATE(EXCH(MAXNGRID,NATOM,NAO))
   ALLOCATE(EXCH_BASIS(NAO,NAO))
   ALLOCATE(SEED(MAXNGRID,NATOM,MAXNGRID,NATOM))
   ALLOCATE(SEED_BASIS(NAO,NAO))
   ALLOCATE(RHS(MAXNGRID,NATOM,MAXNGRID,NATOM))
   ALLOCATE(RHS_BASIS(NAO,NAO))
   ALLOCATE(TEMP4(NAO,MAXNGRID,NATOM))
   ALLOCATE(TIJ(NAO,NAO,MAXVECS))
   ALLOCATE(UIJ(NAO,NAO,MAXVECS))
   ALLOCATE(TIJNEW(NAO,NAO))
   ALLOCATE(UIJNEW(NAO,NAO))
   ALLOCATE(PIJ(NAO,NAO))
   ALLOCATE(ERI(NAO,NAO,IOCC,IOCC))

   ! ERI CALCULATIONS
call cpu_time(icpus)
   DO I=1,IOCC
    DO J=1,IOCC
     DO K=1,NAO
      DO IA=1,NATOM
       DO IG=1,NGRID(IA)
        ORB2(IG,IA)=ORBITALS(IG,IA,K)*ORBITALS(IG,IA,I)
       ENDDO
      ENDDO
      CALL POISSON_DIRECT(ORB2,ORB1)
      DO L=1,NAO
       OV=0.0D0
       DO IA=1,NATOM
        DO IG=1,NGRID(IA)
         OV=OV+GRIDW(IG,IA)*ORB1(IG,IA)*ORBITALS(IG,IA,L)*ORBITALS(IG,IA,J)
        ENDDO
       ENDDO
       ERI(K,L,I,J)=OV
      ENDDO
     ENDDO
    ENDDO
   ENDDO
call cpu_time(icpue)
   WRITE(6,'(A,F10.1,A)') 'ERI CALCULATION                   ',ICPUE-ICPUS,' SEC'
   CALL PFLUSH(6)

   ! BUILD FULL BASIS EXCHANGE MATRIX
   CALL PCPU_TIME(ICPUS)
   DO I=1,NAO
    CALL EXCHANGE_DIRECT(ORBITALS(:,:,I),EXCH(:,:,I))
    DO J=1,NAO
     EXCH_BASIS(J,I)=0.0D0
     DO IA=1,NATOM
      DO IG=1,NGRID(IA)
       EXCH_BASIS(J,I)=EXCH_BASIS(J,I)+EXCH(IG,IA,I)*ORBITALS(IG,IA,J)*GRIDW(IG,IA)
      ENDDO
     ENDDO
    ENDDO
   ENDDO
   CALL PCPU_TIME(ICPUE)
   WRITE(6,'(A,F10.1,A)') 'EXCHANGE MATRIX CONSTRUCTED       ',ICPUE-ICPUS,' SEC'
   CALL PFLUSH(6)

   ALLOCATE(PAIRE(IOCC,IOCC,2))
   PAIRE=0.0D0

   DO I=1,IOCC
    DO J=I,IOCC
     DO ISPIN=1,2 ! 1: SINGLET; 2: TRIPLET

      IF ((I==J).AND.(ISPIN==2)) CYCLE

      CALL PCPU_TIME(ICPUS)
      IF (ISPIN==1) WRITE(6,'(A,2I5)') 'SINGLET PAIR:',I,J
      IF (ISPIN==2) WRITE(6,'(A,2I5)') 'TRIPLET PAIR:',I,J
      CALL PFLUSH(6)

      ! FORM RIGHT-HAND SIDE & SEED FUNCTION
      IF (ISPIN==1) THEN

       ! SINGLET PAIR
       DO IA=1,NATOM
        DO IG=1,NGRID(IA)
         X2=ATOMX(IA)+GRIDX(IG,IA)
         Y2=ATOMY(IA)+GRIDY(IG,IA)
         Z2=ATOMZ(IA)+GRIDZ(IG,IA)
         DO JA=1,NATOM
          DO JG=1,NGRID(JA)
           X1=ATOMX(JA)+GRIDX(JG,JA)
           Y1=ATOMY(JA)+GRIDY(JG,JA)
           Z1=ATOMZ(JA)+GRIDZ(JG,JA)
           R12=DSQRT((X1-X2)**2+(Y1-Y2)**2+(Z1-Z2)**2)
           IF ((IA==JA).AND.(JG==IG)) THEN
            RECIPROCALR12=0.0D0
           ELSE
            RECIPROCALR12=1.0D0/R12
           ENDIF
           IF (COPTN(102)=='F12') THEN
            D=DEXP(-R12)
            IF ((IA==JA).AND.(JG==IG)) THEN
             U1=1.5D0
            ELSE
             U1=RECIPROCALR12*(1.0D0-D)+0.5D0*D
            ENDIF
            TEMP3=(ORBITALS(JG,JA,I)*ORBITALS(IG,IA,J)+ORBITALS(JG,JA,J)*ORBITALS(IG,IA,I))
            TEMP1=U1*TEMP3-0.5D0*DEXP(-R12)*RECIPROCALR12 &
            *(((X1-X2)*DXORBITALS(JG,JA,I)+(Y1-Y2)*DYORBITALS(JG,JA,I)+(Z1-Z2)*DZORBITALS(JG,JA,I))*ORBITALS(IG,IA,J) &
             +((X1-X2)*DXORBITALS(JG,JA,J)+(Y1-Y2)*DYORBITALS(JG,JA,J)+(Z1-Z2)*DZORBITALS(JG,JA,J))*ORBITALS(IG,IA,I) &
             +((X2-X1)*DXORBITALS(IG,IA,J)+(Y2-Y1)*DYORBITALS(IG,IA,J)+(Z2-Z1)*DZORBITALS(IG,IA,J))*ORBITALS(JG,JA,I) &
             +((X2-X1)*DXORBITALS(IG,IA,I)+(Y2-Y1)*DYORBITALS(IG,IA,I)+(Z2-Z1)*DZORBITALS(IG,IA,I))*ORBITALS(JG,JA,J))
            TEMP2=-0.5D0*(1.0D0-D)
            SEED(JG,JA,IG,IA)=TEMP2*TEMP3
           ELSE IF (COPTN(102)=='R12') THEN
            TEMP1=-0.5D0*RECIPROCALR12 &
            *(((X1-X2)*DXORBITALS(JG,JA,I)+(Y1-Y2)*DYORBITALS(JG,JA,I)+(Z1-Z2)*DZORBITALS(JG,JA,I))*ORBITALS(IG,IA,J) &
             +((X1-X2)*DXORBITALS(JG,JA,J)+(Y1-Y2)*DYORBITALS(JG,JA,J)+(Z1-Z2)*DZORBITALS(JG,JA,J))*ORBITALS(IG,IA,I) &
             +((X2-X1)*DXORBITALS(IG,IA,J)+(Y2-Y1)*DYORBITALS(IG,IA,J)+(Z2-Z1)*DZORBITALS(IG,IA,J))*ORBITALS(JG,JA,I) &
             +((X2-X1)*DXORBITALS(IG,IA,I)+(Y2-Y1)*DYORBITALS(IG,IA,I)+(Z2-Z1)*DZORBITALS(IG,IA,I))*ORBITALS(JG,JA,J))
            TEMP2=-0.5D0*R12
            TEMP3=(ORBITALS(JG,JA,I)*ORBITALS(IG,IA,J)+ORBITALS(JG,JA,J)*ORBITALS(IG,IA,I))
            SEED(JG,JA,IG,IA)=TEMP2*TEMP3
           ENDIF
           RHS(JG,JA,IG,IA)=TEMP1+TEMP2*(EXCH(JG,JA,I)*ORBITALS(IG,IA,J)+EXCH(JG,JA,J)*ORBITALS(IG,IA,I) &
                                        +EXCH(IG,IA,I)*ORBITALS(JG,JA,J)+EXCH(IG,IA,J)*ORBITALS(JG,JA,I))
          ENDDO
         ENDDO
        ENDDO
       ENDDO

       ! TRANSFORM SEED
       DO JA=1,NATOM
        DO JG=1,NGRID(JA)
         DO II=1,NAO
          TEMP4(II,JG,JA)=0.0D0
          DO IA=1,NATOM
           DO IG=1,NGRID(IA)
            TEMP4(II,JG,JA)=TEMP4(II,JG,JA)+SEED(IG,IA,JG,JA)*ORBITALS(IG,IA,II)*GRIDW(IG,IA)
           ENDDO
          ENDDO
         ENDDO
        ENDDO
       ENDDO
       DO II=1,NAO
        DO JJ=1,NAO
         SEED_BASIS(II,JJ)=0.0D0
         DO JA=1,NATOM
          DO JG=1,NGRID(JA)
           SEED_BASIS(II,JJ)=SEED_BASIS(II,JJ)+TEMP4(II,JG,JA)*ORBITALS(JG,JA,JJ)*GRIDW(JG,JA)
          ENDDO
         ENDDO
        ENDDO
       ENDDO
       CALL SYMMETRIZE(NAO,SEED_BASIS,ISPIN)

       ! CONSTRUCT FULL RHS
       DO JA=1,NATOM
        DO JG=1,NGRID(JA)
         DO II=1,NAO
          TEMP4(II,JG,JA)=0.0D0
          DO IA=1,NATOM
           DO IG=1,NGRID(IA)
            TEMP4(II,JG,JA)=TEMP4(II,JG,JA)+RHS(IG,IA,JG,JA)*ORBITALS(IG,IA,II)*GRIDW(IG,IA)
           ENDDO
          ENDDO
         ENDDO
        ENDDO
       ENDDO
       DO II=1,NAO
        DO JJ=1,NAO
         RHS_BASIS(II,JJ)=0.0D0
         DO JA=1,NATOM
          DO JG=1,NGRID(JA)
           RHS_BASIS(II,JJ)=RHS_BASIS(II,JJ)+TEMP4(II,JG,JA)*ORBITALS(JG,JA,JJ)*GRIDW(JG,JA)
          ENDDO
         ENDDO
        ENDDO
       ENDDO
       DO II=1,NAO
        DO JJ=1,NAO
         DO KK=1,NAO
          RHS_BASIS(II,JJ)=RHS_BASIS(II,JJ)-EXCH_BASIS(JJ,KK)*SEED_BASIS(KK,II)-EXCH_BASIS(II,KK)*SEED_BASIS(KK,JJ)
         ENDDO
        ENDDO
       ENDDO

      ELSE

       ! TRIPLET PAIR
       DO IA=1,NATOM
        DO IG=1,NGRID(IA)
         X2=ATOMX(IA)+GRIDX(IG,IA)
         Y2=ATOMY(IA)+GRIDY(IG,IA)
         Z2=ATOMZ(IA)+GRIDZ(IG,IA)
         DO JA=1,NATOM
          DO JG=1,NGRID(JA)
           X1=ATOMX(JA)+GRIDX(JG,JA)
           Y1=ATOMY(JA)+GRIDY(JG,JA)
           Z1=ATOMZ(JA)+GRIDZ(JG,JA)
           R12=DSQRT((X1-X2)**2+(Y1-Y2)**2+(Z1-Z2)**2)
           IF ((IA==JA).AND.(IG==JG)) THEN
            RECIPROCALR12=0.0D0
           ELSE
            RECIPROCALR12=1.0D0/R12
           ENDIF
           RHS(JG,JA,IG,IA)=(ORBITALS(JG,JA,I)*ORBITALS(IG,IA,J)-ORBITALS(JG,JA,J)*ORBITALS(IG,IA,I))*RECIPROCALR12
          ENDDO
         ENDDO
        ENDDO
       ENDDO

       ! TRANSFORM RHS
       DO JA=1,NATOM
        DO JG=1,NGRID(JA)
         DO II=1,NAO
          TEMP4(II,JG,JA)=0.0D0
          DO IA=1,NATOM
           DO IG=1,NGRID(IA)
            TEMP4(II,JG,JA)=TEMP4(II,JG,JA)+RHS(IG,IA,JG,JA)*ORBITALS(IG,IA,II)*GRIDW(IG,IA)
           ENDDO
          ENDDO
         ENDDO
        ENDDO
       ENDDO
       DO II=1,NAO
        DO JJ=1,NAO
         RHS_BASIS(II,JJ)=0.0D0
         DO JA=1,NATOM
          DO JG=1,NGRID(JA)
           RHS_BASIS(II,JJ)=RHS_BASIS(II,JJ)+TEMP4(II,JG,JA)*ORBITALS(JG,JA,JJ)*GRIDW(JG,JA)
          ENDDO
         ENDDO
        ENDDO
       ENDDO

      ENDIF
!call dump5(rhs,ngrid(1))
!call dump5(seed,ngrid(1))

!     CALL QPROJECTOR_GRID(SEED)
      CALL QPROJECTOR_MO(RHS_BASIS)
      CALL SYMMETRIZE(NAO,RHS_BASIS,ISPIN)

      ! INITIAL GUESS, WHICH SHOULD BE NEAR EXACT
      TIJ(:,:,1)=0.0D0
      DO II=IOCC+1,NAO
       DO JJ=IOCC+1,NAO
        TIJ(JJ,II,1)=RHS_BASIS(JJ,II)/(SG_EPSILON(JJ)+SG_EPSILON(II)-SG_EPSILON(J)-SG_EPSILON(I))
       ENDDO
      ENDDO
!call dump5(tij(:,:,1),nao)

      CALL PCPU_TIME(ICPUE)
      WRITE(6,'(A,F10.1,A)') 'CONSTRUCTION OF RHS AND GUESS     ',ICPUE-ICPUS,' SEC'
      WRITE(6,'(A)') '-------------------------------------------------------------------------------------------------------'
      WRITE(6,'(A)') ' ITR    RESIDUAL      LEFT-HAND SIDE +  RIGHT-HAND SIDE  +   PAIR ENERGY    =      SUM        CPU / SEC'
      WRITE(6,'(A)') '-------------------------------------------------------------------------------------------------------'
      CALL PFLUSH(6)

      DO ITER=1,MAXITER

       IF (ITER == MAXITER) CALL PABORT('MAXITER REACHED')

       NVEC=MIN(ITER,MAXVECS)

       CALL PCPU_TIME(ICPUS)

       ! ACT FOCK OPERATOR ON GUESS
       DO II=1,NAO
        DO JJ=1,NAO
         UIJ(JJ,II,NVEC)=(SG_EPSILON(II)+SG_EPSILON(JJ)-SG_EPSILON(I)-SG_EPSILON(J))*TIJ(JJ,II,NVEC)
        ENDDO
       ENDDO

       CALL QPROJECTOR_MO(UIJ(:,:,NVEC))
       CALL SYMMETRIZE(NAO,UIJ(:,:,NVEC),ISPIN)

       ! SOLVE SUBSPACE LINEAR EQUATION
       ALLOCATE(A(NVEC,NVEC),B(NVEC),INDX(NVEC))
       DO K=1,NVEC
        B(K)=0.0D0
        DO II=1,NAO
         DO JJ=1,NAO
          B(K)=B(K)+UIJ(JJ,II,K)*RHS_BASIS(JJ,II)
         ENDDO
        ENDDO
       ENDDO
       DO K=1,NVEC
        DO L=1,NVEC
         A(L,K)=0.0D0
         DO II=1,NAO
          DO JJ=1,NAO
           A(L,K)=A(L,K)+UIJ(JJ,II,L)*UIJ(JJ,II,K)
          ENDDO
         ENDDO
        ENDDO
       ENDDO
       IF (IOPTN(9) >= 2) CALL DUMP5(A,NVEC)
       CALL DGESV(NVEC,1,A,NVEC,INDX,B,NVEC,INFO)
       IF (INFO /= 0) CALL PABORT('DGESV FAILED')
       IF (IOPTN(9) >= 2) WRITE(6,*) B
       TIJNEW(:,:)=0.0D0
       UIJNEW(:,:)=0.0D0
       DO K=1,NVEC
        TIJNEW(:,:)=TIJNEW(:,:)+TIJ(:,:,K)*B(K)
        UIJNEW(:,:)=UIJNEW(:,:)+UIJ(:,:,K)*B(K)
       ENDDO
       DEALLOCATE(A,B,INDX)
       CALL QPROJECTOR_MO(TIJNEW)
       CALL SYMMETRIZE(NAO,TIJNEW,ISPIN)
!call dump5(tijnew,nao)

       ! REORGANIZE TRIAL VECTORS
       TIJ(:,:,1)=TIJNEW
       UIJ(:,:,1)=UIJNEW
       IF (NVEC==MAXVECS) THEN
        DO K=2,NVEC-1
         TIJ(:,:,K)=TIJ(:,:,K+1)
         UIJ(:,:,K)=UIJ(:,:,K+1)
        ENDDO
       ENDIF

       ! CALCULATE SINGLET PAIR ENERGY
       IF (ISPIN==1) THEN

        ! FORM FULL PAIR FUNCTION IN BASIS
        DO II=1,NAO
         DO JJ=1,NAO
          PIJ(JJ,II)=TIJNEW(JJ,II)+SEED_BASIS(JJ,II)
         ENDDO
        ENDDO
        CALL QPROJECTOR_MO(PIJ)
        CALL SYMMETRIZE(NAO,PIJ,ISPIN)
!call dump5(pij,nao)

! ===== PLAIN MP2
call cpu_time(icpus)
        PE0=0.0D0
        DO K=IOCC+1,NAO
         DO L=IOCC+1,NAO
          PE0=PE0+ERI(K,L,I,J)*(0.50D0*ERI(K,L,I,J)+0.50D0*ERI(K,L,J,I)) &
             /(SG_EPSILON(I)+SG_EPSILON(J)-SG_EPSILON(K)-SG_EPSILON(L))
         ENDDO
        ENDDO
call cpu_time(icpue)
write(*,'(A23,F25.15,F20.2)') 'pe0 (eri)      =',pe0,icpue-icpus
call cpu_time(icpus)
! ===== 1ST TERM
call cpu_time(icpus)
        PE1=0.0D0
        DO II=1,NAO
         DO JJ=1,NAO
          PE1=PE1+PIJ(JJ,II)*UIJNEW(JJ,II)
         ENDDO
        ENDDO
        PE1=PE1*0.25D0
call cpu_time(icpue)
write(*,'(A23,F25.15,F20.2)') 'pe1 (in basis) =',pe1,icpue-icpus
call cpu_time(icpus)
! ===== 2ND TERM
        PE2=0.0D0
        DO II=1,NAO
         DO JJ=1,NAO
          PE2=PE2-PIJ(JJ,II)*RHS_BASIS(JJ,II)
         ENDDO
        ENDDO
        PE2=PE2*0.25D0
call cpu_time(icpue)
write(*,'(A23,F25.15,F20.2)') 'pe2 (in basis) =',pe2,icpue-icpus
call cpu_time(icpus)
! ----- 2-ELECTRON (NEW 2)
call cpu_time(icpus)
        PE4=0.0D0
        DO II=1,NAO
         DO JJ=1,NAO
          PE4=PE4-TIJNEW(JJ,II)*(ERI(JJ,II,J,I)+ERI(JJ,II,I,J))
         ENDDO
        ENDDO
 call cpu_time(icpue)
 write(*,'(A23,F25.15,F20.2)') '2e (eri tij)   =',pe4/4.0d0,icpue-icpus
call pflush(6)
 call cpu_time(icpus)
        DO IA=1,NATOM
         DO IG=1,NGRID(IA)
          X2=ATOMX(IA)+GRIDX(IG,IA)
          Y2=ATOMY(IA)+GRIDY(IG,IA)
          Z2=ATOMZ(IA)+GRIDZ(IG,IA)
          DO JA=1,NATOM
           DO JG=1,NGRID(JA)
            IF ((IA==JA).AND.(IG==JG)) THEN
             PE4=PE4-GRIDW(JG,JA)*GRIDW(IG,IA) &
                *(-0.5D0)*(ORBITALS(JG,JA,I)*ORBITALS(IG,IA,J)+ORBITALS(JG,JA,J)*ORBITALS(IG,IA,I)) &
                *(ORBITALS(JG,JA,I)*ORBITALS(IG,IA,J)+ORBITALS(JG,JA,J)*ORBITALS(IG,IA,I))
            ELSE
             X1=ATOMX(JA)+GRIDX(JG,JA)
             Y1=ATOMY(JA)+GRIDY(JG,JA)
             Z1=ATOMZ(JA)+GRIDZ(JG,JA)
             R12=DSQRT((X1-X2)**2+(Y1-Y2)**2+(Z1-Z2)**2)
             PE4=PE4-GRIDW(JG,JA)*GRIDW(IG,IA)*SEED(JG,JA,IG,IA)/R12 &
                *(ORBITALS(JG,JA,I)*ORBITALS(IG,IA,J)+ORBITALS(JG,JA,J)*ORBITALS(IG,IA,I))
            ENDIF
           ENDDO
          ENDDO
         ENDDO
        ENDDO
call cpu_time(icpue)
 write(*,'(A23,F25.15,F20.2)') '2e (eri seed)  =',pe4/4.0d0,icpue-icpus
call pflush(6)
! ----- 3-ELECTRON (NEW 2)
call cpu_time(icpus)
        ov=0.0d0
        DO K=1,IOCC
         DO L=1,NAO
          ov=ov+2.0D0*(ERI(K,L,I,J)+ERI(K,L,J,I))*SEED_BASIS(K,L)
         ENDDO
        ENDDO
        PE4=PE4+OV
call cpu_time(icpue)
write(*,'(A23,F25.15,F20.2)') '3e (eri)  =',ov/4.0d0,icpue-icpus
call pflush(6)
!! ----- 4-ELECTRON (NEW 2)
call cpu_time(icpus)
        ov=0.0d0
        DO K=1,IOCC
         DO L=1,IOCC
          ov=ov-(ERI(K,L,I,J)+ERI(K,L,J,I))*SEED_BASIS(K,L)
         ENDDO
        ENDDO
call cpu_time(icpue)
write(*,'(A23,F25.15,F20.2)') '4e (eri)  =',ov/4.0d0,icpue-icpus
call pflush(6)
        PE4=PE4+OV
        PE4=PE4*0.25D0

       ELSE

        ! TRIPLET PAIR ENERGY
! ===== PLAIN MP2
call cpu_time(icpus)
        PE0=0.0D0
        DO K=IOCC+1,NAO
         DO L=IOCC+1,NAO
          PE0=PE0+ERI(K,L,I,J)*(1.50D0*ERI(K,L,I,J)-1.50D0*ERI(K,L,J,I)) &
             /(SG_EPSILON(I)+SG_EPSILON(J)-SG_EPSILON(K)-SG_EPSILON(L))
         ENDDO
        ENDDO
call cpu_time(icpue)
write(*,'(A23,F25.15,F20.2)') 'pe0 (eri)      =',pe0,icpue-icpus
call cpu_time(icpus)
        PE1=0.0D0
        DO II=1,NAO
         DO JJ=1,NAO
          PE1=PE1+TIJNEW(JJ,II)*UIJNEW(JJ,II)
         ENDDO
        ENDDO
        PE1=PE1*0.75D0
call cpu_time(icpue)
write(*,'(A23,F25.15,F20.2)') 'pe1 (in basis) =',pe1,icpue-icpus
call cpu_time(icpus)
        PE2=0.0D0
        DO II=1,NAO
         DO JJ=1,NAO
          PE2=PE2-TIJNEW(JJ,II)*(ERI(JJ,II,I,J)+ERI(JJ,II,I,J))
         ENDDO
        ENDDO
        PE2=PE2*0.75D0
call cpu_time(icpue)
write(*,'(A23,F25.15,F20.2)') 'pe1 (in basis) =',pe1,icpue-icpus
        PE3=2.0D0*PE2+PE1

       ENDIF

       ! RESIDUAL
       TIJNEW(:,:)=UIJ(:,:,1)-RHS_BASIS(:,:)
       OV=0.0D0
       DO II=1,NAO
        DO JJ=1,NAO
         OV=OV+TIJNEW(JJ,II)*TIJNEW(JJ,II)
        ENDDO
       ENDDO
       CALL PCPU_TIME(ICPUE)
!      WRITE(6,'(I3,A,F25.10,A)') ITER,' RESIDUAL = ',OV
       IF (ISPIN==1) THEN
        WRITE(6,'(I3,F14.8,4F19.12,F10.1,A6)') ITER,0.0D0,0.0D0,0.0D0,PE0,PE0,ICPUE-ICPUS,' BASIS'
!       WRITE(6,'(I3,F14.8,4F19.12,F10.1,A6)') ITER,OV,PE1,PE2,PE3,PE1+PE2+PE3,ICPUE-ICPUS,'GRID'
        WRITE(6,'(I3,F14.8,4F19.12,F10.1,A6)') ITER,OV,PE1,PE2,PE4,PE1+PE2+PE4,ICPUE-ICPUS,' GRID'
       ELSE IF (ISPIN==2) THEN
        WRITE(6,'(I3,F14.8,4F19.12,F10.1,A6)') ITER,0.0D0,0.0D0,0.0D0,0.0D0,PE0,ICPUE-ICPUS,' BASIS'
        WRITE(6,'(I3,F14.8,4F19.12,F10.1,A6)') ITER,OV,PE1,PE2,0.0D0,PE3,ICPUE-ICPUS,' GRID'
       ENDIF
       CALL PFLUSH(6)
       IF (OV < DOPTN(67)) EXIT
       DO II=1,NAO
        DO JJ=1,NAO
         TIJNEW(JJ,II)=TIJNEW(JJ,II)/(SG_EPSILON(I)+SG_EPSILON(J)-SG_EPSILON(JJ)-SG_EPSILON(II))
        ENDDO
       ENDDO
       TIJ(:,:,MIN(NVEC+1,MAXVECS))=TIJNEW(:,:)

       ! SCHMIDT ORTHOGONALIZE
!      DO K=1,ITER
!       TIJ(:,:,ITER+1)=TIJ(:,:,ITER+1)-PAIRENERGY(NGRID(1),TIJ(:,:,K),TIJ(:,:,ITER+1))*TIJ(:,:,K)
!      ENDDO

      ENDDO

      WRITE(6,'(A)') '-------------------------------------------------------------------------------------------------------'
      IF (ISPIN==1) THEN
       PAIRE(I,J,ISPIN)=PE1+PE2+PE4
       PAIRE(J,I,ISPIN)=PE1+PE2+PE4
!      PAIREA(I,J,ISPIN)=PE1+PE2+PE4
!      PAIREA(J,I,ISPIN)=PE1+PE2+PE4
      ELSE
       PAIRE(I,J,ISPIN)=PE3
       PAIRE(J,I,ISPIN)=PE3
      ENDIF
      CALL PFLUSH(6)

     ENDDO
    ENDDO
   ENDDO

   OV=0.0D0
   DO I=1,IOCC
    DO J=1,IOCC
     OV=OV+PAIRE(I,J,1)
    ENDDO
   ENDDO
   WRITE(6,'(A,F25.15,A)') 'SINGLET ENERGY =',OV,' HARTREE'
   OV=0.0D0
   DO I=1,IOCC
    DO J=1,IOCC
     OV=OV+PAIRE(I,J,2)
    ENDDO
   ENDDO
   WRITE(6,'(A,F25.15,A)') 'TRIPLET ENERGY =',OV,' HARTREE'
   OV=0.0D0
   DO I=1,IOCC
    DO J=1,IOCC
     OV=OV+PAIRE(I,J,1)+PAIRE(I,J,2)
    ENDDO
   ENDDO
   WRITE(6,'(A,F25.15,A)') 'TOTAL ENERGY   =',OV,' HARTREE'
!  OV=0.0D0
!  DO I=1,IOCC
!   DO J=1,IOCC
!    OV=OV+PAIREA(I,J,1)
!   ENDDO
!  ENDDO
!  WRITE(6,'(A,F25.15,A)') 'SINGLET ENERGY (AUXILIARY) =',OV,' HARTREE'
!  OV=0.0D0
!  DO I=1,IOCC
!   DO J=1,IOCC
!    OV=OV+PAIRE(I,J,2)
!   ENDDO
!  ENDDO
!  WRITE(6,'(A,F25.15,A)') 'TRIPLET ENERGY (AUXILIARY) =',OV,' HARTREE'
!  OV=0.0D0
!  DO I=1,IOCC
!   DO J=1,IOCC
!    OV=OV+PAIREA(I,J,1)+PAIRE(I,J,2)
!   ENDDO
!  ENDDO
!  WRITE(6,'(A,F25.15,A)') 'TOTAL ENERGY   (AUXILIARY) =',OV,' HARTREE'
   CALL PFLUSH(6)

   ! DESTROY MP2 ARRAYS
   DEALLOCATE(EXCH,EXCH_BASIS,SEED,SEED_BASIS,RHS,RHS_BASIS)
   DEALLOCATE(TEMP4,TIJ,UIJ,TIJNEW,UIJNEW,PIJ)
   DEALLOCATE(ORB1,ORB2,ERI)
   DEALLOCATE(ER,EI,EVR,EVL,EWK,FOCK)

   ! DESTROY HF ARRAYS
   DEALLOCATE(SG_EPSILON,RN,RJ,RORB,RHO,RRHO,ORBITALS,ORBITALS_SAVE)
   DEALLOCATE(DXORBITALS,DYORBITALS,DZORBITALS,RXORB,RYORB,RZORB)
   DEALLOCATE(AOBASIS,POTENTIALJ,POTENTIALN,PREVIOUS_J)

   ! DESTROY GRID
   CALL SG_DESTROY_GRID
   DEALLOCATE(NGRID,GRIDX,GRIDY,GRIDZ,ATOMW,FUZZY,GRIDW)
   DEALLOCATE(FACTORIAL,SGN)
   RETURN
END SUBROUTINE



SUBROUTINE CONSTRUCTAO(HALFLMAX)
! Determine exponents of the Slater-type auxiliary basis functions
! s-, p-, d-, ..., AG-type real Cartesian Slater-spherical harmonics with shared exponents

   USE CONSTANTS
   USE CONTROL
   USE STRUCTURE
   USE INTEGRAL
   USE BASISSET
   USE DFT
   USE SINANOGLU

   IMPLICIT NONE
   INTEGER :: HALFLMAX
   INTEGER :: I,J,K,L,M,N,IA,JA
   INTEGER,ALLOCATABLE :: NBAS(:)
   DOUBLE PRECISION :: ICPUS,ICPUE
   DOUBLE PRECISION :: X,Y,Z,RR
   DOUBLE COMPLEX :: YLM1,YLM2
   DOUBLE PRECISION,ALLOCATABLE :: F(:),C(:,:,:)
   DOUBLE PRECISION,ALLOCATABLE :: A(:,:),ER(:),EI(:),EVR(:,:),EVL(:,:),EWK(:)
   DOUBLE PRECISION,ALLOCATABLE :: AOTEMP(:,:,:),AOEXP(:,:)
   INTEGER :: INFO
   INTEGER :: NBASTOTAL
! debug --
!  double complex :: r(0:lmax,-lmax:lmax,1:rg,1:natom)
!  double precision,external :: singleenergy
!  double precision,external :: overlap
!  double precision :: ov
! -- debug

   IF ((HALFLMAX < 0).OR.(HALFLMAX > LMAX/2)) HALFLMAX=LMAX/2
   WRITE(6,'(A,I3)') 'LMAX FOR AUX BASIS = ',HALFLMAX

   WRITE(6,'(A,E15.8,A)') 'LINEAR DEPENDENCY TOLERANCE   = ',DOPTN(85),' (USE LINDEP TO CHANGE)'

   ALLOCATE(NBAS(NATOM),AOEXP(RG,NATOM),C(RG,RG,NATOM))

   CALL PCPU_TIME(ICPUS)
   ! REMOVE LINEAR DEPENDENCIES FOR S-TYPE FOR EACH CENTER
   NBASTOTAL=0
   DO IA=1,NATOM

    ! DETERMINE THE EXPONENTS OF SLATER AUXILIARY FUNCTIONS
    ! GAUSS-CHEVYSHEV RADIAL-GRID BASED
    DO I=1,RG
     AOEXP(I,IA)=DLOG(2.0D0)/SG_GAUSS_CHEV(I,IA)
!    AOEXP(I,IA)=DLOG(2.0D0)/MAX(1.0D0,SG_GAUSS_CHEV(I,IA))
!    AOEXP(I,IA)=DFLOAT(IATOM(IA))/MAX(1.0D0,SG_GAUSS_CHEV(I,IA))
!write(*,*) aoexp(i,ia)
    ENDDO
    ! HYDROGENIC EXACT-SOLUTION BASED
!   DO I=1,RG
!    AOEXP(I,IA)=DFLOAT(IATOM(IA))/DFLOAT(I)
!write(*,*) aoexp(i,ia)
!   ENDDO
    ! EVEN TEMPERED
!   DO I=1,RG
!    AOEXP(I,IA)=DFLOAT(IATOM(IA))/(1.5D0**I)
!write(*,*) aoexp(i,ia)
!   ENDDO

    ALLOCATE(A(RG,RG),ER(RG),EI(RG),EVR(RG,RG),EVL(RG,RG),EWK(4*RG))

    ! BUILD OVERLAP MATRIX
    DO J=1,RG
     DO K=1,RG
      A(K,J)=0.0D0
      DO L=1,NGRID(IA)
       X=GRIDX(L,IA)
       Y=GRIDY(L,IA)
       Z=GRIDZ(L,IA)
       RR=DSQRT(X**2+Y**2+Z**2)
       A(K,J)=A(K,J)+DEXP(-AOEXP(K,IA)*RR)*DEXP(-AOEXP(J,IA)*RR)*ATOMW(L,IA)
      ENDDO
     ENDDO
    ENDDO
!   call dump10(a,rg,rg)

    ! DIAGONALIZE OVERLAP
    CALL DGEEV('N','V',RG,A,RG,ER,EI,EVL,RG,EVR,RG,EWK,4*RG,INFO)
    IF (INFO /= 0) CALL PABORT('DGEEV FAILED')
    CALL SORT_EIGENVALUES(RG,RG,ER,EI,EVL,EVR)
    CALL SCHMIDT_EIGENVECTORS(RG,EVR)
!do i=1,rg
! write(*,*) i,er(i)
!enddo
!call dump5(evr,rg)

    ! CANONICAL ORTHOGONALIZATION
    NBAS(IA)=0
    DO J=1,RG
     IF (ER(J) > DOPTN(85)) THEN
      NBAS(IA)=NBAS(IA)+1
      DO K=1,RG
       C(K,NBAS(IA),IA)=EVR(K,J)/DSQRT(ER(J))
      ENDDO
     ENDIF
    ENDDO

    WRITE(6,'(A,I0,A,I0)') 'NUMBER OF EXPONENTS FOR ATOM ',IA,' = ',NBAS(IA)
    DEALLOCATE(A,ER,EI,EVR,EVL,EWK)

    NBASTOTAL=NBASTOTAL+NBAS(IA)

   ENDDO
   CALL PCPU_TIME(ICPUE)
write(*,*) 'atomic cpu = ',icpue-icpus
   CALL PCPU_TIME(ICPUS)

write(*,*) MAXNGRID*NATOM*NBASTOTAL*(HALFLMAX+1)**2,' words'
   ALLOCATE(AOTEMP(MAXNGRID,NATOM,NBASTOTAL*(HALFLMAX+1)**2))

! debug from here -- 
!  DO IA=1,NATOM
!   DO J=1,RG
!    DO JA=1,NATOM
!     DO K=1,NGRID(JA)
!      CALL RYLM(0,0,K,RR,YLM1,JA,IA)
!      AOTEMP(K,JA,(IA-1)*RG+J)=DEXP(-AOEXP(J,IA)*RR)
!     ENDDO
!    ENDDO
!   ENDDO
!  ENDDO
!  allocate(A(RG*NATOM,RG*NATOM))
!  DO I=1,RG*NATOM
!   DO J=1,RG*NATOM
!    A(J,I)=0.0D0
!    DO IA=1,NATOM
!     DO K=1,NGRID(IA)
!      A(J,I)=A(J,I)+AOTEMP(K,IA,J)*AOTEMP(K,IA,I)*GRIDW(K,IA)
!     ENDDO
!    ENDDO
!   ENDDO
!  ENDDO
!  call dump10(a,rg*natom,rg*natom)
!  deallocate(A)
! -- to here


   ! CONSTRUCT REAL-SPACE AO
   NAO=0
   DO IA=1,NATOM
!write(*,*) "ia=",ia

    ! POPULATE S-TYPE AO
    DO J=1,NBAS(IA)
     NAO=NAO+1
     DO JA=1,NATOM
      DO K=1,NGRID(JA)
       CALL RYLM(0,0,K,RR,YLM1,JA,IA)
!      X=ATOMX(JA)+GRIDX(K,JA)-ATOMX(IA)
!      Y=ATOMY(JA)+GRIDY(K,JA)-ATOMY(IA)
!      Z=ATOMZ(JA)+GRIDZ(K,JA)-ATOMZ(IA)
!      RR=DSQRT(X**2+Y**2+Z**2)
       AOTEMP(K,JA,NAO)=0.0D0
       DO I=1,RG
        AOTEMP(K,JA,NAO)=AOTEMP(K,JA,NAO)+DEXP(-AOEXP(I,IA)*RR)*C(I,J,IA)
       ENDDO
      ENDDO
     ENDDO
    ENDDO

!do j=1,nbas(ia)
! ov=0.0d0
! do k=1,ngrid(ia)
!  ov=ov+aotemp(k,ia,j)*aotemp(k,ia,j)*atomw(k,ia)
! enddo
! write(*,'(i5,f20.10)') j,ov
!enddo

!do j=1,nbas(ia)
! ov=0.0d0
! do ja=1,natom
!  do k=1,ngrid(ja)
!   ov=ov+aotemp(k,ja,j)*aotemp(k,ja,j)*gridw(k,ja)
!if (ia == 1) &
!write(ja*100+j,'(4F20.10)') atomx(ja)+gridx(k,ja),atomy(ja)+gridy(k,ja),atomz(ja)+gridz(k,ja),&
!aotemp(k,ja,j)
!  enddo
! enddo
! write(*,'(i5,f20.10)') j,ov
!enddo

    ! POPULATE P-TYPE AND HIGHER AO
    IF (HALFLMAX > 0) THEN
     DO L=1,HALFLMAX
      DO J=1,NBAS(IA)
       NAO=NAO+1
       DO JA=1,NATOM
        DO K=1,NGRID(JA)
         CALL RYLM(L,0,K,RR,YLM1,JA,IA)
         AOTEMP(K,JA,NAO)=0.0D0
         DO I=1,RG
          AOTEMP(K,JA,NAO)=AOTEMP(K,JA,NAO)+YLM1*DEXP(-AOEXP(I,IA)*RR)*C(I,J,IA)
         ENDDO
        ENDDO
       ENDDO
      ENDDO
      DO M=1,L
       DO J=1,NBAS(IA)
        NAO=NAO+1
        DO JA=1,NATOM
         DO K=1,NGRID(JA)
          CALL RYLM(L,+M,K,RR,YLM1,JA,IA)
          CALL RYLM(L,-M,K,RR,YLM2,JA,IA)
          AOTEMP(K,JA,NAO)=0.0D0
          DO I=1,RG
           AOTEMP(K,JA,NAO)=AOTEMP(K,JA,NAO)+(YLM1+(-1.0D0)**M*YLM2)/DSQRT(2.0D0) &
                           *DEXP(-AOEXP(I,IA)*RR)*C(I,J,IA)
          ENDDO
         ENDDO
        ENDDO
       ENDDO
       DO J=1,NBAS(IA)
        NAO=NAO+1
        DO JA=1,NATOM
         DO K=1,NGRID(JA)
          CALL RYLM(L,+M,K,RR,YLM1,JA,IA)
          CALL RYLM(L,-M,K,RR,YLM2,JA,IA)
          AOTEMP(K,JA,NAO)=0.0D0
          DO I=1,RG
           AOTEMP(K,JA,NAO)=AOTEMP(K,JA,NAO)+DIMAG(YLM1-(-1.0D0)**M*YLM2)/DSQRT(2.0D0) &
                           *DEXP(-AOEXP(I,IA)*RR)*C(I,J,IA)
          ENDDO
         ENDDO
        ENDDO
       ENDDO
      ENDDO
     ENDDO
    ENDIF
   
   ENDDO
!write(*,*) 'nao=',nao
!write(*,*) 'mgrid=',mgrid
!do i=1,nao
!write(*,*) 'basis fxn',i
!do j=1,mgrid
! write(*,*) gridxa(j),gridya(j),gridza(j),aotemp(j,i)
!enddo
!enddo
   CALL PCPU_TIME(ICPUE)
write(*,*) 'ao cpu = ',icpue-icpus
   CALL PCPU_TIME(ICPUS)

   ! REMOVE LINEAR DEPENDENCIES

   ALLOCATE(A(NAO,NAO),ER(NAO),EI(NAO),EVR(NAO,NAO),EVL(NAO,NAO),EWK(4*NAO))

   ! BUILD OVERLAP MATRIX
   DO I=1,NAO
    DO J=1,NAO
     A(J,I)=0.0D0
     DO IA=1,NATOM
      DO K=1,NGRID(IA)
       A(J,I)=A(J,I)+AOTEMP(K,IA,J)*AOTEMP(K,IA,I)*GRIDW(K,IA)
      ENDDO
     ENDDO
    ENDDO
   ENDDO
!  call dump10(a,nao,nao)
   CALL PCPU_TIME(ICPUE)
write(*,*) 'overlap cpu = ',icpue-icpus
   CALL PCPU_TIME(ICPUS)

!write(*,*) 'Warning! No diagonalization of AOBASIS'
!do i=1,nao
!do j=1,nao
!if (j /= i) A(j,i)=0.0d0
!enddo
!enddo

   ! DIAGONALIZE OVERLAP
   CALL DGEEV('N','V',NAO,A,NAO,ER,EI,EVL,NAO,EVR,NAO,EWK,4*NAO,INFO)
   IF (INFO /= 0) CALL PABORT('DGEEV FAILED')
!  DO I=1,RG
!   IF (ER(I) < DOPTN(85)) THEN
!    WRITE(6,'(A,I3,2F15.10)') 'WARNING! LINEAR DEPENDENCY:',I,ER(I)
!   ENDIF
!  ENDDO
   CALL SORT_EIGENVALUES(NAO,NAO,ER,EI,EVL,EVR)
   CALL SCHMIDT_EIGENVECTORS(NAO,EVR)
   CALL PCPU_TIME(ICPUE)
write(*,*) 'diag cpu = ',icpue-icpus
   CALL PCPU_TIME(ICPUS)

   ! CANONICAL ORTHOGONALIZATION
   N=0
   DO I=1,NAO
    IF (ER(I) > DOPTN(85)) THEN
     N=N+1
     DO J=1,NAO
      EVL(J,N)=EVR(J,I)/DSQRT(ER(I))
     ENDDO
    ENDIF
   ENDDO
   WRITE(6,'(A,I0,A,I0)') 'NUMBER OF LINEAR DEPENDENCIES (LMAX = ',HALFLMAX,') = ',NAO-N
   WRITE(6,'(A,I0,A,I0)') 'NUMBER OF AUXILIARY FUNCTIONS (LMAX = ',HALFLMAX,') = ',N
write(*,*) 'ao lmax = ',lmax/2
   CALL PFLUSH(6)

   ALLOCATE(AOBASIS(MAXNGRID,NATOM,N))
   DO I=1,N
    DO IA=1,NATOM
     DO J=1,NGRID(IA)
      AOBASIS(J,IA,I)=0.0D0
      DO K=1,NAO
       AOBASIS(J,IA,I)=AOBASIS(J,IA,I)+AOTEMP(J,IA,K)*EVL(K,I)
      ENDDO
     ENDDO
    ENDDO
   ENDDO
   CALL PCPU_TIME(ICPUE)
write(*,*) 'new ao cpu = ',icpue-icpus
   CALL PCPU_TIME(ICPUS)

!  ALLOCATE(AORB(0:LMAX,-LMAX:LMAX,RG,NATOM,N))
!  AORB=DCMPLX(0.0D0,0.0D0)
!  DO IA=1,NATOM
!   DO K=1,N
!    CALL EXPAND2YLM(AOBASIS(:,IA,K),AORB(:,:,:,IA,K),IA,IA)
!   ENDDO
!  ENDDO
!  CALL PCPU_TIME(ICPUE)
!write(*,*) 'expand ao cpu = ',icpue-icpus
!  CALL PCPU_TIME(ICPUS)

   NAO=N

! debug --
!  do i=1,nao
!   do ia=1,natom
!    call expand2ylm(aobasis(:,ia,i),r(:,:,:,ia),1,1)
!   enddo
!   write(*,'(I5,2F15.10)') i,singleenergy(r,r),overlap(aobasis(:,:,i),aobasis(:,:,i))
!  enddo
!  write(*,*) "AOBASIS is pure spherical harmonics yet EXPAND2YLM does not work!"
!  ! BUILD OVERLAP MATRIX
!  DO I=1,NAO
!   DO J=1,NAO
!    A(J,I)=0.0D0
!    DO IA=1,NATOM
!     DO K=1,NGRID(IA)
!      A(J,I)=A(J,I)+AOBASIS(K,IA,J)*AOBASIS(K,IA,I)*GRIDW(K,IA)
!     ENDDO
!    ENDDO
!   ENDDO
!  ENDDO
!  call dump10(a,nao,nao)
! -- debug

   DEALLOCATE(A,ER,EI,EVR,EVL,EWK,AOTEMP,AOEXP,NBAS,C)

   RETURN
END SUBROUTINE



SUBROUTINE CONSTRUCTAO2
! Determine exponents of the Slater-type auxiliary basis functions
! s-, p-, d-, ..., AG-type real Cartesian Slater-spherical harmonics with shared exponents

   USE CONSTANTS
   USE CONTROL
   USE STRUCTURE
   USE INTEGRAL
   USE BASISSET
   USE DFT
   USE SINANOGLU

   IMPLICIT NONE
   INTEGER :: I,J,K,L,M,N,IA,JA
   INTEGER,ALLOCATABLE :: NBAS(:)
   DOUBLE PRECISION :: ICPUS,ICPUE
   DOUBLE PRECISION :: X,Y,Z,RR
   DOUBLE COMPLEX :: YLM1,YLM2
   DOUBLE PRECISION,ALLOCATABLE :: F(:),C(:,:,:)
   DOUBLE PRECISION,ALLOCATABLE :: A(:,:),ER(:),EI(:),EVR(:,:),EVL(:,:),EWK(:)
   DOUBLE PRECISION,ALLOCATABLE :: AOTEMP(:,:,:),AOEXP(:,:)
   INTEGER :: INFO

   WRITE(6,'(A,E15.8,A)') 'LINEAR DEPENDENCY TOLERANCE   = ',DOPTN(85),' (USE LINDEP TO CHANGE)'

   ALLOCATE(NBAS(NATOM),AOEXP(RG,NATOM),C(RG,RG,NATOM))

   CALL PCPU_TIME(ICPUS)
   ! REMOVE LINEAR DEPENDENCIES FOR S-TYPE FOR EACH CENTER
   DO IA=1,NATOM

    ! DETERMINE THE EXPONENTS OF SLATER AUXILIARY FUNCTIONS
    ! GAUSS-CHEVYSHEV RADIAL-GRID BASED
    DO I=1,RG
     AOEXP(I,IA)=DLOG(2.0D0)/SG_GAUSS_CHEV(I,IA)
!    AOEXP(I,IA)=DLOG(2.0D0)/MAX(1.0D0,SG_GAUSS_CHEV(I,IA))
!    AOEXP(I,IA)=DFLOAT(IATOM(IA))/MAX(1.0D0,SG_GAUSS_CHEV(I,IA))
!write(*,*) aoexp(i,ia)
    ENDDO
    ! HYDROGENIC EXACT-SOLUTION BASED
!   DO I=1,RG
!    AOEXP(I,IA)=DFLOAT(IATOM(IA))/DFLOAT(I)
!write(*,*) aoexp(i,ia)
!   ENDDO
    ! EVEN TEMPERED
!   DO I=1,RG
!    AOEXP(I,IA)=DFLOAT(IATOM(IA))/(1.5D0**I)
!write(*,*) aoexp(i,ia)
!   ENDDO

    ALLOCATE(A(RG,RG),ER(RG),EI(RG),EVR(RG,RG),EVL(RG,RG),EWK(4*RG))

    ! BUILD OVERLAP MATRIX
    DO J=1,RG
     DO K=1,RG
      A(K,J)=0.0D0
      DO L=1,NGRID(IA)
       X=GRIDX(L,IA)
       Y=GRIDY(L,IA)
       Z=GRIDZ(L,IA)
       RR=DSQRT(X**2+Y**2+Z**2)
       A(K,J)=A(K,J)+DEXP(-AOEXP(K,IA)*RR)*DEXP(-AOEXP(J,IA)*RR)*ATOMW(L,IA)
      ENDDO
     ENDDO
    ENDDO
!   call dump10(a,rg,rg)

    ! DIAGONALIZE OVERLAP
    CALL DGEEV('N','V',RG,A,RG,ER,EI,EVL,RG,EVR,RG,EWK,4*RG,INFO)
    IF (INFO /= 0) CALL PABORT('DGEEV FAILED')
    CALL SORT_EIGENVALUES(RG,RG,ER,EI,EVL,EVR)
    CALL SCHMIDT_EIGENVECTORS(RG,EVR)
!do i=1,rg
! write(*,*) i,er(i)
!enddo
!call dump5(evr,rg)

    ! CANONICAL ORTHOGONALIZATION
    NBAS(IA)=0
    DO J=1,RG
     IF (ER(J) > DOPTN(85)) THEN
      NBAS(IA)=NBAS(IA)+1
      DO K=1,RG
       C(K,NBAS(IA),IA)=EVR(K,J)/DSQRT(ER(J))
      ENDDO
     ENDIF
    ENDDO

    WRITE(6,'(A,I0,A,I0)') 'NUMBER OF EXPONENTS FOR ATOM ',IA,' = ',NBAS(IA)
    DEALLOCATE(A,ER,EI,EVR,EVL,EWK)

   ENDDO
   CALL PCPU_TIME(ICPUE)
write(*,*) 'atomic cpu = ',icpue-icpus
   CALL PCPU_TIME(ICPUS)

   ALLOCATE(AOTEMP(MAXNGRID,NATOM,NATOM*RG*(LMAX+1)**2))

   ! CONSTRUCT REAL-SPACE AO
   NAO2=0
   DO IA=1,NATOM

    ! POPULATE S-TYPE AO
    DO J=1,NBAS(IA)
     NAO2=NAO2+1
     DO JA=1,NATOM
      DO K=1,NGRID(JA)
       CALL RYLM(0,0,K,RR,YLM1,JA,IA)
       AOTEMP(K,JA,NAO2)=0.0D0
       DO I=1,RG
        AOTEMP(K,JA,NAO2)=AOTEMP(K,JA,NAO2)+DEXP(-AOEXP(I,IA)*RR)*C(I,J,IA)
       ENDDO
      ENDDO
     ENDDO
    ENDDO

    ! POPULATE P-TYPE AND HIGHER AO
    IF (LMAX > 0) THEN
     DO L=1,LMAX
      DO J=1,NBAS(IA)
       NAO2=NAO2+1
       DO JA=1,NATOM
        DO K=1,NGRID(JA)
         CALL RYLM(L,0,K,RR,YLM1,JA,IA)
         AOTEMP(K,JA,NAO2)=0.0D0
         DO I=1,RG
          AOTEMP(K,JA,NAO2)=AOTEMP(K,JA,NAO2)+YLM1*DEXP(-AOEXP(I,IA)*RR)*C(I,J,IA)
         ENDDO
        ENDDO
       ENDDO
      ENDDO
      DO M=1,L
       DO J=1,NBAS(IA)
        NAO2=NAO2+1
        DO JA=1,NATOM
         DO K=1,NGRID(JA)
          CALL RYLM(L,+M,K,RR,YLM1,JA,IA)
          CALL RYLM(L,-M,K,RR,YLM2,JA,IA)
          AOTEMP(K,JA,NAO2)=0.0D0
          DO I=1,RG
           AOTEMP(K,JA,NAO2)=AOTEMP(K,JA,NAO2)+(YLM1+(-1.0D0)**M*YLM2)/DSQRT(2.0D0) &
                            *DEXP(-AOEXP(I,IA)*RR)*C(I,J,IA)
          ENDDO
         ENDDO
        ENDDO
       ENDDO
       DO J=1,NBAS(IA)
        NAO2=NAO2+1
        DO JA=1,NATOM
         DO K=1,NGRID(JA)
          CALL RYLM(L,+M,K,RR,YLM1,JA,IA)
          CALL RYLM(L,-M,K,RR,YLM2,JA,IA)
          AOTEMP(K,JA,NAO2)=0.0D0
          DO I=1,RG
           AOTEMP(K,JA,NAO2)=AOTEMP(K,JA,NAO2)+DIMAG(YLM1-(-1.0D0)**M*YLM2)/DSQRT(2.0D0) &
                            *DEXP(-AOEXP(I,IA)*RR)*C(I,J,IA)
          ENDDO
         ENDDO
        ENDDO
       ENDDO
      ENDDO
     ENDDO
    ENDIF
   
   ENDDO
   CALL PCPU_TIME(ICPUE)
write(*,*) 'ao cpu = ',icpue-icpus
   CALL PCPU_TIME(ICPUS)

   ! REMOVE LINEAR DEPENDENCIES

   ALLOCATE(A(NAO2,NAO2),ER(NAO2),EI(NAO2),EVR(NAO2,NAO2),EVL(NAO2,NAO2),EWK(4*NAO2))

   ! BUILD OVERLAP MATRIX
   DO I=1,NAO2
    DO J=1,NAO2
     A(J,I)=0.0D0
     DO IA=1,NATOM
      DO K=1,NGRID(IA)
       A(J,I)=A(J,I)+AOTEMP(K,IA,J)*AOTEMP(K,IA,I)*GRIDW(K,IA)
      ENDDO
     ENDDO
    ENDDO
   ENDDO
!  call dump10(a,nao,nao)
   CALL PCPU_TIME(ICPUE)
write(*,*) 'overlap cpu = ',icpue-icpus
   CALL PCPU_TIME(ICPUS)

   ! DIAGONALIZE OVERLAP
   CALL DGEEV('N','V',NAO2,A,NAO2,ER,EI,EVL,NAO2,EVR,NAO2,EWK,4*NAO2,INFO)
   IF (INFO /= 0) CALL PABORT('DGEEV FAILED')
   CALL SORT_EIGENVALUES(NAO2,NAO2,ER,EI,EVL,EVR)
   CALL SCHMIDT_EIGENVECTORS(NAO2,EVR)
   CALL PCPU_TIME(ICPUE)
write(*,*) 'diag cpu = ',icpue-icpus
   CALL PCPU_TIME(ICPUS)

   ! CANONICAL ORTHOGONALIZATION
   N=0
   DO I=1,NAO2
    IF (ER(I) > DOPTN(85)) THEN
     N=N+1
     DO J=1,NAO2
      EVL(J,N)=EVR(J,I)/DSQRT(ER(I))
     ENDDO
    ENDIF
   ENDDO
   WRITE(6,'(A,I0)') 'NUMBER OF LINEAR DEPENDENCIES (LARGE) = ',NAO2-N
   WRITE(6,'(A,I0)') 'NUMBER OF AUXILIARY FUNCTIONS (LARGE) = ',N
write(*,*) 'ao lmax = ',lmax
   CALL PFLUSH(6)

   ALLOCATE(AOBASIS2(MAXNGRID,NATOM,N))
   DO I=1,N
    DO IA=1,NATOM
     DO J=1,NGRID(IA)
      AOBASIS2(J,IA,I)=0.0D0
      DO K=1,NAO2
       AOBASIS2(J,IA,I)=AOBASIS2(J,IA,I)+AOTEMP(J,IA,K)*EVL(K,I)
      ENDDO
     ENDDO
    ENDDO
   ENDDO
   CALL PCPU_TIME(ICPUE)
write(*,*) 'new ao cpu = ',icpue-icpus
   CALL PCPU_TIME(ICPUS)

   ALLOCATE(AORB2(0:LMAX,-LMAX:LMAX,RG,NATOM,N))
   AORB2=DCMPLX(0.0D0,0.0D0)
   DO IA=1,NATOM
    DO K=1,N
     CALL EXPAND2YLM(AOBASIS2(:,IA,K),AORB2(:,:,:,IA,K),IA,IA)
    ENDDO
   ENDDO
   CALL PCPU_TIME(ICPUE)
write(*,*) 'expand ao cpu = ',icpue-icpus
   CALL PCPU_TIME(ICPUS)

   NAO2=N

   DEALLOCATE(A,ER,EI,EVR,EVL,EWK,AOTEMP,AOEXP,NBAS,C)

   RETURN
END SUBROUTINE



!SUBROUTINE CONSTRUCTDAO
!! Make Del auxiliary basis in their radial YLM expansions
!
!   USE CONSTANTS
!   USE CONTROL
!   USE STRUCTURE
!   USE INTEGRAL
!   USE BASISSET
!   USE DFT
!   USE SINANOGLU
!
!   IMPLICIT NONE
!   DOUBLE PRECISION,ALLOCATABLE :: FX(:),FY(:),FZ(:)
!   DOUBLE COMPLEX,ALLOCATABLE   :: R(:)
!   DOUBLE PRECISION :: X,Y,Z,R1,R2
!   DOUBLE COMPLEX :: YLM,YLM1,C
!!   INTEGER :: I,J,K,L,M,N,IA
!
!   ALLOCATE(R(RG))
!   ALLOCATE(AXORB(0:LMAX,-LMAX:LMAX,RG,NATOM,NAO))
!   ALLOCATE(AYORB(0:LMAX,-LMAX:LMAX,RG,NATOM,NAO))
!!   ALLOCATE(AZORB(0:LMAX,-LMAX:LMAX,RG,NATOM,NAO))
!
!   DO IA=1,NATOM
!    ALLOCATE(FX(NGRID(IA)),FY(NGRID(IA)),FZ(NGRID(IA)))
!    DO I=1,NAO
!!     FX=0.0D0
!     FY=0.0D0
!     FZ=0.0D0
!     DO L=0,LMAX
!      DO M=-L,L
!!       C=DSQRT(DFLOAT(L-M)*DFLOAT(L+M+1))
!       DO J=1,RG
!        R(J)=AORB(L,M,J,IA,I)
!       ENDDO
!       CALL FIRST_DERIV(R,IA)
!!       N=0
!       DO J=1,RG
!        DO K=1,AG
!         N=N+1
!         X=GRIDX(N,IA)
!!         Y=GRIDY(N,IA)
!         Z=GRIDZ(N,IA)
!         R2=X**2+Y**2
!         IF (M < L) THEN
!          CALL RYLM(L,M+1,N,R1,YLM1,IA,IA)
!!         ELSE
!          YLM1=DCMPLX(0.0D0,0.0D0)
!         ENDIF
!         CALL RYLM(L,M,N,R1,YLM,IA,IA)
!         FX(N)=FX(N)+X/R1*R(J)*YLM
!!         FY(N)=FY(N)+Y/R1*R(J)*YLM
!         FZ(N)=FZ(N)+Z/R1*R(J)*YLM
!         IF (R2 > 0.0D0) THEN
!          FX(N)=FX(N)+AORB(L,M,J,IA,I)/R2*(DFLOAT(M)*X*Z**2/R1**2*YLM &
!               +C*X*Z*DCMPLX(X,-Y)/R1**2*YLM1 &
!!               -DFLOAT(M)*DCMPLX(0.0D0,Y)*YLM)
!          FY(N)=FY(N)+AORB(L,M,J,IA,I)/R2*(DFLOAT(M)*Y*Z**2/R1**2*YLM &
!               +C*Y*Z*DCMPLX(X,-Y)/R1**2*YLM1 &
!               +DFLOAT(M)*DCMPLX(0.0D0,X)*YLM)
!         ELSE
!!          FX(N)=FX(N)+AORB(L,M,J,IA,I)*C*Z/R1**2*YLM1
!          FY(N)=FY(N)+AORB(L,M,J,IA,I)*C*DCMPLX(0.0D0,-Z)/R1**2*YLM1
!         ENDIF
!         FZ(N)=FZ(N)-AORB(L,M,J,IA,I)*DFLOAT(M)*Z/R1**2*YLM &
!                    -AORB(L,M,J,IA,I)*C*DCMPLX(X,-Y)/R1**2*YLM1
!        ENDDO
!       ENDDO
!      ENDDO
!     ENDDO
!     CALL EXPAND2YLM(FX,AXORB(:,:,:,IA,I),IA,IA)
!     CALL EXPAND2YLM(FY,AYORB(:,:,:,IA,I),IA,IA)
!!     CALL EXPAND2YLM(FZ,AZORB(:,:,:,IA,I),IA,IA)
!    ENDDO
!    DEALLOCATE(FX,FY,FZ)
!   ENDDO
!
!   DEALLOCATE(R)
!
!   RETURN
!END SUBROUTINE



SUBROUTINE CONSTRUCTAOLIGHT
! Auxiliary basis set is the input Gaussians

   USE CONSTANTS
   USE CONTROL
   USE STRUCTURE
   USE INTEGRAL
   USE BASISSET
   USE DFT
   USE SINANOGLU

   IMPLICIT NONE
   INTEGER :: I,J,K,N,IA
   INTEGER :: INFO
   DOUBLE PRECISION,ALLOCATABLE :: A(:,:),ER(:),EI(:),EVR(:,:),EVL(:,:),EWK(:)
   DOUBLE PRECISION,ALLOCATABLE :: AOTEMP(:,:,:)
   DOUBLE PRECISION,ALLOCATABLE :: CGS(:,:),C2P(:) ! 'C2P' IS WORKING ARRAY FOR CGS_GRID

   WRITE(6,'(A)') 'AUXILIARY BASIS IS GAUSSIAN BASIS'

   NAO=NCGS
   ALLOCATE(AOTEMP(MAXNGRID,NATOM,NAO))

   ALLOCATE(CGS(NCGS,0:0),C2P(NPGS))
   DO IA=1,NATOM
    DO J=1,NGRID(IA)
     CALL CGS_GRID(CGS,C2P,NCGS,0,0,0,NPGS,J,IA)
     DO I=1,NCGS
      AOTEMP(J,IA,I)=CGS(I,0)
     ENDDO
    ENDDO
   ENDDO
   DEALLOCATE(CGS,C2P)

   ! REMOVE LINEAR DEPENDENCIES

   ALLOCATE(A(NAO,NAO),ER(NAO),EI(NAO),EVR(NAO,NAO),EVL(NAO,NAO),EWK(4*NAO))

   ! BUILD OVERLAP MATRIX
   DO I=1,NAO
    DO J=1,NAO
     A(J,I)=0.0D0
     DO IA=1,NATOM
      DO K=1,NGRID(IA)
       A(J,I)=A(J,I)+AOTEMP(K,IA,J)*AOTEMP(K,IA,I)*GRIDW(K,IA)
      ENDDO
     ENDDO
    ENDDO
   ENDDO

   ! DIAGONALIZE OVERLAP
   CALL DGEEV('N','V',NAO,A,NAO,ER,EI,EVL,NAO,EVR,NAO,EWK,4*NAO,INFO)
   IF (INFO /= 0) CALL PABORT('DGEEV FAILED')
   CALL SORT_EIGENVALUES(NAO,NAO,ER,EI,EVL,EVR)
   CALL SCHMIDT_EIGENVECTORS(NAO,EVR)

   ! CANONICAL ORTHOGONALIZATION
   N=0
   DO I=1,NAO
    IF (ER(I) > DOPTN(85)) THEN
     N=N+1
     DO J=1,NAO
      EVL(J,N)=EVR(J,I)/DSQRT(ER(I))
     ENDDO
    ENDIF
   ENDDO
   WRITE(6,'(A,I0)') 'NUMBER OF LINEAR DEPENDENCIES  = ',NAO-N
   WRITE(6,'(A,I0)') 'NUMBER OF AUXILIARY FUNCTIONS  = ',N
   CALL PFLUSH(6)

   ALLOCATE(AOBASIS(MAXNGRID,NATOM,N))
   DO I=1,N
    DO IA=1,NATOM
     DO J=1,NGRID(IA)
      AOBASIS(J,IA,I)=0.0D0
      DO K=1,NAO
       AOBASIS(J,IA,I)=AOBASIS(J,IA,I)+AOTEMP(J,IA,K)*EVL(K,I)
      ENDDO
     ENDDO
    ENDDO
   ENDDO

   ALLOCATE(AORB(0:LMAX,-LMAX:LMAX,RG,NATOM,N))
   AORB=DCMPLX(0.0D0,0.0D0)
   DO IA=1,NATOM
    DO K=1,N
     CALL EXPAND2YLM(AOBASIS(:,IA,K),AORB(:,:,:,IA,K),IA,IA)
    ENDDO
   ENDDO

   NAO=N

   DEALLOCATE(A,ER,EI,EVR,EVL,EWK,AOTEMP)

   RETURN
END SUBROUTINE



SUBROUTINE GUESSORB
! Make orbitals on a 3D grid

   USE CONSTANTS
   USE CONTROL
   USE STRUCTURE
   USE INTEGRAL
   USE BASISSET
   USE DFT
   USE SINANOGLU

   IMPLICIT NONE
   DOUBLE PRECISION,ALLOCATABLE :: CGS(:,:,:,:),C2P(:) ! 'C2P' IS WORKING ARRAY FOR CGS_GRID
   DOUBLE PRECISION,ALLOCATABLE :: F(:)            ! A FUNCTION OF RADIAL, ANGULAR GRIDS
   DOUBLE COMPLEX,ALLOCATABLE   :: R(:,:,:)        ! A FUNCTION OF RADIAL GRIDS
   INTEGER :: I,J,K,L,M,IA

   ALLOCATE(CGS(NCGS,0:0,0:0,0:0),C2P(NPGS))
   DO IA=1,NATOM
    DO J=1,NGRID(IA)
     CALL CGS_GRID(CGS,C2P,NCGS,0,0,0,NPGS,J,IA)
     DO I=1,MIN(IALL(0,0,0)-IVIRTCORE,NAO)
      ORBITALS(J,IA,I)=0.0D0
      DO K=1,NCGS
       ORBITALS(J,IA,I)=ORBITALS(J,IA,I)+DREAL(CO(K,I,0,0,0))*CGS(K,0,0,0)
      ENDDO
     ENDDO
    ENDDO
   ENDDO
! --- debug exact hydrogen 1s
!write(*,*) '########### guess is changed'
!  ORBITALS=0.0D0
!  DO IA=1,NATOM
!   DO J=1,NGRID(IA)
!   ORBITALS(J,IA,1)=1.0D0/DSQRT(PI)*DEXP(-DSQRT((ATOMX(IA)+GRIDX(J,IA)-ATOMX(1))**2 &
!   +(ATOMY(IA)+GRIDY(J,IA)-ATOMY(1))**2+(ATOMZ(IA)+GRIDZ(J,IA))**2-ATOMZ(1)))
!   ENDDO
!  ENDDO
!  DO IA=1,NATOM
!   DO J=1,NGRID(IA)
!   ORBITALS(J,IA,2)=1.0D0/DSQRT(PI)*DEXP(-DSQRT((ATOMX(IA)+GRIDX(J,IA)-ATOMX(2))**2 &
!   +(ATOMY(IA)+GRIDY(J,IA)-ATOMY(2))**2+(ATOMZ(IA)+GRIDZ(J,IA))**2-ATOMZ(2)))
!   ENDDO
!  ENDDO
! --- debug end
   IF (IOPTN(9) >= 2) THEN
    WRITE(6,'(A)') 'OCCUPIED ORBITALS'
    WRITE(6,'(10I8:)') (I,I=1,NCGS)
    DO IA=1,NATOM
     DO J=1,NGRID(IA)
      WRITE(6,'(10F8.4:)') (ORBITALS(J,IA,I),I=1,NCGS)
     ENDDO
    ENDDO
   ENDIF
   DEALLOCATE(CGS,C2P)

   RETURN
END SUBROUTINE



SUBROUTINE EXPANDORB
! Expand orbitals into their radial YLM expansion coeffs.

   USE CONSTANTS
   USE CONTROL
   USE STRUCTURE
   USE INTEGRAL
   USE BASISSET
   USE DFT
   USE SINANOGLU

   IMPLICIT NONE
   INTEGER :: I,IA
! debug from here ---
!   INTEGER :: J,L1,M1,L2,M2,L3,M3
!   DOUBLE PRECISION :: A,B,D,F(MAXNGRID),G(MAXNGRID)
!   DOUBLE COMPLEX :: C,RR(0:LMAX,-LMAX:LMAX,1:RG)
!   DOUBLE PRECISION,EXTERNAL :: WIGNER3J         ! WIGNER 3J SYMBOLS
! -- to here

   DO I=1,NAO
! debug from here ---
!do ia=1,natom
!do j=1,ngrid(ia)
! f(j)=orbitals(j,ia,i)*fuzzy(j,ia)
!enddo
!call expand2ylm(f,rr,ia,ia)
!call packylm(g,rr,ia,ia)
!a=0.0d0
!b=0.0d0
!do j=1,ngrid(ia)
! a=a+f(j)**2*gridw(j,ia)
! b=b+g(j)**2*gridw(j,ia)
! write(100+i,'(3F10.5,3F10.5,I2)') atomx(ia)+gridx(j,ia),atomy(ia)+gridy(j,ia),atomz(ia)+gridz(j,ia),f(j),g(j),&
! fuzzy(j,ia),ia
!enddo
!write(*,*) i,ia,a,b
!enddo
! --- to here
    DO IA=1,NATOM
     CALL EXPAND2YLM(ORBITALS(:,IA,I),RORB(:,:,:,IA,I),IA,IA)
    ENDDO
! debug from here ---
!   A=0.0D0
!   B=0.0D0
!   D=0.0D0
!   DO IA=1,NATOM
!    DO J=1,NGRID(IA)
!     A=A+ORBITALS(J,IA,I)**2*GRIDW(J,IA)
!    ENDDO
!    CALL PACKYLM(F,RORB(:,:,:,IA,I),IA,IA)
!    DO J=1,NGRID(IA)
!     B=B+F(J)**2*GRIDW(J,IA)
!    ENDDO
!    DO L1=0,LMAX
!     DO M1=-L1,L1
!      DO J=1,RG
!       RR(L1,M1,J)=(-1.0D0)**M1*RORB(L1,-M1,J,IA,I)
!      ENDDO
!     ENDDO
!    ENDDO
!    CALL PACKYLM(G,RR,IA,IA)
!    DO J=1,NGRID(IA)
!     D=D+F(J)*G(J)*GRIDW(J,IA)
!    ENDDO
!   ENDDO
!   WRITE(*,*) I,A,B,D
! --- to here
   ENDDO

   RETURN
END SUBROUTINE



SUBROUTINE CONSTRUCTDORB
! Make Del orbitals in their radial YLM expansions

   USE CONSTANTS
   USE CONTROL
   USE STRUCTURE
   USE INTEGRAL
   USE BASISSET
   USE DFT
   USE SINANOGLU

   IMPLICIT NONE
   DOUBLE PRECISION,ALLOCATABLE :: FX(:),FY(:),FZ(:)
   DOUBLE COMPLEX,ALLOCATABLE   :: R(:)
   DOUBLE PRECISION :: X,Y,Z,R1,R2
   DOUBLE COMPLEX :: YLM,YLM1,C
   INTEGER :: I,J,K,L,M,N,IA

   ALLOCATE(R(RG))

   DO IA=1,NATOM
    ALLOCATE(FX(NGRID(IA)),FY(NGRID(IA)),FZ(NGRID(IA)))
!   DO I=1,NAO
    DO I=1,IOCC
     FX=0.0D0
     FY=0.0D0
     FZ=0.0D0
     DO L=0,LMAX
      DO M=-L,L
       C=DSQRT(DFLOAT(L-M)*DFLOAT(L+M+1))
       DO J=1,RG
        R(J)=RORB(L,M,J,IA,I)
       ENDDO
       CALL FIRST_DERIV(R,IA)
       N=0
       DO J=1,RG
        DO K=1,AG
         N=N+1
         X=GRIDX(N,IA)
         Y=GRIDY(N,IA)
         Z=GRIDZ(N,IA)
         R2=X**2+Y**2
         IF (M < L) THEN
          CALL RYLM(L,M+1,N,R1,YLM1,IA,IA)
         ELSE
          YLM1=DCMPLX(0.0D0,0.0D0)
         ENDIF
         CALL RYLM(L,M,N,R1,YLM,IA,IA) 
         FX(N)=FX(N)+X/R1*R(J)*YLM
         FY(N)=FY(N)+Y/R1*R(J)*YLM
         FZ(N)=FZ(N)+Z/R1*R(J)*YLM
         IF (R2 > 0.0D0) THEN
          FX(N)=FX(N)+RORB(L,M,J,IA,I)/R2*(DFLOAT(M)*X*Z**2/R1**2*YLM &
               +C*X*Z*DCMPLX(X,-Y)/R1**2*YLM1 &
               -DFLOAT(M)*DCMPLX(0.0D0,Y)*YLM)
          FY(N)=FY(N)+RORB(L,M,J,IA,I)/R2*(DFLOAT(M)*Y*Z**2/R1**2*YLM &
               +C*Y*Z*DCMPLX(X,-Y)/R1**2*YLM1 &
               +DFLOAT(M)*DCMPLX(0.0D0,X)*YLM)
         ELSE
          FX(N)=FX(N)+RORB(L,M,J,IA,I)*C*Z/R1**2*YLM1
          FY(N)=FY(N)+RORB(L,M,J,IA,I)*C*DCMPLX(0.0D0,-Z)/R1**2*YLM1
         ENDIF
         FZ(N)=FZ(N)-RORB(L,M,J,IA,I)*DFLOAT(M)*Z/R1**2*YLM &
                    -RORB(L,M,J,IA,I)*C*DCMPLX(X,-Y)/R1**2*YLM1
        ENDDO
       ENDDO
      ENDDO
     ENDDO
     DXORBITALS(:,IA,I)=FX
     DYORBITALS(:,IA,I)=FY
     DZORBITALS(:,IA,I)=FZ
     CALL EXPAND2YLM(FX,RXORB(:,:,:,IA,I),IA,IA)
     CALL EXPAND2YLM(FY,RYORB(:,:,:,IA,I),IA,IA)
     CALL EXPAND2YLM(FZ,RZORB(:,:,:,IA,I),IA,IA)
    ENDDO
    DEALLOCATE(FX,FY,FZ)
   ENDDO

   DEALLOCATE(R)

   RETURN
END SUBROUTINE



SUBROUTINE CONSTRUCTRHO
! Make electron density on a 3D grid and their radial YLM expansion coeffs.

   USE CONSTANTS
   USE CONTROL
   USE STRUCTURE
   USE INTEGRAL
   USE BASISSET
   USE DFT
   USE SINANOGLU

   IMPLICIT NONE
   INTEGER :: I,J,IA

   RHO=0.0D0
   DO IA=1,NATOM
    DO I=1,IOCC
     DO J=1,NGRID(IA)
      RHO(J,IA)=RHO(J,IA)+2.0D0*ORBITALS(J,IA,I)**2
     ENDDO
    ENDDO
    CALL EXPAND2YLM(RHO(:,IA),RRHO(:,:,:,IA),IA,IA)
   ENDDO
   RETURN
END SUBROUTINE



SUBROUTINE CONSTRUCTN
! Construct a Coulomb potential by direct calculation followed by a spherical harmonics expansion

   USE CONSTANTS
   USE CONTROL
   USE STRUCTURE
   USE INTEGRAL
   USE BASISSET
   USE DFT
   USE SINANOGLU

   IMPLICIT NONE
   INTEGER :: I,JA,IA
   DOUBLE PRECISION :: R

   POTENTIALN=0.0D0
   DO IA=1,NATOM
    DO I=1,NGRID(IA)
     DO JA=1,NATOM
      R=(ATOMX(IA)+GRIDX(I,IA)-ATOMX(JA))**2 &
       +(ATOMY(IA)+GRIDY(I,IA)-ATOMY(JA))**2 &
       +(ATOMZ(IA)+GRIDZ(I,IA)-ATOMZ(JA))**2
      IF (R==0.0D0) CALL PABORT('DIVERGENCE')
      POTENTIALN(I,IA)=POTENTIALN(I,IA)-DFLOAT(IATOM(JA))/DSQRT(R)
     ENDDO
    ENDDO
    CALL EXPAND2YLM(POTENTIALN(:,IA),RN(:,:,:,IA),IA,IA)
   ENDDO
   RETURN
END SUBROUTINE



SUBROUTINE CONSTRUCTJ_PARTIALWAVE(R,RR)
! Construct a Coulomb potential by a partial wave expansion

   USE CONSTANTS
   USE CONTROL
   USE STRUCTURE
   USE INTEGRAL
   USE BASISSET
   USE DFT
   USE SINANOGLU

   IMPLICIT NONE
   DOUBLE COMPLEX :: R(0:LMAX,-LMAX:LMAX,RG,NATOM)
   DOUBLE COMPLEX :: RR(0:LMAX,-LMAX:LMAX,RG,NATOM)
   INTEGER :: I,J,K,L,M,IA
   DOUBLE PRECISION :: RLARGE,RSMALL

   DO IA=1,NATOM
    DO L=0,LMAX
     DO M=-L,L
      DO I=1,RG
       RR(L,M,I,IA)=DCMPLX(0.0D0,0.0D0)
       DO J=1,RG
        IF (I <= J) THEN
         RLARGE=SG_GAUSS_CHEV(I,IA)
         RSMALL=SG_GAUSS_CHEV(J,IA)
        ELSE
         RLARGE=SG_GAUSS_CHEV(J,IA)
         RSMALL=SG_GAUSS_CHEV(I,IA)
        ENDIF
        RR(L,M,I,IA)=RR(L,M,I,IA) &
        +4.0D0*PI/DFLOAT(2*L+1)*R(L,M,J,IA)/RLARGE*(RSMALL/RLARGE)**L*SG_GAUSS_CHEV_W(J,IA)
       ENDDO
      ENDDO
     ENDDO
    ENDDO
   ENDDO
!  IF (IOPTN(9) >= 2) CALL DUMP12(LMAX,DREAL(RR),NR,'COULOMB POTENTIAL')
   RETURN
END SUBROUTINE



SUBROUTINE CONSTRUCTJ(R,RR)
! Construct a Coulomb potential by solving Poisson's equation

   USE CONSTANTS
   USE CONTROL
   USE STRUCTURE
   USE INTEGRAL
   USE BASISSET
   USE DFT
   USE SINANOGLU

   IMPLICIT NONE
   DOUBLE COMPLEX :: R(0:LMAX,-LMAX:LMAX,RG,NATOM)
   DOUBLE COMPLEX :: RR(0:LMAX,-LMAX:LMAX,RG,NATOM)
   DOUBLE COMPLEX,ALLOCATABLE   :: W1(:)
   DOUBLE PRECISION,ALLOCATABLE :: W2(:,:),W3(:,:)
   INTEGER :: I,J,L,M,INFO,IA
   DOUBLE PRECISION :: R1
   INTEGER,ALLOCATABLE :: INDX(:)

   DO IA=1,NATOM
    ALLOCATE(W1(RG),W2(RG,RG),W3(RG,2),INDX(RG))
    DO L=0,LMAX
     DO M=-L,L
      DO I=1,RG
       W1=DCMPLX(0.0D0,0.0D0)
       W1(I)=DCMPLX(1.0D0,0.0D0)
       CALL SECOND_DERIV2(W1,IA)
       DO J=1,RG
        W2(J,I)=DREAL(W1(J))
       ENDDO
       W2(I,I)=W2(I,I)-DFLOAT(L*(L+1))/SG_GAUSS_CHEV(I,IA)**2
      ENDDO
      DO I=1,RG
       W3(I,1)=-4.0D0*PI*SG_GAUSS_CHEV(I,IA)*DREAL(R(L,M,I,IA))
       W3(I,2)=-4.0D0*PI*SG_GAUSS_CHEV(I,IA)*DIMAG(R(L,M,I,IA))
      ENDDO
      CALL DGESV(RG,2,W2,RG,INDX,W3,RG,INFO)
      IF (INFO /= 0) CALL PABORT('DGESV FAILED')
      DO I=1,RG
       RR(L,M,I,IA)=DCMPLX(W3(I,1),W3(I,2))/SG_GAUSS_CHEV(I,IA)
      ENDDO
     ENDDO
    ENDDO
    DEALLOCATE(W1,W2,W3,INDX)
   ENDDO
   RETURN

END SUBROUTINE



SUBROUTINE CONSTRUCTJ_NEW(ORB1,ORB2)
! Construct a Coulomb potential by solving Poisson's equation

   USE CONSTANTS
   USE CONTROL
   USE STRUCTURE
   USE INTEGRAL
   USE BASISSET
   USE DFT
   USE SINANOGLU

   IMPLICIT NONE
   DOUBLE PRECISION :: ORB1(MAXNGRID,NATOM)
   DOUBLE PRECISION :: ORB2(MAXNGRID,NATOM)
   DOUBLE PRECISION :: ORB3(MAXNGRID)
   DOUBLE COMPLEX   :: RTEMP(0:LMAX,-LMAX:LMAX,RG)
   DOUBLE COMPLEX   :: W1(RG)
   DOUBLE PRECISION :: W2(RG,RG),W3(RG,2)
   DOUBLE PRECISION :: R1
   INTEGER :: I,J,L,M,INFO,IA,IB
   INTEGER :: INDX(RG)

   ORB2=0.0D0
   DO IA=1,NATOM
    R1=0.0D0
    DO I=1,NGRID(IA)
     ORB3(I)=ORB1(I,IA)*FUZZY(I,IA)
     R1=R1+ORB3(I)*ATOMW(I,IA)
    ENDDO
!write(*,*) 'charge for center',ia,'is',r1
    CALL EXPAND2YLM(ORB3,RTEMP,IA,IA)
    DO L=0,LMAX
     DO M=-L,L
      DO I=1,RG
       W1=DCMPLX(0.0D0,0.0D0)
       W1(I)=DCMPLX(1.0D0,0.0D0)
       CALL SECOND_DERIV2(W1,IA)
       DO J=1,RG
        W2(J,I)=DREAL(W1(J))
       ENDDO
       W2(I,I)=W2(I,I)-DFLOAT(L*(L+1))/SG_GAUSS_CHEV(I,IA)**2
      ENDDO
      DO I=1,RG
       W3(I,1)=-4.0D0*PI*SG_GAUSS_CHEV(I,IA)*DREAL(RTEMP(L,M,I))
       W3(I,2)=-4.0D0*PI*SG_GAUSS_CHEV(I,IA)*DIMAG(RTEMP(L,M,I))
      ENDDO
      CALL DGESV(RG,2,W2,RG,INDX,W3,RG,INFO)
      IF (INFO /= 0) CALL PABORT('DGESV FAILED')
      DO I=1,RG
       RTEMP(L,M,I)=DCMPLX(W3(I,1),W3(I,2))/SG_GAUSS_CHEV(I,IA)
      ENDDO
     ENDDO
    ENDDO
!write(*,*) 'U(0,0,~inf)=',rtemp(0,0,1)*sg_gauss_chev(1,ia)
!write(*,*) 'U(0,0, inf)=',dsqrt(4.0d0*pi)*r1
    DO IB=1,NATOM
     CALL PACKYLM(ORB3,RTEMP,IB,IA)
     DO I=1,NGRID(IB)
      ORB2(I,IB)=ORB2(I,IB)+ORB3(I)
     ENDDO
    ENDDO

   ENDDO
   RETURN

END SUBROUTINE



SUBROUTINE POISSON_DIRECT(ORB1,ORB2)
! Construct a Coulomb potential by solving Poisson's equation

   USE CONSTANTS
   USE CONTROL
   USE STRUCTURE
   USE INTEGRAL
   USE BASISSET
   USE DFT
   USE SINANOGLU

   IMPLICIT NONE
   DOUBLE PRECISION :: ORB1(MAXNGRID,NATOM)
   DOUBLE PRECISION :: ORB2(MAXNGRID,NATOM)
   DOUBLE COMPLEX :: R(0:LMAX,-LMAX:LMAX,RG,NATOM)
   DOUBLE COMPLEX :: RR(0:LMAX,-LMAX:LMAX,RG,NATOM)
   INTEGER :: IA,I

!  DO IA=1,NATOM
!   CALL EXPAND2YLM(ORB1(:,IA),R(:,:,:,IA),IA,IA)
!  ENDDO
!  CALL CONSTRUCTJ(R,RR)
!  DO IA=1,NATOM
!   CALL PACKYLM(ORB2(:,IA),RR(:,:,:,IA),IA,IA)
!  ENDDO
   CALL CONSTRUCTJ_NEW(ORB1,ORB2)
   RETURN

END SUBROUTINE



DOUBLE PRECISION FUNCTION HFENERGY()
! Apply Fock operator to a one-electron function expanded by YLM's.

   USE CONSTANTS
   USE GRADIENT
   USE STRUCTURE
   USE SINANOGLU

   IMPLICIT NONE
   DOUBLE COMPLEX,ALLOCATABLE :: RTEMP1(:,:,:,:)
   DOUBLE COMPLEX,ALLOCATABLE :: RTEMP2(:,:,:,:)
   DOUBLE PRECISION,EXTERNAL :: SINGLEENERGY
   INTEGER :: I

   ALLOCATE(RTEMP1(0:LMAX,-LMAX:LMAX,RG,NATOM))
   ALLOCATE(RTEMP2(0:LMAX,-LMAX:LMAX,RG,NATOM))

   HFENERGY=NUCLEAR_REPULSION

   DO I=1,IOCC

    ! KINETIC OPERATOR
    CALL KINETICYLM(RORB(:,:,:,:,I),RTEMP1)
    RTEMP2=RTEMP1
!write(*,*) 'kinetic=',2.0d0*SINGLEENERGY(RTEMP1,RORB(:,:,:,:,I))

    ! NUCLEAR OPERATOR
    CALL EXTERNLYLM(RORB(:,:,:,:,I),RTEMP1)
    RTEMP2=RTEMP2+RTEMP1
!write(*,*) 'externl=',2.0d0*SINGLEENERGY(RTEMP1,RORB(:,:,:,:,I))

    ! COULOMB OPERATOR
    CALL COULOMBYLM(RORB(:,:,:,:,I),RTEMP1)
    RTEMP2=RTEMP2+0.5D0*RTEMP1
!write(*,*) 'coulomb=',SINGLEENERGY(RTEMP1,RORB(:,:,:,:,I))

    ! EXCHANGE OPERATOR
    CALL EXCHANGEYLM(RORB(:,:,:,:,I),RTEMP1)
    RTEMP2=RTEMP2+0.5D0*RTEMP1
!write(*,*) 'exchnge=',SINGLEENERGY(RTEMP1,RORB(:,:,:,:,I))

    HFENERGY=HFENERGY+2.0D0*SINGLEENERGY(RTEMP2,RORB(:,:,:,:,I))

   ENDDO
   
   DEALLOCATE(RTEMP1,RTEMP2)
   
   RETURN
END FUNCTION



DOUBLE PRECISION FUNCTION HFENERGY_DIRECT()
! Apply Fock operator to a one-electron function expanded on a grid.

   USE CONSTANTS
   USE GRADIENT
   USE STRUCTURE
   USE DFT
   USE SINANOGLU

   IMPLICIT NONE
   DOUBLE PRECISION :: ORB1(MAXNGRID,NATOM)
   DOUBLE PRECISION :: ORB2(MAXNGRID,NATOM)
   DOUBLE PRECISION,EXTERNAL :: OVERLAP
   INTEGER :: I
   DOUBLE PRECISION :: T,N,J,K

   HFENERGY_DIRECT=NUCLEAR_REPULSION

   T=0.0D0
   N=0.0D0
   J=0.0D0
   K=0.0D0
   DO I=1,IOCC

    ! KINETIC OPERATOR
    CALL KINETIC_DIRECT(ORBITALS(:,:,I),ORB2)
    T=T+2.0D0*OVERLAP(ORB2,ORBITALS(:,:,I))

    ! NUCLEAR OPERATOR
    CALL EXTERNL_DIRECT(ORBITALS(:,:,I),ORB1)
    ORB2=ORB2+ORB1
    N=N+2.0D0*OVERLAP(ORB1,ORBITALS(:,:,I))

    ! COULOMB OPERATOR
    CALL COULOMB_DIRECT(ORBITALS(:,:,I),ORB1)
    ORB2=ORB2+0.5D0*ORB1
    J=J+1.0D0*OVERLAP(ORB1,ORBITALS(:,:,I))

    ! EXCHANGE OPERATOR
    CALL EXCHANGE_DIRECT(ORBITALS(:,:,I),ORB1)
    ORB2=ORB2+0.5D0*ORB1
    K=K+1.0D0*OVERLAP(ORB1,ORBITALS(:,:,I))

    HFENERGY_DIRECT=HFENERGY_DIRECT+2.0D0*OVERLAP(ORB2,ORBITALS(:,:,I))

   ENDDO
!  WRITE(6,'(A17,F19.12)') 'KINETIC ',T
!  WRITE(6,'(A17,F19.12)') 'EXTERNAL',N
!  WRITE(6,'(A17,F19.12)') 'COULOMB ',J
!  WRITE(6,'(A17,F19.12)') 'EXCHANGE',K
!  WRITE(6,'(A17,F19.12)') 'TOTAL   ',HFENERGY_DIRECT

   RETURN
END FUNCTION



SUBROUTINE FOCKYLM(R,RR)
! Apply Fock operator to a one-electron function expanded by YLM's.

   USE CONSTANTS
   USE GRADIENT
   USE STRUCTURE
   USE SINANOGLU

   IMPLICIT NONE
   DOUBLE COMPLEX :: R(0:LMAX,-LMAX:LMAX,RG,NATOM)
   DOUBLE COMPLEX :: RR(0:LMAX,-LMAX:LMAX,RG,NATOM)
   DOUBLE COMPLEX,ALLOCATABLE :: RTEMP(:,:,:,:)

   ALLOCATE(RTEMP(0:LMAX,-LMAX:LMAX,RG,NATOM))

   ! KINETIC OPERATOR
   CALL KINETICYLM(R,RTEMP)
   RR=RTEMP

   ! NUCLEAR OPERATOR
   CALL EXTERNLYLM(R,RTEMP)
   RR=RR+RTEMP

   ! COULOMB OPERATOR
   CALL COULOMBYLM(R,RTEMP)
   RR=RR+RTEMP

   ! EXCHANGE OPERATOR
   CALL EXCHANGEYLM(R,RTEMP)
   RR=RR+RTEMP

   DEALLOCATE(RTEMP)

   RETURN
END SUBROUTINE



SUBROUTINE FOCK_DIRECT(ORB1,ORB2)
! Apply Fock operator to a one-electron function expanded on a grid.

   USE CONSTANTS
   USE GRADIENT
   USE STRUCTURE
   USE DFT
   USE SINANOGLU

   IMPLICIT NONE
   DOUBLE PRECISION :: ORB1(MAXNGRID,NATOM)
   DOUBLE PRECISION :: ORB2(MAXNGRID,NATOM)
   DOUBLE PRECISION :: ORB3(MAXNGRID,NATOM)

   ! KINETIC OPERATOR
   CALL KINETIC_DIRECT(ORB1,ORB2)

   ! NUCLEAR OPERATOR
   CALL EXTERNL_DIRECT(ORB1,ORB3)
   ORB2=ORB2+ORB3

   ! COULOMB OPERATOR
   CALL COULOMB_DIRECT(ORB1,ORB3)
   ORB2=ORB2+ORB3

   ! EXCHANGE OPERATOR
   CALL EXCHANGE_DIRECT(ORB1,ORB3)
   ORB2=ORB2+ORB3

   RETURN
END SUBROUTINE



SUBROUTINE KINETICYLM(R,RR)
! Apply kinetic operator to a one-electron function expanded by YLM's.

   USE CONSTANTS
   USE STRUCTURE
   USE SINANOGLU

   IMPLICIT NONE
   DOUBLE COMPLEX :: R(0:LMAX,-LMAX:LMAX,RG,NATOM)
   DOUBLE COMPLEX :: RR(0:LMAX,-LMAX:LMAX,RG,NATOM)
   INTEGER :: I,L,M,IA
   DOUBLE COMPLEX,ALLOCATABLE :: RLM1(:)
   DOUBLE PRECISION :: R1

   ALLOCATE(RLM1(RG))

   DO IA=1,NATOM
    DO L=0,LMAX
     DO M=-L,L
      DO I=1,RG
       RLM1(I)=R(L,M,I,IA)
      ENDDO
      CALL SECOND_DERIV(RLM1,IA)
      DO I=1,RG
       R1=SG_GAUSS_CHEV(I,IA)
       RR(L,M,I,IA)=-0.5D0*(RLM1(I)-DFLOAT(L*(L+1))*R(L,M,I,IA)/(R1**2))
      ENDDO
     ENDDO
    ENDDO
   ENDDO
 
   DEALLOCATE(RLM1)
   RETURN
END SUBROUTINE



SUBROUTINE KINETIC_DIRECT(ORB1,ORB2)
! Apply kinetic operator to a one-electron function expanded on a grid.

   USE CONSTANTS
   USE GRADIENT
   USE STRUCTURE
   USE DFT
   USE SINANOGLU

   IMPLICIT NONE
   DOUBLE PRECISION :: ORB1(MAXNGRID,NATOM)
   DOUBLE PRECISION :: ORB2(MAXNGRID,NATOM)
   DOUBLE COMPLEX :: R(0:LMAX,-LMAX:LMAX,RG,NATOM)
   DOUBLE COMPLEX :: RR(0:LMAX,-LMAX:LMAX,RG,NATOM)
   INTEGER :: IA,I

   DO IA=1,NATOM
    CALL EXPAND2YLM(ORB1(:,IA),R(:,:,:,IA),IA,IA)
   ENDDO
   CALL KINETICYLM(R,RR)
   DO IA=1,NATOM
    CALL PACKYLM(ORB2(:,IA),RR(:,:,:,IA),IA,IA)
   ENDDO

   RETURN
END SUBROUTINE



SUBROUTINE EXTERNLYLM(R,RR)
! Apply nuclear attraction operator to a one-electron function expanded by YLM's.

   USE CONSTANTS
   USE GRADIENT
   USE STRUCTURE
   USE SINANOGLU

   IMPLICIT NONE
   DOUBLE COMPLEX :: R(0:LMAX,-LMAX:LMAX,RG,NATOM)
   DOUBLE COMPLEX :: RR(0:LMAX,-LMAX:LMAX,RG,NATOM)
   INTEGER :: I,L1,M1,L2,M2,L3,M3,IA
   DOUBLE COMPLEX :: C
   DOUBLE PRECISION,EXTERNAL :: WIGNER3J         ! WIGNER 3J SYMBOLS

   RR=DCMPLX(0.0D0,0.0D0)
   DO IA=1,NATOM
    DO L1=0,LMAX
     DO M1=-L1,L1
      DO L2=0,LMAX
       DO M2=-L2,L2
        M3=-M1-M2
        DO L3=MAX(IABS(M3),IABS(L1-L2)),MIN(LMAX,L1+L2)
         C=SGN(M3)*WIGNER3J(L1,L2,L3,M1,M2,M3)*WIGNER3J(L1,L2,L3,0,0,0) &
                  *DSQRT(DFLOAT((2*L1+1)*(2*L2+1)*(2*L3+1))/4.0D0/PI)
         DO I=1,RG
          RR(L3,-M3,I,IA)=RR(L3,-M3,I,IA)+C*RN(L1,M1,I,IA)*R(L2,M2,I,IA)
         ENDDO
        ENDDO
       ENDDO
      ENDDO
     ENDDO
    ENDDO
   ENDDO
   RETURN
END SUBROUTINE



SUBROUTINE EXTERNL_DIRECT(ORB1,ORB2)
! Apply nuclear attraction operator to a one-electron function expanded on a grid.

   USE CONSTANTS
   USE GRADIENT
   USE STRUCTURE
   USE DFT
   USE SINANOGLU

   IMPLICIT NONE
   DOUBLE PRECISION :: ORB1(MAXNGRID,NATOM)
   DOUBLE PRECISION :: ORB2(MAXNGRID,NATOM)
   INTEGER :: IA,I

   DO IA=1,NATOM
    DO I=1,NGRID(IA)
     ORB2(I,IA)=ORB1(I,IA)*POTENTIALN(I,IA)
    ENDDO
   ENDDO
   RETURN
END SUBROUTINE



SUBROUTINE COULOMBYLM(R,RR)
! Apply Coulomb operator to a one-electron function expanded by YLM's.

   USE CONSTANTS
   USE GRADIENT
   USE STRUCTURE
   USE SINANOGLU

   IMPLICIT NONE
   DOUBLE COMPLEX :: R(0:LMAX,-LMAX:LMAX,RG,NATOM)
   DOUBLE COMPLEX :: RR(0:LMAX,-LMAX:LMAX,RG,NATOM)
   INTEGER :: I,L1,M1,L2,M2,L3,M3,IA
   DOUBLE COMPLEX :: C
   DOUBLE PRECISION,EXTERNAL :: WIGNER3J         ! WIGNER 3J SYMBOLS

   RR=DCMPLX(0.0D0,0.0D0)
   DO IA=1,NATOM
    DO L1=0,LMAX
     DO M1=-L1,L1
      DO L2=0,LMAX
       DO M2=-L2,L2
        M3=-M1-M2
        DO L3=MAX(IABS(M3),IABS(L1-L2)),MIN(LMAX,L1+L2)
         C=SGN(M3)*WIGNER3J(L1,L2,L3,M1,M2,M3)*WIGNER3J(L1,L2,L3,0,0,0) &
                  *DSQRT(DFLOAT((2*L1+1)*(2*L2+1)*(2*L3+1))/4.0D0/PI)
         DO I=1,RG
          RR(L3,-M3,I,IA)=RR(L3,-M3,I,IA)+C*RJ(L1,M1,I,IA)*R(L2,M2,I,IA)
         ENDDO
        ENDDO
       ENDDO
      ENDDO
     ENDDO
    ENDDO
   ENDDO
   RETURN
END SUBROUTINE



SUBROUTINE COULOMB_DIRECT(ORB1,ORB2)
! Apply Coulomb operator to a one-electron function expanded on a grid.

   USE CONSTANTS
   USE GRADIENT
   USE STRUCTURE
   USE DFT
   USE SINANOGLU

   IMPLICIT NONE
   DOUBLE PRECISION :: ORB1(MAXNGRID,NATOM)
   DOUBLE PRECISION :: ORB2(MAXNGRID,NATOM)
   INTEGER :: IA,I

   DO IA=1,NATOM
    DO I=1,NGRID(IA)
     ORB2(I,IA)=ORB1(I,IA)*POTENTIALJ(I,IA)
    ENDDO
   ENDDO
   RETURN
END SUBROUTINE



SUBROUTINE EXCHANGEYLM(R,RR)
! Apply exchange operator to a one-electron function expanded by YLM's.

   USE CONSTANTS
   USE GRADIENT
   USE STRUCTURE
   USE SINANOGLU
   USE DFT

   IMPLICIT NONE
   DOUBLE PRECISION :: ORB1(MAXNGRID,NATOM)
   DOUBLE PRECISION :: ORB2(MAXNGRID,NATOM)
   DOUBLE COMPLEX :: R(0:LMAX,-LMAX:LMAX,RG,NATOM)
   DOUBLE COMPLEX :: RR(0:LMAX,-LMAX:LMAX,RG,NATOM)
   DOUBLE COMPLEX,ALLOCATABLE :: RTEMP1(:,:,:,:)
   DOUBLE COMPLEX,ALLOCATABLE :: RTEMP2(:,:,:,:)
   INTEGER :: I,J,L1,M1,L2,M2,L3,M3,IA
   DOUBLE COMPLEX :: C
   DOUBLE PRECISION,EXTERNAL :: WIGNER3J         ! WIGNER 3J SYMBOLS

   ALLOCATE(RTEMP1(0:LMAX,-LMAX:LMAX,RG,NATOM),RTEMP2(0:LMAX,-LMAX:LMAX,RG,NATOM))

   RR=DCMPLX(0.0D0,0.0D0)
   DO J=1,IOCC

    ! OCC(J) X (INPUT FUNCTION)
    RTEMP1=DCMPLX(0.0D0,0.0D0)
    DO IA=1,NATOM
     DO L1=0,LMAX
      DO M1=-L1,L1
       DO L2=0,LMAX
        DO M2=-L2,L2
         M3=M1-M2
         DO L3=MAX(IABS(M3),IABS(L1-L2)),MIN(LMAX,L1+L2)
          C=SGN(M1)*SGN(M3)*WIGNER3J(L1,L2,L3,-M1,M2,M3)*WIGNER3J(L1,L2,L3,0,0,0) &
           *DSQRT(DFLOAT((2*L1+1)*(2*L2+1)*(2*L3+1))/4.0D0/PI)
          DO I=1,RG
           RTEMP1(L3,-M3,I,IA)=RTEMP1(L3,-M3,I,IA)+C*DCONJG(RORB(L1,M1,I,IA,J))*R(L2,M2,I,IA)
          ENDDO
         ENDDO
        ENDDO
       ENDDO
      ENDDO
     ENDDO
    ENDDO

    ! POISSON SOLVER
!   CALL CONSTRUCTJ(RTEMP1,RTEMP2)
    DO IA=1,NATOM
     CALL PACKYLM(ORB1(:,IA),RTEMP1(:,:,:,IA),IA,IA)
    ENDDO
    CALL CONSTRUCTJ_NEW(ORB1,ORB2)
    DO IA=1,NATOM
     CALL EXPAND2YLM(ORB2(:,IA),RTEMP2(:,:,:,IA),IA,IA)
    ENDDO

    ! Int OCC(J) X (INPUT FUNCTION) / R12 dT X OCC(J)
    DO IA=1,NATOM
     DO L1=0,LMAX
      DO M1=-L1,L1
       DO L2=0,LMAX
        DO M2=-L2,L2
         M3=-M1-M2
         DO L3=MAX(IABS(M3),IABS(L1-L2)),MIN(LMAX,L1+L2)
          C=SGN(M3)*WIGNER3J(L1,L2,L3,M1,M2,M3)*WIGNER3J(L1,L2,L3,0,0,0) &
           *DSQRT(DFLOAT((2*L1+1)*(2*L2+1)*(2*L3+1))/4.0D0/PI)
          DO I=1,RG
           RR(L3,-M3,I,IA)=RR(L3,-M3,I,IA)-C*RORB(L1,M1,I,IA,J)*RTEMP2(L2,M2,I,IA)
          ENDDO
         ENDDO    
        ENDDO
       ENDDO
      ENDDO
     ENDDO
    ENDDO

   ENDDO

   DEALLOCATE(RTEMP1,RTEMP2)
   RETURN
END SUBROUTINE



SUBROUTINE EXCHANGE_DIRECT(ORB1,ORB2)
! Apply Coulomb operator to a one-electron function expanded on a grid.

   USE CONSTANTS
   USE GRADIENT
   USE STRUCTURE
   USE DFT
   USE SINANOGLU

   IMPLICIT NONE
   DOUBLE PRECISION :: ORB1(MAXNGRID,NATOM)
   DOUBLE PRECISION :: ORB2(MAXNGRID,NATOM)
   DOUBLE PRECISION :: ORB3(MAXNGRID,NATOM)
   DOUBLE PRECISION :: ORB4(MAXNGRID,NATOM)
!  DOUBLE COMPLEX :: RTEMP1(0:LMAX,-LMAX:LMAX,RG,NATOM)
!  DOUBLE COMPLEX :: RTEMP2(0:LMAX,-LMAX:LMAX,RG,NATOM)
   INTEGER :: IA,I,J

   ORB2=0.0D0
   DO J=1,IOCC
    DO IA=1,NATOM
     DO I=1,NGRID(IA)
      ORB3(I,IA)=ORB1(I,IA)*ORBITALS(I,IA,J)
     ENDDO
!    CALL EXPAND2YLM(ORB3(:,IA),RTEMP1(:,:,:,IA),IA,IA)
    ENDDO
!   CALL CONSTRUCTJ(RTEMP1,RTEMP2)
    CALL CONSTRUCTJ_NEW(ORB3,ORB4)
    DO IA=1,NATOM
!    CALL PACKYLM(ORB3(:,IA),RTEMP2(:,:,:,IA),IA,IA)
     DO I=1,NGRID(IA)
      ORB2(I,IA)=ORB2(I,IA)-ORB4(I,IA)*ORBITALS(I,IA,J)
     ENDDO
    ENDDO
   ENDDO
   RETURN
END SUBROUTINE



SUBROUTINE FIRST_DERIV(R,IA)
! 7-point finite-difference first differentiation, (d/dr)f(r) 

   USE CONSTANTS
   USE STRUCTURE
   USE SINANOGLU

   IMPLICIT NONE
   INTEGER :: IA
   DOUBLE COMPLEX   :: R(RG)
   DOUBLE PRECISION :: H
   DOUBLE COMPLEX,ALLOCATABLE :: R1D(:)
   INTEGER :: I
   DOUBLE PRECISION,PARAMETER :: BSRADI(17) = &
     (/0.472D0,0.472D0,1.370D0,0.992D0,0.803D0,0.661D0,0.614D0,0.567D0,0.472D0, &
       0.472D0,1.701D0,1.417D0,1.181D0,1.039D0,0.945D0,0.945D0,0.945D0/) ! Ne DATA WAS MISSING IN THE ORIGINAL
   DOUBLE PRECISION :: R0

   ALLOCATE(R1D(RG))
   IF (IABS(SALG)==1) THEN
    H=10.0D0/DFLOAT(RG)
   ELSE IF (IABS(SALG)==2) THEN
    H=10.0D0/DFLOAT(RG)
   ELSE IF (IABS(SALG)==3) THEN
    H=PI/DFLOAT(RG+1)
   ENDIF

   ! FIRST DERIVATIVES
   IF (SALG > 0) THEN
    R1D(1)=(-1764.0D0*R(1)+4320.0D0*R(2)-5400.0D0*R(3)+4800.0D0*R(4) &
            -2700.0D0*R(5)+864.0D0*R(6)-120.0D0*R(7))/(720.0D0*H)
    R1D(2)=(-120.0D0*R(1)-924.0D0*R(2)+1800.0D0*R(3)-1200.0D0*R(4) &
            +600.0D0*R(5)-180.0D0*R(6)+24.0D0*R(7))/(720.0D0*H)
    R1D(3)=(24.0D0*R(1)-288.0D0*R(2)-420.0D0*R(3)+960.0D0*R(4) &
            -360.0D0*R(5)+96.0D0*R(6)-12.0D0*R(7))/(720.0D0*H)
    R1D(4)=(-12.0D0*R(1)+108.0D0*R(2)-540.0D0*R(3) &
            +540.0D0*R(5)-108.0D0*R(6)+12.0D0*R(7))/(720.0D0*H)
    R1D(RG-3)=(-12.0D0*R(RG-6)+108.0D0*R(RG-5)-540.0D0*R(RG-4) &
              +540.0D0*R(RG-2)-108.0D0*R(RG-1)+12.0D0*R(RG))/(720.0D0*H)
    R1D(RG-2)=(12.0D0*R(RG-6)-96.0D0*R(RG-5)+360.0D0*R(RG-4)-960.0D0*R(RG-3) &
              +420.0D0*R(RG-2)+288.0D0*R(RG-1)-24.0D0*R(RG))/(720.0D0*H)
    R1D(RG-1)=(-24.0D0*R(RG-6)+180.0D0*R(RG-5)-600.0D0*R(RG-4)+1200.0D0*R(RG-3) &
              -1800.0D0*R(RG-2)+924.0D0*R(RG-1)+120.0D0*R(RG))/(720.0D0*H)
    R1D(RG)=(120.0D0*R(RG-6)-864.0D0*R(RG-5)+2700.0D0*R(RG-4)-4800.0D0*R(RG-3) &
             +5400.0D0*R(RG-2)-4320.0D0*R(RG-1)+1764.0D0*R(RG))/(720.0D0*H)
    DO I=5,RG-4
     R1D(I)=(+144.0D0*R(I-4)-1536.0D0*R(I-3)+8064.0D0*R(I-2)-32256.0D0*R(I-1) &
            +32256.0D0*R(I+1)-8064.0D0*R(I+2)+1536.0D0*R(I+3)-144.0D0*R(I+4))/(40320.0D0*H)
    ENDDO
   ELSE
    R1D(1)=(R(2)-R(1))/H
    R1D(RG)=(R(RG)-R(RG-1))/H
    DO I=2,RG-1
     R1D(I)=(R(I+1)-R(I-1))/(2.0D0*H)
    ENDDO
   ENDIF

   R0=BSRADI(IATOM(IA))
   IF (IABS(SALG)==-2) THEN
    DO I=1,RG
     R(I)=-R1D(I)/SG_GAUSS_CHEV(I,IA)
    ENDDO
   ELSE IF (IABS(SALG)==3) THEN
    DO I=1,RG
     R(I)=-DSQRT(R0/SG_GAUSS_CHEV(I,IA))*R1D(I)/(SG_GAUSS_CHEV(I,IA)+R0)
    ENDDO
   ELSE
    CALL PABORT('NOT YET IMPLEMENTED')
   ENDIF

   DEALLOCATE(R1D)
   RETURN
END SUBROUTINE



SUBROUTINE SECOND_DERIV(R,IA)
! 7-point finite-difference second differentiation
! (1/r)(d2/dr2)rf(r) = (2/r)(df/dr)+(d2f/dr2) = (2/r)(dx/dr)(df/dx) + (d2x/dr2)(df/dx) + (dx/dr)^2(d2f/dx2)

   USE CONSTANTS
   USE STRUCTURE
   USE SINANOGLU

   IMPLICIT NONE
   INTEGER :: IA
   DOUBLE COMPLEX   :: R(RG)
   DOUBLE PRECISION :: H
   DOUBLE COMPLEX,ALLOCATABLE :: R1D(:)
   DOUBLE COMPLEX,ALLOCATABLE :: R2D(:)
   INTEGER :: I
   DOUBLE PRECISION,PARAMETER :: BSRADI(17) = &
     (/0.472D0,0.472D0,1.370D0,0.992D0,0.803D0,0.661D0,0.614D0,0.567D0,0.472D0, &
       0.472D0,1.701D0,1.417D0,1.181D0,1.039D0,0.945D0,0.945D0,0.945D0/) ! Ne DATA WAS MISSING IN THE ORIGINAL
   DOUBLE PRECISION :: R0,X,OMEGA

   ALLOCATE(R1D(RG),R2D(RG))
   IF (IABS(SALG)==1) THEN
    H=10.0D0/DFLOAT(RG)
   ELSE IF (IABS(SALG)==2) THEN
    H=10.0D0/DFLOAT(RG)
   ELSE IF (IABS(SALG)==3) THEN
    H=PI/DFLOAT(RG+1)
   ENDIF

   ! FIRST DERIVATIVES
   IF (SALG > 0) THEN
    R1D(1)=(-1764.0D0*R(1)+4320.0D0*R(2)-5400.0D0*R(3)+4800.0D0*R(4) &
            -2700.0D0*R(5)+864.0D0*R(6)-120.0D0*R(7))/(720.0D0*H)
    R1D(2)=(-120.0D0*R(1)-924.0D0*R(2)+1800.0D0*R(3)-1200.0D0*R(4) &
            +600.0D0*R(5)-180.0D0*R(6)+24.0D0*R(7))/(720.0D0*H)
    R1D(3)=(24.0D0*R(1)-288.0D0*R(2)-420.0D0*R(3)+960.0D0*R(4) &
            -360.0D0*R(5)+96.0D0*R(6)-12.0D0*R(7))/(720.0D0*H)
    R1D(4)=(-12.0D0*R(1)+108.0D0*R(2)-540.0D0*R(3) &
            +540.0D0*R(5)-108.0D0*R(6)+12.0D0*R(7))/(720.0D0*H)
    R1D(RG-3)=(-12.0D0*R(RG-6)+108.0D0*R(RG-5)-540.0D0*R(RG-4) &
              +540.0D0*R(RG-2)-108.0D0*R(RG-1)+12.0D0*R(RG))/(720.0D0*H)
    R1D(RG-2)=(12.0D0*R(RG-6)-96.0D0*R(RG-5)+360.0D0*R(RG-4)-960.0D0*R(RG-3) &
              +420.0D0*R(RG-2)+288.0D0*R(RG-1)-24.0D0*R(RG))/(720.0D0*H)
    R1D(RG-1)=(-24.0D0*R(RG-6)+180.0D0*R(RG-5)-600.0D0*R(RG-4)+1200.0D0*R(RG-3) &
              -1800.0D0*R(RG-2)+924.0D0*R(RG-1)+120.0D0*R(RG))/(720.0D0*H)
    R1D(RG)=(120.0D0*R(RG-6)-864.0D0*R(RG-5)+2700.0D0*R(RG-4)-4800.0D0*R(RG-3) &
             +5400.0D0*R(RG-2)-4320.0D0*R(RG-1)+1764.0D0*R(RG))/(720.0D0*H)
    DO I=5,RG-4
     R1D(I)=(+144.0D0*R(I-4)-1536.0D0*R(I-3)+8064.0D0*R(I-2)-32256.0D0*R(I-1) &
            +32256.0D0*R(I+1)-8064.0D0*R(I+2)+1536.0D0*R(I+3)-144.0D0*R(I+4))/(40320.0D0*H)
    ENDDO
   ELSE
    R1D(1)=(R(2)-R(1))/H
    R1D(RG)=(R(RG)-R(RG-1))/H
    DO I=2,RG-1
     R1D(I)=(R(I+1)-R(I-1))/(2.0D0*H)
    ENDDO
   ENDIF

   ! SECOND DERIVATIVES
   IF (SALG > 0) THEN
    R2D(1)=(1624.0D0*R(1)-6264.0D0*R(2)+10530.0D0*R(3)-10160.0D0*R(4) &
            +5940.0D0*R(5)-1944.0D0*R(6)+274.0D0*R(7))/(360.0D0*H**2)
    R2D(2)=(274.0D0*R(1)-294.0D0*R(2)-510.0D0*R(3)+940.0D0*R(4) &
            -570.0D0*R(5)+186.0D0*R(6)-26.0D0*R(7))/(360.0D0*H**2)
    R2D(3)=(-26.0D0*R(1)+456.0D0*R(2)-840.0D0*R(3)+400.0D0*R(4) &
            +30.0D0*R(5)-24.0D0*R(6)+4.0D0*R(7))/(360.0D0*H**2)
    R2D(4)=(4.0D0*R(1)-54.0D0*R(2)+540.0D0*R(3)-980.0D0*R(4) &
            +540.0D0*R(5)-54.0D0*R(6)+4.0D0*R(7))/(360.0D0*H**2)
    R2D(RG-3)=(4.0D0*R(RG-6)-54.0D0*R(RG-5)+540.0D0*R(RG-4)-980.0D0*R(RG-3) &
              +540.0D0*R(RG-2)-54.0D0*R(RG-1)+4.0D0*R(RG))/(360.0D0*H**2)
    R2D(RG-2)=(4.0D0*R(RG-6)-24.0D0*R(RG-5)+30.0D0*R(RG-4)+400.0D0*R(RG-3) &
              -840.0D0*R(RG-2)+456.0D0*R(RG-1)-26.0D0*R(RG))/(360.0D0*H**2)
    R2D(RG-1)=(-26.0D0*R(RG-6)+186.0D0*R(RG-5)-570.0D0*R(RG-4)+940.0D0*R(RG-3) &
              -510.0D0*R(RG-2)-294.0D0*R(RG-1)+274.0D0*R(RG))/(360.0D0*H**2)
    R2D(RG)=(274.0D0*R(RG-6)-1944.0D0*R(RG-5)+5940.0D0*R(RG-4)-10160.0D0*R(RG-3) &
            +10530.0D0*R(RG-2)-6264.0D0*R(RG-1)+1624.0D0*R(RG))/(360.0D0*H**2)
    DO I=5,RG-4
     R2D(I)=(-36.0D0*R(I-4)+512.0D0*R(I-3)-4032.0D0*R(I-2)+32256.0D0*R(I-1)-57400.0D0*R(I) &
          +32256.0D0*R(I+1)-4032.0D0*R(I+2)+512.0D0*R(I+3)-36.0D0*R(I+4))/(20160.0D0*H**2)
    ENDDO
   ELSE
    call pabort('nothing we can do here to maintain symmetric matrix structure')
    R2D(1)=  -2.0D0*R(1)    +1.0D0*R(2)
    R2D(RG)= +1.0D0*R(RG-1) -2.0D0*R(RG)
    DO I=2,RG-1
     R2D(I)= +1.0D0*R(I-1)-2.0D0*R(I)+1.0D0*R(I+1)
    ENDDO
   ENDIF

   R0=BSRADI(IATOM(IA))
   DO I=1,RG
    IF (SALG==1) THEN
     R(I)=-2.0D0*R1D(I)/SG_GAUSS_CHEV(I,IA)/(720.0D0*H)+R2D(I)/(360.0D0*H**2)
!    R(I)=R2D(I)/(360.0D0*H**2)
    ELSE IF (SALG==-1) THEN
     R(I)=-2.0D0*R1D(I)/SG_GAUSS_CHEV(I,IA)/(2.0D0*H)+R2D(I)/(H**2)
!    R(I)=R2D(I)/(H**2)
    ELSE IF (SALG==2) THEN
     R(I)=-R1D(I)/(720.0D0*H)/SG_GAUSS_CHEV(I,IA)**2+R2D(I)/(360.0D0*H**2)/SG_GAUSS_CHEV(I,IA)**2
!    R(I)=R1D(I)/(720.0D0*H)/SG_GAUSS_CHEV(I)**2+R2D(I)/(360.0D0*H**2)/SG_GAUSS_CHEV(I)**2
    ELSE IF (SALG==-2) THEN
     R(I)=-R1D(I)/(2.0D0*H)/SG_GAUSS_CHEV(I,IA)**2+R2D(I)/(H**2)/SG_GAUSS_CHEV(I,IA)**2
!    R(I)=R1D(I)/(2.0D0*H)/SG_GAUSS_CHEV(I)**2+R2D(I)/(H**2)/SG_GAUSS_CHEV(I)**2
    ELSE IF (SALG==3) THEN
     OMEGA=DFLOAT(I)*PI/DFLOAT(RG+1)
     X=DCOS(OMEGA)
     R(I)=-2.0D0*R1D(I)/SG_GAUSS_CHEV(I,IA)*(1.0D0-X)**2/(2.0D0*R0*DSIN(OMEGA)) &
          +R1D(I)*((1.0D0-X)**3/(2.0D0*R0**2*DSIN(OMEGA)) &
                  -(1.0D0-X)**4*DCOS(OMEGA)/(4.0D0*R0**2*DSIN(OMEGA)**3)) &
          +R2D(I)*((1.0D0-X)**2/(2.0D0*R0*DSIN(OMEGA)))**2
    ELSE IF (SALG==-3) THEN
     OMEGA=DFLOAT(I)*PI/DFLOAT(RG+1)
     X=DCOS(OMEGA)
     R(I)=-2.0D0*R1D(I)/SG_GAUSS_CHEV(I,IA)/(2.0D0*H)*(1.0D0-X)**2/(2.0D0*R0*DSIN(OMEGA)) &
          +R1D(I)/(2.0D0*H)*((1.0D0-X)**3/(2.0D0*R0**2*DSIN(OMEGA)) &
                              -(1.0D0-X)**4*DCOS(OMEGA)/(4.0D0*R0**2*DSIN(OMEGA)**3)) &
          +R2D(I)/(1.0D0*H**2)*((1.0D0-X)**2/(2.0D0*R0*DSIN(OMEGA)))**2
    ENDIF
   ENDDO

   DEALLOCATE(R2D,R1D)
   RETURN
END SUBROUTINE



SUBROUTINE SECOND_DERIV2(R,IA)
! 7-point finite-difference second differentiation
! (1/r)(d2/dr2)r r^-1f(r) = (1/r)(d2x/dr2)(df/dx) + (1/r)(dx/dr)^2(d2f/dx2)

   USE CONSTANTS
   USE STRUCTURE
   USE SINANOGLU

   IMPLICIT NONE
   INTEGER :: IA
   DOUBLE COMPLEX   :: R(RG)
   DOUBLE PRECISION :: H
   DOUBLE COMPLEX,ALLOCATABLE :: R1D(:)
   DOUBLE COMPLEX,ALLOCATABLE :: R2D(:)
   INTEGER :: I
   DOUBLE PRECISION,PARAMETER :: BSRADI(17) = &
     (/0.472D0,0.472D0,1.370D0,0.992D0,0.803D0,0.661D0,0.614D0,0.567D0,0.472D0, &
       0.472D0,1.701D0,1.417D0,1.181D0,1.039D0,0.945D0,0.945D0,0.945D0/) ! Ne DATA WAS MISSING IN THE ORIGINAL
   DOUBLE PRECISION :: R0,X,OMEGA

   ALLOCATE(R1D(RG),R2D(RG))
   IF (SALG==1) THEN
    H=PI/DFLOAT(RG+1)
   ELSE IF (IABS(SALG)==2) THEN
    H=10.0D0/DFLOAT(RG)
   ELSE IF (IABS(SALG)==3) THEN
    H=PI/DFLOAT(RG+1)
   ENDIF

   ! FIRST DERIVATIVES
   IF (SALG > 0) THEN
    R1D(1)=(-1764.0D0*R(1)+4320.0D0*R(2)-5400.0D0*R(3)+4800.0D0*R(4) &
            -2700.0D0*R(5)+864.0D0*R(6)-120.0D0*R(7))/(720.0D0*H)
    R1D(2)=(-120.0D0*R(1)-924.0D0*R(2)+1800.0D0*R(3)-1200.0D0*R(4) &
            +600.0D0*R(5)-180.0D0*R(6)+24.0D0*R(7))/(720.0D0*H)
    R1D(3)=(24.0D0*R(1)-288.0D0*R(2)-420.0D0*R(3)+960.0D0*R(4) &
            -360.0D0*R(5)+96.0D0*R(6)-12.0D0*R(7))/(720.0D0*H)
    R1D(4)=(-12.0D0*R(1)+108.0D0*R(2)-540.0D0*R(3) &
           +540.0D0*R(5)-108.0D0*R(6)+12.0D0*R(7))/(720.0D0*H)
    R1D(RG-3)=(-12.0D0*R(RG-6)+108.0D0*R(RG-5)-540.0D0*R(RG-4) &
              +540.0D0*R(RG-2)-108.0D0*R(RG-1)+12.0D0*R(RG))/(720.0D0*H)
    R1D(RG-2)=(-12.0D0*R(RG-5)+108.0D0*R(RG-4)-540.0D0*R(RG-3) &
              +540.0D0*R(RG-1)-108.0D0*R(RG))/(720.0D0*H)
    R1D(RG-1)=(+12.0D0*R(RG-5)-96.0D0*R(RG-4)+360.0D0*R(RG-3)-960.0D0*R(RG-2) &
              +420.0D0*R(RG-1)+288.0D0*R(RG))/(720.0D0*H)
    R1D(RG)=(-24.0D0*R(RG-5)+180.0D0*R(RG-4)-600.0D0*R(RG-3)+1200.0D0*R(RG-2) &
             -1800.0D0*R(RG-1)+924.0D0*R(RG))/(720.0D0*H)
    DO I=5,RG-4
     R1D(I)=(+144.0D0*R(I-4)-1536.0D0*R(I-3)+8064.0D0*R(I-2)-32256.0D0*R(I-1) &
            +32256.0D0*R(I+1)-8064.0D0*R(I+2)+1536.0D0*R(I+3)-144.0D0*R(I+4))/(40320.0D0*H)
    ENDDO
   ELSE
    R1D(1)=1.0D0*R(2)
    R1D(RG)=-1.0D0*R(RG-1)
    DO I=2,RG-1
     R1D(I)=-1.0D0*R(I-1)+1.0D0*R(I+1)
    ENDDO
   ENDIF

   ! SECOND DERIVATIVES
   IF (SALG > 0) THEN
    R2D(1)=(1624.0D0*R(1)-6264.0D0*R(2)+10530.0D0*R(3)-10160.0D0*R(4) &
            +5940.0D0*R(5)-1944.0D0*R(6)+274.0D0*R(7))/(360.0D0*H**2)
    R2D(2)=(274.0D0*R(1)-294.0D0*R(2)-510.0D0*R(3)+940.0D0*R(4) &
            -570.0D0*R(5)+186.0D0*R(6)-26.0D0*R(7))/(360.0D0*H**2)
    R2D(3)=(-26.0D0*R(1)+456.0D0*R(2)-840.0D0*R(3)+400.0D0*R(4) &
            +30.0D0*R(5)-24.0D0*R(6)+4.0D0*R(7))/(360.0D0*H**2)
    R2D(4)=(4.0D0*R(1)-54.0D0*R(2)+540.0D0*R(3)-980.0D0*R(4) &
            +540.0D0*R(5)-54.0D0*R(6)+4.0D0*R(7))/(360.0D0*H**2)
    R2D(RG-3)=(4.0D0*R(RG-6)-54.0D0*R(RG-5)+540.0D0*R(RG-4)-980.0D0*R(RG-3) &
              +540.0D0*R(RG-2)-54.0D0*R(RG-1)+4.0D0*R(RG))/(360.0D0*H**2)
    R2D(RG-2)=(+4.0D0*R(RG-5)-54.0D0*R(RG-4)  +540.0D0*R(RG-3)-980.0D0*R(RG-2) &
              +540.0D0*R(RG-1)-54.0D0*R(RG))/(360.0D0*H**2)
    R2D(RG-1)=(+4.0D0*R(RG-5)-24.0D0*R(RG-4)   +30.0D0*R(RG-3)+400.0D0*R(RG-2) &
              -840.0D0*R(RG-1)+456.0D0*R(RG))/(360.0D0*H**2)
    R2D(RG)=(-26.0D0*R(RG-5)+186.0D0*R(RG-4)  -570.0D0*R(RG-3)+940.0D0*R(RG-2) &
             -510.0D0*R(RG-1)-294.0D0*R(RG))/(360.0D0*H**2)
    DO I=5,RG-4
     R2D(I)=(-36.0D0*R(I-4) +512.0D0*R(I-3)-4032.0D0*R(I-2)+32256.0D0*R(I-1)-57400.0D0*R(I) &
             +32256.0D0*R(I+1)-4032.0D0*R(I+2)+512.0D0*R(I+3)-36.0D0*R(I+4))/(20160.0D0*H**2)
    ENDDO
   ELSE
    R2D(1)=-2.0D0*R(1)+1.0D0*R(2)
    R2D(RG)=+1.0D0*R(RG-1)-2.0D0*R(RG)
    DO I=2,RG-1
     R2D(I)=+1.0D0*R(I-1)-2.0D0*R(I)+1.0D0*R(I+1)
    ENDDO
   ENDIF

   R0=BSRADI(IATOM(IA))
   DO I=1,RG
    IF (SALG==1) THEN
     CALL PABORT('NOT YET IMPLEMENTED')
    ELSE IF (SALG==-1) THEN
     CALL PABORT('NOT YET IMPLEMENTED')
    ELSE IF (SALG==2) THEN
     CALL PABORT('NOT YET IMPLEMENTED')
    ELSE IF (SALG==-2) THEN
     R(I)=-R1D(I)/(2.0D0*H)/SG_GAUSS_CHEV(I,IA)+R2D(I)/(H**2)/SG_GAUSS_CHEV(I,IA)
    ELSE IF (SALG==3) THEN
     OMEGA=DFLOAT(I)*PI/DFLOAT(RG+1)
     X=DCOS(OMEGA)
     R(I)=+R1D(I)*((1.0D0-X)**3/(2.0D0*R0**2*DSIN(OMEGA)) &
          -(1.0D0-X)**4*DCOS(OMEGA)/(4.0D0*R0**2*DSIN(OMEGA)**3)) &
          +R2D(I)*((1.0D0-X)**2/(2.0D0*R0*DSIN(OMEGA)))**2
    ELSE IF (SALG==-3) THEN
     CALL PABORT('NOT YET IMPLEMENTED')
    ENDIF
   ENDDO

   DEALLOCATE(R2D,R1D)
   RETURN
END SUBROUTINE



SUBROUTINE EXPAND2YLM(F,R,DEST,ORIG)
! Expand a given function as a linear combination of radial spherical functions

   USE CONSTANTS
   USE SINANOGLU

   IMPLICIT NONE
   INTEGER :: DEST,ORIG
   DOUBLE PRECISION :: F(AG,RG)
   DOUBLE COMPLEX   :: YLM
   DOUBLE COMPLEX   :: R(0:LMAX,-LMAX:LMAX,RG)
   DOUBLE PRECISION :: R1
   INTEGER :: I,J,K,L,M

   DO L=0,LMAX       ! LOOP OVER L
    DO M=-L,L        ! LOOP OVER M
     K=0
     DO I=1,RG       ! LOOP OVER RADIAL GRID POINTS
      R(L,M,I)=DCMPLX(0.0D0,0.0D0)
      DO J=1,AG      ! LOOP OVER ANGULAR GRID POINTS
       K=K+1
       CALL RYLM(L,M,K,R1,YLM,DEST,ORIG) ! GET R & YLM AT THE POINT
       R(L,M,I)=R(L,M,I)+DCONJG(YLM)*F(J,I)*SG_LEBEDVW(J)
      ENDDO
     ENDDO
    ENDDO
   ENDDO
   RETURN
END SUBROUTINE



SUBROUTINE PACKYLM(F,R,DEST,ORIG)
! Expand a linear combination of radial spherical functions to real space

   USE CONSTANTS
   USE SINANOGLU

   IMPLICIT NONE
   INTEGER,PARAMETER :: INTORDER=4
   INTEGER :: DEST,ORIG
   DOUBLE PRECISION :: F(AG,RG)
   DOUBLE COMPLEX   :: YLM
   DOUBLE COMPLEX   :: R(0:LMAX,-LMAX:LMAX,RG)
   DOUBLE PRECISION :: R1
   DOUBLE PRECISION :: RREAL,RIMAG,DY
   DOUBLE PRECISION :: X(RG),Y(RG)
   INTEGER :: I,J,K,L,M,N,P

   IF (DEST==ORIG) THEN
   ! SIMPLE EXPANSION
   
    K=0
    DO I=1,RG       ! LOOP OVER RADIAL GRID POINTS
     DO J=1,AG      ! LOOP OVER ANGULAR GRID POINTS
      K=K+1
      F(J,I)=0.0D0
      DO L=0,LMAX   ! LOOP OVER L
       DO M=-L,L    ! LOOP OVER M
        CALL RYLM(L,M,K,R1,YLM,DEST,ORIG) ! GET R & YLM AT THE POINT
        F(J,I)=F(J,I)+R(L,M,I)*YLM
       ENDDO
      ENDDO
     ENDDO
    ENDDO

   ELSE
   ! RATIONAL INTERPOLATION

    X=SG_GAUSS_CHEV(:,ORIG)
    K=0
    DO I=1,RG       ! LOOP OVER RADIAL GRID POINTS OF ATOM IB
     DO J=1,AG      ! LOOP OVER ANGULAR GRID POINTS OF ATOM IB
      K=K+1
      F(J,I)=0.0D0
      DO L=0,LMAX   ! LOOP OVER L CENTERED AT ATOM IA
       DO M=-L,L    ! LOOP OVER M CENTERED AT ATOM IA
        CALL RYLM(L,M,K,R1,YLM,DEST,ORIG) ! GET R & YLM AT THE POINT
        P=1
        DO N=1,RG
         IF (SG_GAUSS_CHEV(N,ORIG) > R1) P=N
        ENDDO
        P=MAX(1,MIN(P-1,RG-3))
        Y=DREAL(R(L,M,:))
        CALL RATINT(X(P),Y(P),INTORDER,R1,RREAL,DY)
        Y=DIMAG(R(L,M,:))
        CALL RATINT(X(P),Y(P),INTORDER,R1,RIMAG,DY)
        F(J,I)=F(J,I)+DCMPLX(RREAL,RIMAG)*YLM
       ENDDO
      ENDDO
     ENDDO
    ENDDO

   ENDIF

   RETURN
END SUBROUTINE



DOUBLE PRECISION FUNCTION SINGLEENERGY(R,RR)
! Int R(r1)RR(r2) dr1dr2.

   USE CONSTANTS
   USE CONTROL
   USE STRUCTURE
   USE INTEGRAL
   USE BASISSET
   USE DFT
   USE SINANOGLU

   IMPLICIT NONE
   DOUBLE COMPLEX :: R(0:LMAX,-LMAX:LMAX,RG,NATOM)
   DOUBLE COMPLEX :: RR(0:LMAX,-LMAX:LMAX,RG,NATOM)
   DOUBLE PRECISION,ALLOCATABLE :: F(:),G(:)
   INTEGER :: I,IA

   SINGLEENERGY=0.0D0
   DO IA=1,NATOM
    ALLOCATE(F(NGRID(IA)),G(NGRID(IA)))
    CALL PACKYLM(F,R(:,:,:,IA),IA,IA)
    CALL PACKYLM(G,RR(:,:,:,IA),IA,IA)
    DO I=1,NGRID(IA)
     SINGLEENERGY=SINGLEENERGY+F(I)*G(I)*GRIDW(I,IA)
    ENDDO
    DEALLOCATE(F,G)
   ENDDO
   RETURN
END FUNCTION



DOUBLE PRECISION FUNCTION OVERLAP(ORB1,ORB2)
! Int ORB1(r1)ORB2(r2) dr1dr2.

   USE CONSTANTS
   USE CONTROL
   USE STRUCTURE
   USE INTEGRAL
   USE BASISSET
   USE DFT
   USE SINANOGLU

   IMPLICIT NONE
   DOUBLE PRECISION :: ORB1(MAXNGRID,NATOM)
   DOUBLE PRECISION :: ORB2(MAXNGRID,NATOM)
   INTEGER :: I,IA

   OVERLAP=0.0D0
   DO IA=1,NATOM
    DO I=1,NGRID(IA)
     OVERLAP=OVERLAP+ORB1(I,IA)*ORB2(I,IA)*GRIDW(I,IA)
    ENDDO
   ENDDO
   RETURN
END FUNCTION



SUBROUTINE RYLM(L,M,I,R,YLM,DEST,ORIG)
! Returns the value of radius and real spherical harmonics of the origin atom
! at a grid point of the destination atom

   USE CONSTANTS
   USE SINANOGLU

   IMPLICIT NONE
   DOUBLE COMPLEX :: YLM
   INTEGER :: L,M
   INTEGER :: I,J
   INTEGER :: DEST,ORIG
   DOUBLE PRECISION :: R,THETA,PHI
   DOUBLE PRECISION :: NORM
   DOUBLE PRECISION,EXTERNAL :: PLGNDR

   CALL C2SPHERICAL(R,THETA,PHI,I,DEST,ORIG)
   YLM=PLGNDR(L,IABS(M),DCOS(THETA))*DCMPLX(DCOS(DFLOAT(IABS(M))*PHI),DSIN(DFLOAT(IABS(M))*PHI))
   NORM = DFLOAT(2*L+1)/4.0D0/PI
   IF (IABS(M) >= 1) THEN
    DO J=L-IABS(M)+1,L+IABS(M)
     NORM=NORM/DFLOAT(J)
    ENDDO
   ENDIF
   YLM=DSQRT(NORM)*YLM
   IF (M < 0) YLM=SGN(M)*DCONJG(YLM)
   RETURN
END SUBROUTINE


   
SUBROUTINE C2SPHERICAL(R,THETA,PHI,I,DEST,ORIG)
! Returns the spherical coordinates of the origin atom of a grid point of the destination atom

   USE CONSTANTS
   USE STRUCTURE
   USE DFT
   USE SINANOGLU
   
   IMPLICIT NONE
   INTEGER :: I
   INTEGER :: DEST,ORIG
   DOUBLE PRECISION :: X,Y,Z
   DOUBLE PRECISION :: R,THETA,PHI

   X=ATOMX(DEST)+GRIDX(I,DEST)-ATOMX(ORIG)
   Y=ATOMY(DEST)+GRIDY(I,DEST)-ATOMY(ORIG)
   Z=ATOMZ(DEST)+GRIDZ(I,DEST)-ATOMZ(ORIG)
   R=DSQRT(X**2+Y**2+Z**2)
   THETA=DACOS(Z/R)
   IF (X == 0.0D0) THEN
    IF (Y > 0.0D0) PHI=PI/2.0D0
    IF (Y < 0.0D0) PHI=-PI/2.0D0
   ELSE IF (Y == 0.0D0) THEN
    IF (X > 0.0D0) PHI=0.0D0
    IF (X < 0.0D0) PHI=-PI
   ELSE IF (X > 0.0D0) THEN
    PHI=DATAN(Y/X)
   ELSE
    PHI=DATAN(Y/X)+PI
   ENDIF
! DEBUG CODE ...
!  IF (DABS(Z-DCOS(THETA))>1.0D-10) WRITE(*,*) 'Z',Z,DCOS(THETA)
!  IF (DABS(X-DSIN(THETA)*DCOS(PHI))>1.0D-10) WRITE(*,*) 'X',X,DSIN(THETA)*DCOS(PHI)
!  IF (DABS(Y-DSIN(THETA)*DSIN(PHI))>1.0D-10) WRITE(*,*) 'Y',Y,DSIN(THETA)*DSIN(PHI)
! ... END DEBUG
   RETURN
END SUBROUTINE



FUNCTION plgndr(l,m,x)
! Returns associated Legendre polynomial value
! (C) Copr. 1986-92 Numerical Recipes Software t.)-5i.

   IMPLICIT NONE
   INTEGER :: l,m
   DOUBLE PRECISION :: plgndr,x
   INTEGER :: i,ll
   DOUBLE PRECISION :: fact,pll,pmm,pmmp1,somx2

   if (m < 0.or.m > l.or.dabs(x) > 1.0d0) call pabort('bad arguments in plgndr')
   pmm=1.0d0
   if(m > 0) then
     somx2=dsqrt((1.0d0-x)*(1.0d0+x))
     fact=1.0d0
     do i=1,m
       pmm=-pmm*fact*somx2
       fact=fact+2.0d0
     enddo
   endif
   if(l == m) then
     plgndr=pmm
   else
     pmmp1=x*dfloat(2*m+1)*pmm
     if(l == m+1) then
       plgndr=pmmp1
     else
       do ll=m+2,l
         pll=(x*dfloat(2*ll-1)*pmmp1-dfloat(ll+m-1)*pmm)/dfloat(ll-m)
         pmm=pmmp1
         pmmp1=pll
       enddo
       plgndr=pll
     endif
   endif
   return
END FUNCTION



SUBROUTINE SG_CONSTRUCT_GRID
! CONSTRUCT GRID FOR NUMERICAL INTEGRATION IN SINANOGLU CALCULATIONS.
 
   USE CONSTANTS
   USE STRUCTURE
   USE CONTROL
   USE DFT
   USE SINANOGLU

   IMPLICIT NONE
   DOUBLE PRECISION,PARAMETER :: BSRADI(17) = &
     (/0.472D0,0.472D0,1.370D0,0.992D0,0.803D0,0.661D0,0.614D0,0.567D0,0.472D0, &
       0.472D0,1.701D0,1.417D0,1.181D0,1.039D0,0.945D0,0.945D0,0.945D0/) ! Ne DATA WAS MISSING IN THE ORIGINAL
   INTEGER :: I,J,K,L,M,II,JJ,IA,JA
   DOUBLE PRECISION :: R1,R2,X,W
   DOUBLE PRECISION :: THETA,PHI
   REAL :: ICPUS,ICPUE

   RG = IOPTN(81)
   AG = IOPTN(82)
   IF (RG*AG == 0) CALL PABORT('SPECIFY RADIAL AND ANGULAR GRIDS')
   IF (RG < 7) CALL PABORT('RADIAL GRID POINTS TOO FEW')
!  IF (NATOM /= 1) CALL PABORT('ATOMIC CALCULATIONS ONLY')

   ALLOCATE(SG_GAUSS_CHEV(RG,NATOM),SG_GAUSS_CHEV_W(RG,NATOM))
   ALLOCATE(SG_LEBEDVX(AG),SG_LEBEDVY(AG),SG_LEBEDVZ(AG),SG_LEBEDVW(AG))

   DO IA=1,NATOM
    R1=BSRADI(IATOM(IA))
    IF (IABS(SALG)==1) THEN
     DO J=1,RG
      SG_GAUSS_CHEV(J,IA)=DFLOAT(RG+1-J)/DFLOAT(RG)*10.0D0
      SG_GAUSS_CHEV_W(J,IA)=10.0D0/DFLOAT(RG)*SG_GAUSS_CHEV(J,IA)**2
     ENDDO
    ELSE IF (IABS(SALG)==2) THEN
     DO J=1,RG
      X=-5.0D0+DFLOAT(RG-J)/DFLOAT(RG)*10.0D0
      SG_GAUSS_CHEV(J,IA)=DEXP(X)/DFLOAT(IATOM(IA))
      SG_GAUSS_CHEV_W(J,IA)=10.0D0/DFLOAT(RG)*SG_GAUSS_CHEV(J,IA)**3
     ENDDO
    ELSE IF (IABS(SALG)==3) THEN
     DO J=1,RG
      X=DCOS(DFLOAT(J)*PI/DFLOAT(RG+1))
      SG_GAUSS_CHEV(J,IA)=R1*(1.0D0+X)/(1.0D0-X)
      SG_GAUSS_CHEV_W(J,IA)=2.0D0*R1/(1.0D0-X)**2*PI/DFLOAT(RG+1)*DSIN(DFLOAT(J)*PI/DFLOAT(RG+1))*SG_GAUSS_CHEV(J,IA)**2
     ENDDO
    ENDIF
   ENDDO

   IF (AG == 1) THEN
    LMAX=0
    SG_LEBEDVX(1)=1.0D0
    SG_LEBEDVY(1)=0.0D0
    SG_LEBEDVZ(1)=0.0D0
    SG_LEBEDVW(1)=1.0D0
   ELSE IF (AG == 6) THEN
    LMAX=1
    CALL LD0006(SG_LEBEDVX,SG_LEBEDVY,SG_LEBEDVZ,SG_LEBEDVW,AG)
   ELSE IF (AG == 14) THEN
    LMAX=2
    CALL LD0014(SG_LEBEDVX,SG_LEBEDVY,SG_LEBEDVZ,SG_LEBEDVW,AG)
   ELSE IF (AG == 26) THEN
    LMAX=3
    CALL LD0026(SG_LEBEDVX,SG_LEBEDVY,SG_LEBEDVZ,SG_LEBEDVW,AG)
   ELSE IF (AG == 38) THEN
    LMAX=4
    CALL LD0038(SG_LEBEDVX,SG_LEBEDVY,SG_LEBEDVZ,SG_LEBEDVW,AG)
   ELSE IF (AG == 50) THEN
    LMAX=5
    CALL LD0050(SG_LEBEDVX,SG_LEBEDVY,SG_LEBEDVZ,SG_LEBEDVW,AG)
   ELSE IF (AG == 74) THEN
    LMAX=6
    CALL LD0074(SG_LEBEDVX,SG_LEBEDVY,SG_LEBEDVZ,SG_LEBEDVW,AG)
   ELSE IF (AG == 86) THEN
    LMAX=7
    CALL LD0086(SG_LEBEDVX,SG_LEBEDVY,SG_LEBEDVZ,SG_LEBEDVW,AG)
   ELSE IF (AG == 110) THEN
    LMAX=8
    CALL LD0110(SG_LEBEDVX,SG_LEBEDVY,SG_LEBEDVZ,SG_LEBEDVW,AG)
   ELSE IF (AG == 146) THEN
    LMAX=9
    CALL LD0146(SG_LEBEDVX,SG_LEBEDVY,SG_LEBEDVZ,SG_LEBEDVW,AG)
   ELSE IF (AG == 170) THEN
    LMAX=10
    CALL LD0170(SG_LEBEDVX,SG_LEBEDVY,SG_LEBEDVZ,SG_LEBEDVW,AG)
   ELSE IF (AG == 194) THEN
    LMAX=11
    CALL LD0194(SG_LEBEDVX,SG_LEBEDVY,SG_LEBEDVZ,SG_LEBEDVW,AG)
   ELSE IF (AG == 230) THEN
    LMAX=12
    CALL LD0230(SG_LEBEDVX,SG_LEBEDVY,SG_LEBEDVZ,SG_LEBEDVW,AG)
   ELSE IF (AG == 266) THEN
    LMAX=13
    CALL LD0266(SG_LEBEDVX,SG_LEBEDVY,SG_LEBEDVZ,SG_LEBEDVW,AG)
   ELSE IF (AG == 302) THEN
    LMAX=14
    CALL LD0302(SG_LEBEDVX,SG_LEBEDVY,SG_LEBEDVZ,SG_LEBEDVW,AG)
   ELSE IF (AG == 350) THEN
    LMAX=(31-1)/2
    CALL LD0350(SG_LEBEDVX,SG_LEBEDVY,SG_LEBEDVZ,SG_LEBEDVW,AG)
   ELSE IF (AG == 434) THEN
    LMAX=(35-1)/2
    CALL LD0434(SG_LEBEDVX,SG_LEBEDVY,SG_LEBEDVZ,SG_LEBEDVW,AG)
   ELSE IF (AG == 590) THEN
    LMAX=(41-1)/2
    CALL LD0590(SG_LEBEDVX,SG_LEBEDVY,SG_LEBEDVZ,SG_LEBEDVW,AG)
   ELSE IF (AG == 770) THEN
    LMAX=(47-1)/2
    CALL LD0770(SG_LEBEDVX,SG_LEBEDVY,SG_LEBEDVZ,SG_LEBEDVW,AG)
   ELSE IF (AG == 974) THEN
    LMAX=(53-1)/2
    CALL LD0974(SG_LEBEDVX,SG_LEBEDVY,SG_LEBEDVZ,SG_LEBEDVW,AG)
   ELSE IF (AG == 1202) THEN
    LMAX=(59-1)/2
    CALL LD1202(SG_LEBEDVX,SG_LEBEDVY,SG_LEBEDVZ,SG_LEBEDVW,AG)
   ELSE IF (AG == 1454) THEN
    LMAX=(65-1)/2
    CALL LD1454(SG_LEBEDVX,SG_LEBEDVY,SG_LEBEDVZ,SG_LEBEDVW,AG)
   ELSE IF (AG == 1730) THEN
    LMAX=(71-1)/2
    CALL LD1730(SG_LEBEDVX,SG_LEBEDVY,SG_LEBEDVZ,SG_LEBEDVW,AG)
   ELSE IF (AG == 2030) THEN
    LMAX=(77-1)/2
    CALL LD2030(SG_LEBEDVX,SG_LEBEDVY,SG_LEBEDVZ,SG_LEBEDVW,AG)
   ELSE IF (AG == 2354) THEN
    LMAX=(83-1)/2
    CALL LD2354(SG_LEBEDVX,SG_LEBEDVY,SG_LEBEDVZ,SG_LEBEDVW,AG)
   ELSE IF (AG == 2702) THEN
    LMAX=(89-1)/2
    CALL LD2702(SG_LEBEDVX,SG_LEBEDVY,SG_LEBEDVZ,SG_LEBEDVW,AG)
   ELSE IF (AG == 3074) THEN
    LMAX=(95-1)/2
    CALL LD3074(SG_LEBEDVX,SG_LEBEDVY,SG_LEBEDVZ,SG_LEBEDVW,AG)
   ELSE IF (AG == 3470) THEN
    LMAX=(101-1)/2
    CALL LD3470(SG_LEBEDVX,SG_LEBEDVY,SG_LEBEDVZ,SG_LEBEDVW,AG)
   ELSE IF (AG == 3890) THEN
    LMAX=(107-1)/2
    CALL LD3890(SG_LEBEDVX,SG_LEBEDVY,SG_LEBEDVZ,SG_LEBEDVW,AG)
   ELSE IF (AG == 4334) THEN
    LMAX=(113-1)/2
    CALL LD4334(SG_LEBEDVX,SG_LEBEDVY,SG_LEBEDVZ,SG_LEBEDVW,AG)
   ELSE IF (AG == 4802) THEN
    LMAX=(119-1)/2
    CALL LD4802(SG_LEBEDVX,SG_LEBEDVY,SG_LEBEDVZ,SG_LEBEDVW,AG)
   ELSE IF (AG == 5294) THEN
    LMAX=(125-1)/2
    CALL LD5294(SG_LEBEDVX,SG_LEBEDVY,SG_LEBEDVZ,SG_LEBEDVW,AG)
   ELSE IF (AG == 5810) THEN
    LMAX=(131-1)/2
    CALL LD5810(SG_LEBEDVX,SG_LEBEDVY,SG_LEBEDVZ,SG_LEBEDVW,AG)
   ELSE
    CALL PABORT('LEBEDEV GRID NOT FOUND')
   ENDIF
   DO J=1,AG
    SG_LEBEDVW(J)=SG_LEBEDVW(J)*4.0D0*PI
   ENDDO

   ! SET GRID INFORMATION IN CONVENTIONAL DFT FASHION
   M=0
   DO IA=1,NATOM
    WRITE(6,'(A,I0,A,A,A,I0,A,I0,A,I0,A)') 'GRID FOR ATOM ',IA,' ( ',CATOM(IATOM(IA)),' ) IS ',RG,' x ',AG,' (LMAX = ',LMAX,')'
    NGRID(IA)=RG*AG
    DO J=1,RG
     DO K=1,AG
      M=M+1
      GRIDX((J-1)*AG+K,IA)=SG_GAUSS_CHEV(J,IA)*SG_LEBEDVX(K)
      GRIDY((J-1)*AG+K,IA)=SG_GAUSS_CHEV(J,IA)*SG_LEBEDVY(K)
      GRIDZ((J-1)*AG+K,IA)=SG_GAUSS_CHEV(J,IA)*SG_LEBEDVZ(K)
      GRIDW((J-1)*AG+K,IA)=SG_GAUSS_CHEV_W(J,IA)*SG_LEBEDVW(K)
     ENDDO
    ENDDO
   ENDDO
   WRITE(6,'(A,I0)') 'NUMBER OF GRID POINTS = ',M

   ! FORM A DISTANCE MATRIX
!  ALLOCATE(R12(MAXNGRID,NATOM,MAXNGRID,NATOM))
!  ALLOCATE(RECIPROCALR12(MAXNGRID,NATOM,MAXNGRID,NATOM))
!  DO IA=1,NATOM
!   DO II=1,NGRID(IA)
!    DO JA=1,NATOM
!     DO JJ=1,NGRID(JA)
!      R12(II,IA,JJ,JA)=DSQRT((ATOMX(JA)+GRIDX(JJ,JA)-ATOMX(IA)-GRIDX(II,IA))**2 &
!                            +(ATOMY(JA)+GRIDY(JJ,JA)-ATOMY(IA)-GRIDY(II,IA))**2 &
!                            +(ATOMZ(JA)+GRIDZ(JJ,JA)-ATOMZ(IA)-GRIDZ(II,IA))**2)
!      IF ((IA == JA).AND.(II == JJ)) THEN
!       RECIPROCALR12(II,IA,JJ,JA)=0.0D0
!      ELSE
!       RECIPROCALR12(II,IA,JJ,JA)=1.0D0/R12(II,IA,JJ,JA)
!      ENDIF
!     ENDDO
!    ENDDO
!   ENDDO
!  ENDDO

   RETURN
END SUBROUTINE



SUBROUTINE SG_DESTROY_GRID
! DEALLOCATE GRID RELATED ARRAYS

   USE SINANOGLU

   IMPLICIT NONE

   DEALLOCATE(SG_GAUSS_CHEV,SG_GAUSS_CHEV_W,SG_LEBEDVX,SG_LEBEDVY,SG_LEBEDVZ,SG_LEBEDVW)

   RETURN
END SUBROUTINE



DOUBLE PRECISION FUNCTION WIGNER3J(L1,L2,L3,M1,M2,M3)
! RETURNS WIGNER 3J SYMBOL NUMERICAL VALUES

   USE SINANOGLU

   IMPLICIT NONE
   INTEGER :: L1,L2,L3,M1,M2,M3
   INTEGER :: JMIN,JMAX,J
   INTEGER :: I1,I2,I3,I4,I5
   DOUBLE PRECISION :: A,B,C

   IF ((L3 > L1+L2).OR.(L3 < IABS(L1-L2)).OR.(IABS(M1) > L1).OR.(IABS(M2) > L2).OR.(IABS(M3) > L3).OR.(M1+M2+M3/=0)) THEN
!   CALL PABORT('WIGNER3J ARGUMENTS OUT OF BOUNDS')
    CALL WARNING('WIGNER3J ARGUMENTS OUT OF BOUNDS')
    WRITE(6,'(6I3)') L1,L2,L3,M1,M2,M3
    WIGNER3J=0.0D0
    RETURN
   ENDIF

   A=(FACTORIAL(L1+L2-L3)*FACTORIAL(L1-L2+L3)*FACTORIAL(-L1+L2+L3))/(FACTORIAL(L1+L2+L3+1))
   B=(FACTORIAL(L1+M1)*FACTORIAL(L1-M1)*FACTORIAL(L2+M2)*FACTORIAL(L2-M2)*FACTORIAL(L3+M3)*FACTORIAL(L3-M3))
   I1=L2-L3-M1
   I2=L1-L3+M2
   I3=L1-M1
   I4=L2+M2
   I5=L1+L2-L3
   JMIN=MAX(0,MAX(I1,I2))
   JMAX=MIN(I3,MIN(I4,I5))
   C=0.0D0
   DO J=JMIN,JMAX
    C=C+SGN(J)/(FACTORIAL(J)*FACTORIAL(J-I1)*FACTORIAL(J-I2)*FACTORIAL(I3-J)*FACTORIAL(I4-J)*FACTORIAL(I5-J))
   ENDDO
   WIGNER3J=(SGN(L1-L2-M3))*DSQRT(A)*DSQRT(B)*C
   RETURN
END FUNCTION



SUBROUTINE COMPARE(R,RR,X,IORB,TITLE)
! Compare the numerical and analytical values for the same integrals

    USE INTEGRAL
    USE BASISSET
    USE SINANOGLU

    IMPLICIT NONE
    INTEGER :: IORB
    DOUBLE COMPLEX :: R(0:LMAX,-LMAX:LMAX,RG)
    DOUBLE COMPLEX :: RR(0:LMAX,-LMAX:LMAX,RG)
    DOUBLE PRECISION :: X(NCGS,NCGS)
    DOUBLE PRECISION :: Y,Z
    DOUBLE PRECISION,EXTERNAL :: SINGLEENERGY
    CHARACTER*(*) :: TITLE
    INTEGER I,J,K,L,M

    Y=SINGLEENERGY(R,RR)
    Z=0.0D0
    DO J=1,NCGS
     DO K=1,NCGS
      Z=Z+DREAL(CO(J,IORB,0,0,0)*CO(K,IORB,0,0,0))*X(J,K)
     ENDDO
    ENDDO
    WRITE(6,'(A,A,F15.10,A,F15.10,A)') TITLE,' = ',Y,' (ANALYTIC',Z,') HARTREE'
    RETURN
END SUBROUTINE



SUBROUTINE COMPARE_DIRECT(ORB1,ORB2,X,IORB,TITLE)
! Compare the numerical and analytical values for the same integrals

    USE INTEGRAL
    USE STRUCTURE
    USE BASISSET
    USE DFT
    USE SINANOGLU

    IMPLICIT NONE
    INTEGER :: IORB
    DOUBLE PRECISION :: ORB1(MAXNGRID,NATOM)
    DOUBLE PRECISION :: ORB2(MAXNGRID,NATOM)
    DOUBLE PRECISION :: X(NCGS,NCGS)
    DOUBLE PRECISION :: Y,Z
    DOUBLE PRECISION,EXTERNAL :: OVERLAP
    CHARACTER*(*) :: TITLE
    INTEGER I,J,K,L,M

    Y=OVERLAP(ORB1,ORB2)
    Z=0.0D0
    DO J=1,NCGS
     DO K=1,NCGS
      Z=Z+DREAL(CO(J,IORB,0,0,0)*CO(K,IORB,0,0,0))*X(J,K)
     ENDDO
    ENDDO
    WRITE(6,'(A,A,F15.10,A,F15.10,A)') TITLE,' = ',Y,' (ANALYTIC',Z,') HARTREE'
    RETURN
END SUBROUTINE



SUBROUTINE SORT_EIGENVALUES(N,NP,ER,EI,VL,VR)
! SORTS THE EIGENVECTORS IN INCREASING ORDER OF EIGENVALUES

   IMPLICIT NONE
   INTEGER :: N,NP
   INTEGER :: I,J,K
   DOUBLE PRECISION :: ER(NP),EI(NP),VL(NP,NP),VR(NP,NP)
   DOUBLE PRECISION,ALLOCATABLE :: WE(:),WI(:),WL(:,:),WR(:,:)
   DOUBLE PRECISION :: C

   ALLOCATE(WE(NP),WI(NP),WL(NP,NP),WR(NP,NP))

   DO I=1,N
    C=1.0D99
    DO J=1,N
     IF (ER(J) < C) THEN
      K=J
      C=ER(J)
     ENDIF
    ENDDO
    WE(I)=ER(K)
    WI(I)=EI(K)
    WL(:,I)=VL(:,K)
    WR(:,I)=VR(:,K)
    ER(K)=2.0D99
   ENDDO
   ER=WE
   EI=WI
   VL=WL
   VR=WR
   DEALLOCATE(WE,WI,WL,WR)
   RETURN
END SUBROUTINE



SUBROUTINE SCHMIDT_EIGENVECTORS(N,VR)
! GRAM-SCHMIDT BIORTHOGONALIZE LEFT & RIGHT EIGENVECTORS

   IMPLICIT NONE
   INTEGER :: N
   INTEGER :: I,J,K
   DOUBLE PRECISION :: VR(N,N)
   DOUBLE PRECISION :: C,D

   DO I=2,N
    DO J=1,I-1
     D=0.0D0
     DO K=1,N
      D=D+VR(K,J)*VR(K,J)
     ENDDO
     C=0.0D0
     DO K=1,N
      C=C+VR(K,J)*VR(K,I)
     ENDDO
     VR(:,I)=VR(:,I)-C*VR(:,J)/D
    ENDDO
   ENDDO
   DO I=1,N
    C=0.0D0
    DO K=1,N
     C=C+VR(K,I)*VR(K,I)
    ENDDO
    VR(:,I)=VR(:,I)/DSQRT(C)
   ENDDO

   RETURN
END SUBROUTINE



SUBROUTINE QPROJECTOR_GRID(PAIR)
! Project out occupied orbital components from a pair function.

   USE STRUCTURE
   USE INTEGRAL
   USE DFT
   USE SINANOGLU

   IMPLICIT NONE
   DOUBLE PRECISION :: PAIR(MAXNGRID,NATOM,MAXNGRID,NATOM)
   INTEGER :: IA,JA
   INTEGER :: IG,JG
   INTEGER :: K
   DOUBLE PRECISION :: OV

   DO JA=1,NATOM
    DO JG=1,NGRID(JA)
     DO K=1,IOCC
      OV=0.0D0
      DO IA=1,NATOM
       DO IG=1,NGRID(IA)
        OV=OV+ORBITALS(IG,IA,K)*PAIR(IG,IA,JG,JA)*GRIDW(IG,IA)
       ENDDO
      ENDDO
      DO IA=1,NATOM
       DO IG=1,NGRID(IA)
        PAIR(IG,IA,JG,JA)=PAIR(IG,IA,JG,JA)-OV*ORBITALS(IG,IA,K)
       ENDDO
      ENDDO
     ENDDO
    ENDDO
   ENDDO
   DO JA=1,NATOM
    DO JG=1,NGRID(JA)
     DO K=1,IOCC
      OV=0.0D0
      DO IA=1,NATOM
       DO IG=1,NGRID(IA)
        OV=OV+ORBITALS(IG,IA,K)*PAIR(JG,JA,IG,IA)*GRIDW(IG,IA)
       ENDDO
      ENDDO
      DO IA=1,NATOM
       DO IG=1,NGRID(IA)
        PAIR(JG,JA,IG,IA)=PAIR(JG,JA,IG,IA)-OV*ORBITALS(IG,IA,K)
       ENDDO
      ENDDO
     ENDDO
    ENDDO
   ENDDO
   RETURN
END SUBROUTINE



SUBROUTINE QPROJECTOR_MO(PAIR)
! Project out occupied orbital components from a pair function.

   USE STRUCTURE
   USE INTEGRAL
   USE DFT
   USE SINANOGLU

   IMPLICIT NONE
   DOUBLE PRECISION :: PAIR(NAO,NAO)
   INTEGER :: I,J

   DO I=1,NAO
    DO J=1,IOCC
     PAIR(J,I)=0.0D0
     PAIR(I,J)=0.0D0
    ENDDO
   ENDDO
   RETURN
END SUBROUTINE



SUBROUTINE SYMMETRIZE(NG,PAIR,ISPIN)
! Project out occupied orbitals from a pair function.

   USE CONSTANTS
   USE CONTROL
   USE STRUCTURE
   USE INTEGRAL
   USE BASISSET
   USE DFT
   USE SINANOGLU

   IMPLICIT NONE
   INTEGER :: NG
   DOUBLE PRECISION :: PAIR(NG,NG)
   INTEGER :: ISPIN ! 1: SYMMETRIZE; 2: ANTISYMMETRIZE
   INTEGER :: IG,JG
   DOUBLE PRECISION :: OV

   IF (ISPIN==1) THEN
    DO IG=1,NG
     DO JG=IG,NG
      OV=(PAIR(JG,IG)+PAIR(IG,JG))/2.0D0
      PAIR(JG,IG)=OV
      PAIR(IG,JG)=OV
     ENDDO
    ENDDO
   ELSE IF (ISPIN==2) THEN
    DO IG=1,NG
     DO JG=IG,NG
      OV=(PAIR(JG,IG)-PAIR(IG,JG))/2.0D0
      PAIR(JG,IG)=OV
      PAIR(IG,JG)=-OV
     ENDDO
    ENDDO
   ELSE
    CALL PABORT('A BUG')
   ENDIF

   RETURN
END SUBROUTINE



SUBROUTINE ratint(xa,ya,n,x,y,dy)
IMPLICIT NONE
INTEGER n,NMAX
DOUBLE PRECISION dy,x,y,xa(n),ya(n),TINY
PARAMETER (NMAX=10,TINY=1.d-25)
INTEGER i,m,ns
DOUBLE PRECISION dd,h,hh,t,w,c(NMAX),d(NMAX)
ns=1
hh=dabs(x-xa(1))
do i=1,n
  h=dabs(x-xa(i))
  if (h.eq.0.0d0)then
    y=ya(i)
    dy=0.0d0
    return
  else if (h.lt.hh) then
    ns=i
    hh=h
  endif
  c(i)=ya(i)
  d(i)=ya(i)+TINY
enddo
y=ya(ns)
ns=ns-1
do m=1,n-1
  do i=1,n-m
    w=c(i+1)-d(i)
    h=xa(i+m)-x
    t=(xa(i)-x)*d(i)/h
    dd=t-c(i+1)
    if(dd.eq.0.0d0) call pabort('failure in ratint')
    dd=w/dd
    d(i)=c(i+1)*dd
    c(i)=t*dd
  enddo
  if (2*ns.lt.n-m)then
    dy=c(ns+1)
  else
    dy=d(ns)
    ns=ns-1
  endif
  y=y+dy
enddo
return
END
