SUBROUTINE DEGENERATE_MP(ORDER)
! DEGENERATE MP OF HIRSCHFELDER & CERTAIN

   USE CONSTANTS
   USE CONTROL
   USE STRUCTURE
   USE INTEGRAL
   USE BASISSET
   USE GRADIENT
   USE THR_FULLCI

   IMPLICIT NONE
!integer,parameter :: itarget=0    ! debug mode turned off
!integer,parameter :: itarget=4033 ! ground state , nondegenerate
!integer,parameter :: itarget=4036 ! excited state, 2-fold degenerate
!integer,parameter :: itarget=4018 ! excited state, 2-fold degenerate uncoupled
!integer,parameter :: itarget=4021 ! excited state, 1-fold degenerate
!integer,parameter :: itarget=3818 ! ionized state, 2-fold degenerate uncoupled
!integer,parameter :: itarget=2610 ! ionized state, 5-fold degenerate
!integer,parameter :: itarget=3438 ! 4-alpha,4-beta,2-fold,coupled x 2
!integer,parameter :: itarget=3440 ! 2-fold, coupled, divergent off the bat!
!double precision,parameter :: etarget=-51.4814928855d0
 integer,parameter :: itarget=4034 ! excited state, 4-fold
   LOGICAL :: LALL
   INTEGER,ALLOCATABLE :: ITARGETS(:)
   INTEGER :: JTARGET,JDEGEN
   INTEGER :: NELEA_TARGET,NELEB_TARGET
   INTEGER :: ORDER
   INTEGER :: IORDER
   INTEGER :: NALL_CHECK,I,J,K,L
   INTEGER :: IA,IB
   INTEGER,PARAMETER :: MAXNDEGEN=99
   REAL :: ICPUS,ICPUE
   DOUBLE PRECISION,ALLOCATABLE :: E0(:)
   DOUBLE PRECISION,ALLOCATABLE :: FACTORIAL(:)
   DOUBLE PRECISION,ALLOCATABLE :: ALLE_LAMBDA(:,:)
   DOUBLE PRECISION,ALLOCATABLE :: A(:,:),ER(:),EI(:),VR(:,:),VL(:,:),WK(:)
   DOUBLE PRECISION,ALLOCATABLE :: EHCSUM(:,:)
   DOUBLE PRECISION :: PREVIOUSMIN,CURRENTMIN
   INTEGER :: INFO
   INTEGER :: LIST(MAXNDEGEN)
   LOGICAL :: LCHECK
   CHARACTER(40) :: CBITSA,CBITSB

   WRITE(6,'(/,A)') '*******************************'
   WRITE(6,'(A)')   '* GENERAL-ORDER DEGENERATE MP *'
   WRITE(6,'(A)')   '*******************************'

   IF (ORDER==0) RETURN
   IF ((KVCX /= 0).OR.(KVCY /= 0).OR.(KVCZ /= 0)) CALL PABORT('FOR MOLECULES ONLY')
   IF (LOPTN(25)) CALL PABORT('USE NON-DIRECT ALGORITHM')
   IF (IALL(0,0,0)-IOCC-IVIRTCORE <= 0) CALL PABORT('NO VIRTUAL ORBITAL')

   WRITE(6,'(A,I0)')      'ORDER     = ',ORDER
!if (itarget /= 0) write(*,*) 'debug mode ******************** for state ',itarget
   CALL CPU_TIME(ICPUS)

   IF (IOPTN(59) <= 0) THEN
    WRITE(6,'(A)') 'ALL ROOTS ARE SOUGHT'
    WRITE(6,'(A,I10)') 'NUMBER OF ROOTS = ',2**(2*(IALLMAX-IVIRTCORE-ICORE))
    LALL=.TRUE.
    IF (IALL(0,0,0)-IOCC-IVIRTCORE > 15) CALL PABORT('INTEGER*4 ARGUMENT OVERFLOW')
   ELSE IF (LOPTN(60)) THEN
    NELEA_TARGET=IOCC-1
    NELEB_TARGET=IOCC
    WRITE(6,'(A)') 'IP ROOTS ARE SOUGHT'
    WRITE(6,'(A,2I3)') 'NELEA,NELEB = ',NELEA_TARGET,NELEB_TARGET
    WRITE(6,'(A,I3)') 'NUMBER OF ROOTS = ',IOPTN(59)
    LALL=.FALSE.
   ELSE IF (LOPTN(61)) THEN
    NELEA_TARGET=IOCC+1
    NELEB_TARGET=IOCC
    WRITE(6,'(A)') 'EA ROOTS ARE SOUGHT'
    WRITE(6,'(A,2I3)') 'NELEA,NELEB = ',NELEA_TARGET,NELEB_TARGET
    WRITE(6,'(A,I3)') 'NUMBER OF ROOTS = ',IOPTN(59)
    LALL=.FALSE.
   ELSE
    NELEA_TARGET=IOCC
    NELEB_TARGET=IOCC
    WRITE(6,'(A)') 'EXCITED ROOTS ARE SOUGHT'
    WRITE(6,'(A,2I3)') 'NELEA,NELEB = ',NELEA_TARGET,NELEB_TARGET
    WRITE(6,'(A,I3)') 'NUMBER OF ROOTS = ',IOPTN(59)
    LALL=.FALSE.
   ENDIF

   ALLOCATE(H(IALLMAX-IVIRTCORE,IALLMAX-IVIRTCORE))
   ALLOCATE(G(IALLMAX-IVIRTCORE,IALLMAX-IVIRTCORE,IALLMAX-IVIRTCORE,IALLMAX-IVIRTCORE))
   CALL THERMAL_ONE_ELECTRON_INTEGRALS
   CALL THERMAL_TWO_ELECTRON_INTEGRALS

   IF (LALL) THEN
    IF (IALL(0,0,0)-IOCC-IVIRTCORE > 15) THEN
     WRITE(6,'(A)') 'INTEGER*4 ARGUMENT OVERFLOW'
     WRITE(6,'(A)') 'SKIPPING DEGENERATE MP'
     RETURN
    ENDIF
    NALL=2**(2*(IALL(0,0,0)-IVIRTCORE-ICORE))
   ELSE
    CALL THERMAL_GENERATE_CONFIGURATIONSA(NELEA_TARGET,MIN(NELEA_TARGET,IALL(0,0,0)-IVIRTCORE-NELEA_TARGET))
    CALL THERMAL_GENERATE_CONFIGURATIONSB(NELEB_TARGET,MIN(NELEB_TARGET,IALL(0,0,0)-IVIRTCORE-NELEB_TARGET))
    NALL=NCFA*NCFB
    DEALLOCATE(CFHALFA,ADDRSSA,NORDERA)
    DEALLOCATE(CFHALFB,ADDRSSB,NORDERB)
   ENDIF
   WRITE(6,'(A,I10)') 'DIMENSION OF E0 ARRAY = ',NALL
   ALLOCATE(E0(NALL),ALLE(NALL),ALLN(NALL),ALL_M(NALL))

   ! ==========================================
   ! GENERATE HCPT EFFECTIVE HAMILTONIAN MATRIX
   ! ==========================================
   !
   ! ZEROTH-ORDER ENERGIES UNSORTED
   !                       ^^^^^^^^
   NALL_CHECK=0
   ESHIFT=1.0D9
   DO NELE=2*ICORE,2*(IALL(0,0,0)-IVIRTCORE)
    DO NELEA=ICORE,NELE
     NELEB=NELE-NELEA
     IF ((.NOT.LALL).AND.((NELEA /= NELEA_TARGET).OR.(NELEB /= NELEB_TARGET))) CYCLE
     IF (NELEA > IALL(0,0,0)-IVIRTCORE) CYCLE
     IF (NELEB > IALL(0,0,0)-IVIRTCORE) CYCLE
     IF (NELEA < ICORE) CYCLE
     IF (NELEB < ICORE) CYCLE
!    WRITE(6,'(A    )') '============================'
!    WRITE(6,'(A,2I3)') 'NUMBER OF ELECTRONS = ',NELEA,NELEB
!    WRITE(6,'(A    )') '============================'
     CALL THERMAL_GENERATE_CONFIGURATIONSA(NELEA,MIN(NELEA,IALL(0,0,0)-IVIRTCORE-NELEA))
     CALL THERMAL_GENERATE_CONFIGURATIONSB(NELEB,MIN(NELEB,IALL(0,0,0)-IVIRTCORE-NELEB))
     DO IA=1,NCFA
      DO IB=1,NCFB
       E0(NALL_CHECK+(IA-1)*NCFB+IB)=NUCLEAR_REPULSION
       DO I=1,IALL(0,0,0)-IVIRTCORE
        IF (BTEST(CFHALFA(IA),I-1)) &
         E0(NALL_CHECK+(IA-1)*NCFB+IB)=E0(NALL_CHECK+(IA-1)*NCFB+IB)+EPSILON(I,0,0,0)
        IF (BTEST(CFHALFB(IB),I-1)) &
         E0(NALL_CHECK+(IA-1)*NCFB+IB)=E0(NALL_CHECK+(IA-1)*NCFB+IB)+EPSILON(I,0,0,0)
       ENDDO
      ENDDO
     ENDDO
     DO I=1,NCFA*NCFB
      ALLN(NALL_CHECK+I)=NELE
      IF (E0(NALL_CHECK+I) < ESHIFT) ESHIFT=E0(NALL_CHECK+I)
     ENDDO
     NALL_CHECK=NALL_CHECK+NCFA*NCFB
     DEALLOCATE(CFHALFA,ADDRSSA,NORDERA)
     DEALLOCATE(CFHALFB,ADDRSSB,NORDERB)
    ENDDO
   ENDDO
   IF (NALL /= NALL_CHECK) CALL PABORT('ERROR IN DEGENERATE_MP')
   NALL=NALL_CHECK
   !
   ! POPULATE TARGET STATES
   ! 
   IF (.NOT.LALL) THEN
    ALLOCATE(ITARGETS(IOPTN(59)))
    PREVIOUSMIN=-1.0D99
    DO I=1,IOPTN(59)
     CURRENTMIN=1.0D99
     DO J=1,NALL
      IF ((E0(J) < CURRENTMIN).AND.(DABS(E0(J)-CURRENTMIN) > 1.0D-9).AND.(E0(J)-PREVIOUSMIN > 1.0D-9)) THEN
!     IF ((E0(J)-PREVIOUSMIN > 1.0D-9).AND.(E0(J) < CURRENTMIN)) THEN
       CURRENTMIN=E0(J)
       ITARGETS(I)=J
      ENDIF
     ENDDO
     PREVIOUSMIN=CURRENTMIN
    ENDDO
    DO I=1,IOPTN(59)
     K=0 
     DO J=1,NALL
      IF (DABS(E0(J)-E0(ITARGETS(I))) < 1.0D-9) K=K+1
     ENDDO 
     WRITE(6,'(A,I3,A,I10,A,F15.10,I5,A)') 'TARGET',I,' = STATE',ITARGETS(I),' ZEROTH-ORDER ENERGY = ',E0(ITARGETS(I)),&
                                            K,'-FOLD DEGENERATE'
    ENDDO

   ENDIF
   !
   ! ALLOCATE EHC ARRAY AND POPULATE ZEROTH ORDER
   !
   ALLOCATE(EHC(NALL,NALL,0:ORDER),VHC(NALL,NALL,0:ORDER))
   ALLOCATE(EHCSUM(NALL,NALL))
   EHC=0.0D0
   DO I=1,NALL
    EHC(I,I,0)=E0(I)
   ENDDO
   VHC=0.0D0
   DO I=1,NALL
    VHC(I,I,0)=1.0D0
   ENDDO
   EHCSUM=EHC(:,:,0)

   ! =========
   ! ALL ROOTS
   ! =========
   IF (LALL) THEN

   CALL CPU_TIME(ICPUS)
   WRITE(6,'(A)') 'GENERATING THE ENTIRE HCPT MATRIX FOR ALL ROOTS'

   DO IORDER=1,ORDER
    NALL_CHECK=0
    DO NELE=2*ICORE,2*(IALL(0,0,0)-IVIRTCORE)
     DO NELEA=ICORE,NELE
      NELEB=NELE-NELEA
      IF (NELEA > IALL(0,0,0)-IVIRTCORE) CYCLE
      IF (NELEB > IALL(0,0,0)-IVIRTCORE) CYCLE
      IF (NELEA < ICORE) CYCLE
      IF (NELEB < ICORE) CYCLE
      CALL THERMAL_GENERATE_CONFIGURATIONSA(NELEA,MIN(NELEA,IALL(0,0,0)-IVIRTCORE-NELEA))
      CALL THERMAL_GENERATE_CONFIGURATIONSB(NELEB,MIN(NELEB,IALL(0,0,0)-IVIRTCORE-NELEB))
      CALL EHC_GEN(IORDER,NALL_CHECK)
      EHCSUM(NALL_CHECK+1:NALL_CHECK+NCFA*NCFB,NALL_CHECK+1:NALL_CHECK+NCFA*NCFB)= &
       EHCSUM(NALL_CHECK+1:NALL_CHECK+NCFA*NCFB,NALL_CHECK+1:NALL_CHECK+NCFA*NCFB)+ &
       EHC(NALL_CHECK+1:NALL_CHECK+NCFA*NCFB,NALL_CHECK+1:NALL_CHECK+NCFA*NCFB,IORDER)
       DO I=NALL_CHECK+1,NALL_CHECK+NCFA*NCFB
        K=0
        LIST=0
        DO J=NALL_CHECK+1,NALL_CHECK+NCFA*NCFB
         IF (DABS(EHC(J,J,0)-EHC(I,I,0)) < 1.0D-9) THEN
          K=K+1
          LIST(K)=J
         ENDIF
        ENDDO
        IF (K > MAXNDEGEN) CALL PABORT('ERROR')
if ((itarget==0).or.(i==itarget)) then
!if (dabs(etarget-e0(i)) < 1.0d-9) then
        ALLOCATE(A(K,K),ER(K),EI(K),VR(K,K),VL(1,K),WK(4*K))
        LCHECK=.FALSE.
        A=0.0D0
        DO J=1,K
         DO L=1,K
          A(L,J)=EHCSUM(LIST(L),LIST(J))
          IF ((L /= J).AND.(DABS(EHCSUM(LIST(L),LIST(J))) > 1.0D-9)) LCHECK=.TRUE.
         ENDDO
        ENDDO
        IF (LCHECK) WRITE(*,'(A,I5,X,I2,A,100I5)') '***** STATE ',I,K,'-FOLD DEGENERATE:',(LIST(J),J=1,K)
        IF (.NOT.LCHECK) WRITE(*,'(A,I5,X,I2,A,100I5)') '===== STATE ',I,K,'-FOLD DEGENERATE, UNCOUPLED:',(LIST(J),J=1,K)
        WRITE(6,'(A,I3,A)') 'ORDER:',IORDER,' ACCUMULATED HIRSCHFELDER-CERTAIN ENERGY MATRIX'
! *** NOTE: Diagonalization of incremental (e.g., second-order) H-C energy matrix gives
!           correct eigenvalues, but the order of states is scrambled. Summing over eigenvalues
!           in the order of their sizes will be incorrect. The same eigenvector for a higher
!           perturbation order diagonalizes all lower-order H-C energy matrices.
        CALL DUMP5(A,K)
        CALL DGEEV('N','V',K,A,K,ER,EI,VL,1,VR,K,WK,4*K,INFO)
        IF (INFO /= 0) CALL PABORT('DGEEV FAILED TO DIAGONALIZE A MATRIX')
        CALL PIKSRT2(K,K,ER,EI,VR,WK)
        DO J=1,K
         WRITE(*,'(I5,2F20.10,A)') J,ER(J),EI(J),'i'
!        WRITE(*,'(I5,F20.10,128F10.4:)') J,ER(J),(VR(L,J),L=1,K)
        ENDDO
        DEALLOCATE(A,ER,EI,VR,VL,WK)
endif
       ENDDO
!-------------------------------
!endif
      DEALLOCATE(CFHALFA,ADDRSSA,NORDERA)
      DEALLOCATE(CFHALFB,ADDRSSB,NORDERB)
      NALL_CHECK=NALL_CHECK+NCFA*NCFB
     ENDDO
    ENDDO
    CALL CPU_TIME(ICPUE)
    WRITE(6,'(A,I3,A,F10.2)') 'ORDER:',IORDER,' CPU/SEC =',ICPUE-ICPUS
    CALL PFLUSH(6)
    CALL CPU_TIME(ICPUS)
   ENDDO
   NALL=NALL_CHECK

   ! ==============
   ! TARGETED ROOTS
   ! ==============
   ELSE 

   CALL CPU_TIME(ICPUS)
   WRITE(6,'(A)') 'GENERATING THE HCPT SUBMATRIX FOR TARGETED ROOTS'

   CALL THERMAL_GENERATE_CONFIGURATIONSA(NELEA_TARGET,MIN(NELEA_TARGET,IALL(0,0,0)-IVIRTCORE-NELEA_TARGET))
   CALL THERMAL_GENERATE_CONFIGURATIONSB(NELEB_TARGET,MIN(NELEB_TARGET,IALL(0,0,0)-IVIRTCORE-NELEB_TARGET))
   NALL=NCFA*NCFB

   DO JTARGET=1,IOPTN(59)
    J=ITARGETS(JTARGET)
    JDEGEN=0
    LIST=0
    DO I=1,NALL
     IF (DABS(E0(I)-E0(J)) < 1.0D-9) THEN
      JDEGEN=JDEGEN+1
      LIST(JDEGEN)=I
     ENDIF
    ENDDO
    IF (JDEGEN > MAXNDEGEN) CALL PABORT('TOO DEGENERATE')
    I=0
    DO IA=1,NCFA
     DO IB=1,NCFB
      I=I+1
      IF (I == J) THEN
       CBITSA=""
       DO K=1,IALL(0,0,0)-IVIRTCORE
        IF (BTEST(CFHALFA(IA),K-1)) THEN
         CBITSA="1"//CBITSA
        ELSE
         CBITSA="0"//CBITSA
        ENDIF
       ENDDO
       CBITSB=""
       DO K=1,IALL(0,0,0)-IVIRTCORE
        IF (BTEST(CFHALFB(IB),K-1)) THEN
         CBITSB="1"//CBITSB
        ELSE
         CBITSB="0"//CBITSB
        ENDIF
       ENDDO
       WRITE(6,'(/,A,I3,A,I7,A,A,A,A,A,F15.10,A,128I7:)') '*** TARGET',JTARGET,' STRINGS ',I,&
            ' (',TRIM(CBITSA),',',TRIM(CBITSB),')',E0(I),' DEGENERATE STATES = ',(LIST(K),K=1,JDEGEN)
      ENDIF
     ENDDO
    ENDDO

    WRITE(6,'(A,100A15:)') '-----',('---------------',J=1,JDEGEN)
    WRITE(6,'(A,100I15:)') 'ORDER',(LIST(J),J=1,JDEGEN)
    WRITE(6,'(A,100A15:)') '-----',('---------------',J=1,JDEGEN)
    DO IORDER=1,ORDER
     CALL EHC_GEN_SUB(IORDER,0,LIST,JDEGEN)
     EHCSUM=EHCSUM+EHC(:,:,IORDER)
     ALLOCATE(A(JDEGEN,JDEGEN),ER(JDEGEN),EI(JDEGEN),VR(JDEGEN,JDEGEN),VL(1,JDEGEN),WK(4*JDEGEN))
     LCHECK=.FALSE.
     A=0.0D0
     DO J=1,JDEGEN
      DO L=1,JDEGEN
       A(L,J)=EHCSUM(LIST(L),LIST(J))
       IF ((L /= J).AND.(DABS(EHCSUM(LIST(L),LIST(J))) > 1.0D-9)) LCHECK=.TRUE.
      ENDDO
     ENDDO
!    IF (LCHECK) THEN
!     WRITE(6,'(A,I2,A,100I5)') 'COUPLED',JDEGEN,'-FOLD DEGENERATE:',(LIST(J),J=1,JDEGEN)
!    ELSE
!     WRITE(6,'(A,I2,A,100I5)') 'UNCOUPLED',JDEGEN,'-FOLD DEGENERATE:',(LIST(J),J=1,JDEGEN)
!    ENDIF
!    WRITE(6,'(A,I3,A)') 'ORDER:',IORDER,' ACCUMULATED HIRSCHFELDER-CERTAIN ENERGY MATRIX'
! *** NOTE: Diagonalization of incremental (e.g., second-order) H-C energy matrix gives
!           correct eigenvalues, but the order of states is scrambled. Summing over eigenvalues
!           in the order of their sizes will be incorrect. The same eigenvector for a higher
!           perturbation order diagonalizes all lower-order H-C energy matrices.
!    CALL DUMP5(A,JDEGEN)
     CALL DGEEV('N','V',JDEGEN,A,JDEGEN,ER,EI,VL,1,VR,JDEGEN,WK,4*JDEGEN,INFO)
     IF (INFO /= 0) CALL PABORT('DGEEV FAILED TO DIAGONALIZE A MATRIX')
     CALL PIKSRT2(JDEGEN,JDEGEN,ER,EI,VR,WK)
     CALL CPU_TIME(ICPUE)
     WRITE(*,'(I5,100F15.10:)') IORDER,(ER(J),J=1,JDEGEN)
!    DO J=1,JDEGEN
!     WRITE(*,'(I5,2F20.10,A)') J,ER(J),EI(J),'i'
!     WRITE(*,'(I5,F20.10,128F10.4:)') J,ER(J),(VR(L,J),L=1,K)
!    ENDDO
     DEALLOCATE(A,ER,EI,VR,VL,WK)
!    WRITE(6,'(A,I3,A,F10.2)') 'ORDER:',IORDER,' CPU/SEC =',ICPUE-ICPUS
     CALL PFLUSH(6)
     CALL CPU_TIME(ICPUS)
    ENDDO
    WRITE(6,'(A,100A15:)') '-----',('---------------',J=1,JDEGEN)

   ENDDO

   DEALLOCATE(CFHALFA,ADDRSSA,NORDERA)
   DEALLOCATE(CFHALFB,ADDRSSB,NORDERB)

   ENDIF

!! -----------------------------------------------------------------
!! OBSOLETE FROM HERE ...
!! DIAGONALIZATION AGAIN, BUT THIS TIME USING WIDER DEGENERATE BASIS
!! **** NOT CORRECT IF ITARGET /= 0
!! -----------------------------------------------------------------
!if (itarget==-1) then
!if (itarget==0) then
!   EHCSUM=EHC(:,:,0)
!   DO IORDER=1,ORDER
!    EHCSUM=EHCSUM+EHC(:,:,IORDER)
!    DO I=1,NALL
!!------------------------------- DIAGONALIZATION
!     K=0
!     LIST=0
!     DO J=1,NALL
!      IF (DABS(EHC(J,J,0)-EHC(I,I,0)) < 1.0D-9) THEN
!       K=K+1
!       LIST(K)=J
!      ENDIF
!     ENDDO
!     IF (K > MAXNDEGEN) CALL PABORT('ERROR')
!     WRITE(*,'(A,I5,X,I2,A,100I5)') '***** STATE ',I,K,'-FOLD DEGENERATE:',(LIST(J),J=1,K)
!     ALLOCATE(A(K,K),ER(K),EI(K),VR(K,K),VL(1,K),WK(4*K))
!     A=0.0D0
!     DO J=1,K
!      DO L=1,K
!       A(L,J)=EHCSUM(LIST(L),LIST(J))
!      ENDDO
!     ENDDO
!     WRITE(6,'(A,I3,A)') 'ORDER:',IORDER,' ACCUMULATED HIRSCHFELDER-CERTAIN ENERGY MATRIX'
!     CALL DUMP5(A,K)
!     CALL DGEEV('N','V',K,A,K,ER,EI,VL,1,VR,K,WK,4*K,INFO)
!     IF (INFO /= 0) CALL PABORT('DGEEV FAILED TO DIAGONALIZE A MATRIX')
!     CALL PIKSRT2(K,K,ER,EI,VR,WK)
!     DO J=1,K
!      WRITE(*,'(I5,F20.10)') J,ER(J)
!     ENDDO
!     DEALLOCATE(A,ER,EI,VR,VL,WK)
!!------------------------------- TO HERE, OBSOLETE
!    ENDDO
!   ENDDO
!endif

   IF (.NOT.LALL) DEALLOCATE(ITARGETS)
   DEALLOCATE(EHC,VHC,EHCSUM)
   DEALLOCATE(ALL_M,E0,ALLE,ALLN)
   DEALLOCATE(H,G)

   RETURN
END SUBROUTINE



SUBROUTINE DEGENERATE_CC(ORDER)
! DEGENERATE CC, A SPECIAL CASE OF SUMRCC BY LI & PALDUS

   USE CONSTANTS
   USE CONTROL
   USE STRUCTURE
   USE INTEGRAL
   USE BASISSET
   USE GRADIENT
   USE THR_FULLCI

   IMPLICIT NONE
!integer,parameter :: itarget=0    ! debug mode turned off
!integer,parameter :: itarget=4033 ! ground state , nondegenerate
!integer,parameter :: itarget=4036 ! excited state, 2-fold degenerate
!integer,parameter :: itarget=4018 ! excited state, 2-fold degenerate uncoupled
!integer,parameter :: itarget=4021 ! excited state, 1-fold degenerate
!integer,parameter :: itarget=3818 ! ionized state, 2-fold degenerate uncoupled
!integer,parameter :: itarget=2610 ! ionized state, 5-fold degenerate
!integer,parameter :: itarget=3438 ! 4-alpha,4-beta,2-fold,coupled x 2
!integer,parameter :: itarget=3440 ! 2-fold, coupled, divergent off the bat!
!integer,parameter :: itarget=4034 ! excited state, 4-fold
   LOGICAL :: LALL
   LOGICAL :: LGUESS
   LOGICAL :: LIPALDUS
   INTEGER :: NTARGETS,MTARGETS
   INTEGER,ALLOCATABLE :: ITARGETS(:)
   INTEGER :: JTARGET,KTARGET
   INTEGER :: NELEA_TARGET,NELEB_TARGET
   INTEGER :: NDEGEN
   INTEGER,PARAMETER :: MAXNDEGEN=99
   INTEGER :: REFA(MAXNDEGEN),REFB(MAXNDEGEN)
   INTEGER :: ORDER
   INTEGER :: I,J,K,L
   INTEGER :: ISTATE,JSTATE
   INTEGER :: IA,IB
   REAL :: ICPUS,ICPUE
   DOUBLE PRECISION,ALLOCATABLE :: E0(:)
   DOUBLE PRECISION,ALLOCATABLE :: FACTORIAL(:)
   DOUBLE PRECISION,ALLOCATABLE :: ALLE_LAMBDA(:,:)
   DOUBLE PRECISION,ALLOCATABLE :: A(:,:),ER(:),EI(:),VR(:,:),VL(:,:),WK(:)
   DOUBLE PRECISION :: PREVIOUSMIN,CURRENTMIN
   INTEGER :: INFO
   INTEGER :: LIST(MAXNDEGEN)
   CHARACTER(40) :: CBITSA,CBITSB
   LOGICAL :: LDONE
   LOGICAL :: LEXIST

   WRITE(6,'(/,A)') '*******************************'
   WRITE(6,'(A)')   '* GENERAL-ORDER DEGENERATE CC *'
   WRITE(6,'(A)')   '*******************************'

   IF (ORDER==0) RETURN
   IF ((KVCX /= 0).OR.(KVCY /= 0).OR.(KVCZ /= 0)) CALL PABORT('FOR MOLECULES ONLY')
   IF (LOPTN(25)) CALL PABORT('USE NON-DIRECT ALGORITHM')
   IF (IALL(0,0,0)-IOCC-IVIRTCORE <= 0) CALL PABORT('NO VIRTUAL ORBITAL')

   LGUESS=LOPTN(111)
   LIPALDUS=LOPTN(112)

   WRITE(6,'(A,I0)')      'ORDER     = ',ORDER
!if (itarget /= 0) write(*,*) 'debug mode ******************** for state ',itarget
   CALL CPU_TIME(ICPUS)

   IF (IOPTN(59) <= 0) THEN
    WRITE(6,'(A)') 'ALL ROOTS ARE SOUGHT'
    WRITE(6,'(A,I10)') 'TOTAL NUMBER OF ROOTS = ',2**(2*(IALLMAX-IVIRTCORE-ICORE))
    LALL=.TRUE.
 nelea_target=3
 neleb_target=3
!   LGUESS=.FALSE.
!   IF (IALL(0,0,0)-IOCC-IVIRTCORE > 15) CALL PABORT('INTEGER*4 ARGUMENT OVERFLOW')
   ELSE IF (LOPTN(60)) THEN
    NELEA_TARGET=IOCC-1
    NELEB_TARGET=IOCC
    WRITE(6,'(A)') 'IP ROOTS ARE SOUGHT'
    WRITE(6,'(A,2I3)') 'NELEA,NELEB = ',NELEA_TARGET,NELEB_TARGET
    WRITE(6,'(A,I3)') 'NUMBER OF ROOTS = ',IOPTN(59)
    LALL=.FALSE.
   ELSE IF (LOPTN(61)) THEN
    NELEA_TARGET=IOCC+1
    NELEB_TARGET=IOCC
    WRITE(6,'(A)') 'EA ROOTS ARE SOUGHT'
    WRITE(6,'(A,2I3)') 'NELEA,NELEB = ',NELEA_TARGET,NELEB_TARGET
    WRITE(6,'(A,I3)') 'NUMBER OF ROOTS = ',IOPTN(59)
    LALL=.FALSE.
   ELSE
    NELEA_TARGET=IOCC
    NELEB_TARGET=IOCC
    WRITE(6,'(A)') 'EXCITED ROOTS ARE SOUGHT'
    WRITE(6,'(A,2I3)') 'NELEA,NELEB = ',NELEA_TARGET,NELEB_TARGET
    WRITE(6,'(A,I3)') 'NUMBER OF ROOTS = ',IOPTN(59)
    LALL=.FALSE.
   ENDIF
   IF (LIPALDUS) THEN
    WRITE(6,'(/,A)') '/\/\/\/\/\/\/\/\/\/\/\/\'
    WRITE(6,'(A)')   'LI-PALDUS ANSATZ IS USED'
    WRITE(6,'(A)')   '\/\/\/\/\/\/\/\/\/\/\/\/'
   ENDIF

   ALLOCATE(H(IALLMAX-IVIRTCORE,IALLMAX-IVIRTCORE))
   ALLOCATE(G(IALLMAX-IVIRTCORE,IALLMAX-IVIRTCORE,IALLMAX-IVIRTCORE,IALLMAX-IVIRTCORE))
   CALL THERMAL_ONE_ELECTRON_INTEGRALS
   CALL THERMAL_TWO_ELECTRON_INTEGRALS

!  IF (LALL) THEN
!   IF (IALL(0,0,0)-IOCC-IVIRTCORE > 15) THEN
!    WRITE(6,'(A)') 'INTEGER*4 ARGUMENT OVERFLOW'
!    WRITE(6,'(A)') 'SKIPPING DEGENERATE CC'
!    RETURN
!   ENDIF
!   NALL=2**(2*(IALL(0,0,0)-IVIRTCORE-ICORE))
!  ELSE
!   CALL THERMAL_GENERATE_CONFIGURATIONSA(NELEA_TARGET,MIN(NELEA_TARGET,IALL(0,0,0)-IVIRTCORE-NELEA_TARGET))
!   CALL THERMAL_GENERATE_CONFIGURATIONSB(NELEB_TARGET,MIN(NELEB_TARGET,IALL(0,0,0)-IVIRTCORE-NELEB_TARGET))
!   NALL=NCFA*NCFB
!   DEALLOCATE(CFHALFA,ADDRSSA,NORDERA)
!   DEALLOCATE(CFHALFB,ADDRSSB,NORDERB)
!  ENDIF

   ! ==================================================
   ! GENERATE DEGENERATE CC ENERGY AND OVERLAP MATRICES
   ! ==================================================
   ESHIFT=1.0D9
   DO NELE=2*ICORE,2*(IALL(0,0,0)-IVIRTCORE)
    DO NELEA=ICORE,NELE
     NELEB=NELE-NELEA
     IF ((.NOT.LALL).AND.((NELEA /= NELEA_TARGET).OR.(NELEB /= NELEB_TARGET))) CYCLE
 if ((lall).AND.((nelea /= nelea_target).OR.(neleb /= neleb_target))) CYCLE
     IF (NELEA > IALL(0,0,0)-IVIRTCORE) CYCLE
     IF (NELEB > IALL(0,0,0)-IVIRTCORE) CYCLE
     IF (NELEA < ICORE) CYCLE
     IF (NELEB < ICORE) CYCLE
     WRITE(6,'(/,A,2I3)') '-----------------------'
     WRITE(6,'(A,2I3)')   'No.ELECTRONS ARE ',NELEA,NELEB
     WRITE(6,'(A,2I3)')   '-----------------------'
     CALL THERMAL_GENERATE_CONFIGURATIONSA(NELEA,MIN(NELEA,IALL(0,0,0)-IVIRTCORE-NELEA))
     CALL THERMAL_GENERATE_CONFIGURATIONSB(NELEB,MIN(NELEB,IALL(0,0,0)-IVIRTCORE-NELEB))
     WRITE(6,'(A,I10)') 'DIMENSION OF E0 ARRAY = ',NCFA*NCFB
     !
     ! ZEROTH-ORDER ENERGIES UNSORTED
     !                       ^^^^^^^^
     ALLOCATE(E0(NCFA*NCFB),ALLE(NCFA*NCFB),ALLN(NCFA*NCFB),ALL_M(NCFA*NCFB))
     DO IA=1,NCFA
      DO IB=1,NCFB
       E0((IA-1)*NCFB+IB)=NUCLEAR_REPULSION
       DO I=1,IALL(0,0,0)-IVIRTCORE
        IF (BTEST(CFHALFA(IA),I-1)) &
         E0((IA-1)*NCFB+IB)=E0((IA-1)*NCFB+IB)+EPSILON(I,0,0,0)
        IF (BTEST(CFHALFB(IB),I-1)) &
         E0((IA-1)*NCFB+IB)=E0((IA-1)*NCFB+IB)+EPSILON(I,0,0,0)
       ENDDO
      ENDDO
     ENDDO
     DO I=1,NCFA*NCFB
      ALLN(I)=NELE
      IF (E0(I) < ESHIFT) ESHIFT=E0(I)
!     WRITE(6,'(I3,F20.10)') I,E0(I)
     ENDDO
     ! DETERMINE TOTAL NUMBER OF NONDEGENERATE REFS
     MTARGETS=0
     DO I=1,NCFA*NCFB
      LEXIST=.FALSE.
      IF (I > 1) THEN
       DO J=1,I-1
        IF (DABS(E0(J)-E0(I)) < 1.0D-9) LEXIST=.TRUE.
       ENDDO
      ENDIF
      IF (.NOT.LEXIST) MTARGETS=MTARGETS+1
     ENDDO
     WRITE(6,'(A,I5)') 'TOTAL NUMBER OF NONDEGENERATE REFS = ',MTARGETS
     IF (LALL) THEN
      NTARGETS=MTARGETS
     ELSE
      NTARGETS=MIN(IOPTN(59),MTARGETS)
     ENDIF
     IF (IOPTN(59) > NTARGETS) THEN
      WRITE(6,'(A,I5,A,I5)') 'NUMBER OF TARGETS REDUCED FROM ',IOPTN(59),' TO ',NTARGETS
     ELSE
      WRITE(6,'(A,I5)') 'NUMBER OF TARGETS = ',NTARGETS
     ENDIF
     !
     ! POPULATE TARGET STATES
     ! 
     ALLOCATE(ITARGETS(NTARGETS))
     PREVIOUSMIN=-1.0D99
     DO I=1,NTARGETS
      CURRENTMIN=1.0D99
      DO J=1,NCFA*NCFB
       IF ((E0(J) < CURRENTMIN).AND.(DABS(E0(J)-CURRENTMIN) > 1.0D-9).AND.(E0(J)-PREVIOUSMIN > 1.0D-9)) THEN
        CURRENTMIN=E0(J)
        ITARGETS(I)=J
       ENDIF
      ENDDO
      PREVIOUSMIN=CURRENTMIN
     ENDDO
     DO I=1,NTARGETS
      K=0 
      DO J=1,NCFA*NCFB
       IF (DABS(E0(J)-E0(ITARGETS(I))) < 1.0D-9) K=K+1
      ENDDO 
      WRITE(6,'(A,I3,A,I10,A,F15.10,I5,A)') 'TARGET',I,' = STATE',ITARGETS(I),' ZEROTH-ORDER ENERGY = ',E0(ITARGETS(I)),&
                                             K,'-FOLD DEGENERATE'
     ENDDO
     !
     DO I=1,NCFA
      DO J=1,NCFB
       ISTATE=(I-1)*NCFB+J
       JTARGET=0
       DO K=1,NTARGETS
        IF (ITARGETS(K)==ISTATE) THEN
         KTARGET=K
         JTARGET=ISTATE
        ENDIF
       ENDDO
       IF (JTARGET==0) CYCLE
!if ((itarget /= 0).and.(istate /= itarget)) cycle
!if (ktarget /= 25) cycle
       WRITE(6,'(/,A,I5,A,I5)') '***** TARGET ',KTARGET,' = STATE ',ISTATE
       CBITSA=""
       CBITSB=""
       DO K=1,IALL(0,0,0)-IVIRTCORE
        IF (BTEST(CFHALFA(I),K-1)) THEN
         CBITSA="1"//CBITSA
        ELSE
         CBITSA="0"//CBITSA
        ENDIF
        IF (BTEST(CFHALFB(J),K-1)) THEN
         CBITSB="1"//CBITSB
        ELSE
         CBITSB="0"//CBITSB
        ENDIF
       ENDDO
       WRITE(6,'(A,2(I3,A,A,A))') 'REFERENCE IS   ',I,' (',TRIM(CBITSA),')',J,' (',TRIM(CBITSB),')'
       REFA(1)=I
       REFB(1)=J
       NDEGEN=0
       LDONE=.FALSE.
       DO K=1,NCFA
        DO L=1,NCFB
         JSTATE=(K-1)*NCFB+L
         IF (DABS(E0(ISTATE)-E0(JSTATE)) < 1.0D-9) THEN
          IF (JSTATE < ISTATE) THEN
           NDEGEN=0
           LDONE=.TRUE.
          ELSE
           NDEGEN=NDEGEN+1
           IF (NDEGEN > MAXNDEGEN) CALL PABORT('ERROR')
           REFA(NDEGEN)=K
           REFB(NDEGEN)=L
          ENDIF
         ENDIF
        ENDDO
       ENDDO
       IF (LDONE) THEN
        WRITE(6,'(A)') '... ALREADY DONE'
        EXIT
       ELSE
        CALL DCC_GEN(ORDER,KTARGET,REFA,REFB,NDEGEN,LGUESS,LIPALDUS)
       ENDIF
      ENDDO
     ENDDO
     DEALLOCATE(CFHALFA,ADDRSSA,NORDERA)
     DEALLOCATE(CFHALFB,ADDRSSB,NORDERB)
     DEALLOCATE(ITARGETS)
     DEALLOCATE(ALL_M,E0,ALLE,ALLN)
    ENDDO
    CALL CPU_TIME(ICPUE)
    IF (LALL) WRITE(6,'(A,I3,A,F10.2)') 'No.ELECTRONS',NELE,' CPU/SEC =',ICPUE-ICPUS
    CALL PFLUSH(6)
    CALL CPU_TIME(ICPUS)
   ENDDO

   DEALLOCATE(H,G)

   RETURN
END SUBROUTINE



SUBROUTINE DCC_GEN(ORDER,KTARGET,ICFA,ICFB,NDEGEN,LGUESS,LIPALDUS)
! PERFORM A DEGENERATE COUPLED-CLUSTER CALCULATION 
     
   USE CONTROL 
   USE GRADIENT
   USE STRUCTURE
   USE INTEGRAL
   USE BASISSET
   USE THR_FULLCI
    
   IMPLICIT NONE
   INTEGER :: KTARGET
   LOGICAL :: LGUESS
   LOGICAL :: LIPALDUS
   INTEGER :: NDEGEN
   INTEGER,PARAMETER :: MAXNDEGEN=99 ! MUST BE SAME AS DEGENERATE_CC
   INTEGER :: ICFA(MAXNDEGEN),ICFB(MAXNDEGEN)
   INTEGER,PARAMETER :: MAXITER=1000
   INTEGER :: ITER,IORDER
   INTEGER :: ORDER,IPOWER
   INTEGER :: IA,IB,IC,ID
   INTEGER :: I,J,K,L,M,N
   INTEGER :: HOLEA(ORDER),HOLEB(ORDER),PARTA(ORDER),PARTB(ORDER)
   INTEGER :: KSIGN(0:2*IALL(0,0,0)),ISIGN,JSIGN
   INTEGER(4) :: CFALPH,CFBETA
   INTEGER :: EOF
   INTEGER :: NHOLES, NACTIVEHOLES
   INTEGER :: NPARTICLES, NACTIVEPARTICLES 
   REAL :: MEM,ICPUS,ICPUE
   DOUBLE PRECISION,ALLOCATABLE :: VEC1(:,:),VEC2(:,:),VEC3(:,:)
   DOUBLE PRECISION :: HA,HB,MAXDEV
   DOUBLE PRECISION,ALLOCATABLE :: CCE(:,:),CCS(:,:),ER(:),EI(:),VR(:,:),VL(:,:),WK(:)
   DOUBLE PRECISION,ALLOCATABLE :: DEVSQ1(:),DEVSQ2(:)
   DOUBLE PRECISION,ALLOCATABLE :: CCE_PRINT(:,:)
   INTEGER :: INFO
   CHARACTER(30) :: CBITSA,CBITSB
   CHARACTER(3)  :: APPEND
   CHARACTER(15) :: FULLAPPEND
   INTEGER,ALLOCATABLE :: REFOCCA(:,:),REFOCCB(:,:)
   INTEGER,ALLOCATABLE :: REFVIRA(:,:),REFVIRB(:,:)
   INTEGER :: IOCCA,IVIRA,NORDA
   INTEGER :: IOCCB,IVIRB,NORDB
   INTEGER,ALLOCATABLE :: CCO(:,:)
   LOGICAL :: LOCC
   DOUBLE PRECISION :: SUM1,SUM2
   DOUBLE PRECISION,ALLOCATABLE :: B(:,:),BS(:,:),C(:),CS(:)
   DOUBLE PRECISION :: D
   INTEGER,ALLOCATABLE :: INDX(:)
   INTEGER :: MAXORDER
   LOGICAL :: LEXIST

   CALL CPU_TIME(ICPUS)
   MAXORDER=MIN(2*(IALL(0,0,0)-IVIRTCORE)-NELEA-NELEB,NELEA+NELEB)
   WRITE(6,'(A)') 'A DEGENERATE COUPLED-CLUSTER CALCULATION WILL BE PERFORMED'
   WRITE(6,'(A,I2,A,I2,A)') 'CC ORDER IS ',ORDER,'(MAX EXCITATION ORDER IS ',MAXORDER,')'
   WRITE(6,'(A)') 'H EXP(T) ALGORITHM WILL BE USED'
   IF (IOPTN(54) > 0) WRITE(6,'(A,I3,A)') 'DIIS EXTRAPOLATION WILL BE PERFORMED ONCE IN',IOPTN(54),' ITERATIONS'
!  WRITE(6,'(A,2I3)') 'No.ELECTRONS ARE ',NELEA,NELEB
   WRITE(6,'(A,I3)') 'DEGREE OF DEGENERACY IS ',NDEGEN

   DO N=1,NDEGEN
    CBITSA=""
    CBITSB=""
    DO K=1,IALL(0,0,0)-IVIRTCORE
     IF (BTEST(CFHALFA(ICFA(N)),K-1)) THEN
      CBITSA="1"//CBITSA
     ELSE
      CBITSA="0"//CBITSA
     ENDIF
     IF (BTEST(CFHALFB(ICFB(N)),K-1)) THEN
      CBITSB="1"//CBITSB
     ELSE
      CBITSB="0"//CBITSB
     ENDIF
    ENDDO
    J=(ICFA(N)-1)*NCFB+ICFB(N)
    WRITE(6,'(I3,A,I5,A,2(I3,A,A,A))') N,'-TH DEGENERATE REF ',J,':',ICFA(N),' (',TRIM(CBITSA),')',ICFB(N),' (',TRIM(CBITSB),')'
   ENDDO

   ! DETERMINE OCCUPIED AND VIRTUAL ORBITALS IN REFS
   ALLOCATE(CCO(NDEGEN,NDEGEN))
   ALLOCATE(REFOCCA(IALL(0,0,0),NDEGEN),REFOCCB(IALL(0,0,0),NDEGEN))
   ALLOCATE(REFVIRA(IALL(0,0,0),NDEGEN),REFVIRB(IALL(0,0,0),NDEGEN))
   REFOCCA=0
   REFVIRA=0
   REFOCCB=0
   REFVIRB=0
   DO N=1,NDEGEN
    IOCCA=0
    IOCCB=0
    IVIRA=0
    IVIRB=0
    DO I=1,IALL(0,0,0)-IVIRTCORE
     IF (BTEST(CFHALFA(ICFA(N)),I-1)) THEN
      IOCCA=IOCCA+1
      REFOCCA(IOCCA,N)=I
     ELSE
      IVIRA=IVIRA+1
      REFVIRA(IVIRA,N)=I
     ENDIF
     IF (BTEST(CFHALFB(ICFB(N)),I-1)) THEN
      IOCCB=IOCCB+1
      REFOCCB(IOCCB,N)=I
     ELSE
      IVIRB=IVIRB+1
      REFVIRB(IVIRB,N)=I
     ENDIF
    ENDDO
    IF (IOCCA /= NELEA) CALL PABORT('ERROR 411')
    IF (IOCCB /= NELEB) CALL PABORT('ERROR 412')
    IF (IVIRA /= IALL(0,0,0)-IVIRTCORE-NELEA) CALL PABORT('ERROR 511')
    IF (IVIRB /= IALL(0,0,0)-IVIRTCORE-NELEB) CALL PABORT('ERROR 512')
   ENDDO
   DO N=1,NDEGEN
    DO M=1,NDEGEN
     NORDA=0
     DO I=1,IOCCA
      LOCC=.FALSE.
      DO J=1,IOCCA
       IF (REFOCCA(J,M)==REFOCCA(I,N)) LOCC=.TRUE.
      ENDDO
      IF (.NOT.LOCC) NORDA=NORDA+1
     ENDDO
     NORDB=0
     DO I=1,IOCCB
      LOCC=.FALSE.
      DO J=1,IOCCB
       IF (REFOCCB(J,M)==REFOCCB(I,N)) LOCC=.TRUE.
      ENDDO
      IF (.NOT.LOCC) NORDB=NORDB+1
     ENDDO
     CCO(M,N)=NORDA+NORDB
    ENDDO
   ENDDO
   WRITE(6,'(A)') 'EXCITATION ORDER MATRIX'
   CALL DUMP17(CCO,NDEGEN)   

   ALLOCATE(CCE(NDEGEN,NDEGEN),CCS(NDEGEN,NDEGEN),ER(NDEGEN),EI(NDEGEN),VR(NDEGEN,NDEGEN),VL(1,NDEGEN),WK(4*NDEGEN))
   ALLOCATE(CCE_PRINT(NDEGEN,NDEGEN),DEVSQ1(NDEGEN),DEVSQ2(NDEGEN))
   ALLOCATE(INDX(NDEGEN),B(NDEGEN,NDEGEN),BS(NDEGEN,NDEGEN),C(NDEGEN),CS(NDEGEN))
     
   ALLOCATE(VEC1(NCFB,NCFA),VEC2(NCFB,NCFA),VEC3(NCFB,NCFA))
   DO N=1,NDEGEN
    WRITE(APPEND,'(I3)') N
    WRITE(FULLAPPEND,'(I2.2,A,I2.2,A,I5.5,A,I3.3)') NELEA,'.',NELEB,'.',KTARGET,'.',N
    OPEN(100+N,FILE=TRIM(COPTN(1))//'.T.'//FULLAPPEND,FORM='UNFORMATTED')
    OPEN(200+N,FILE=TRIM(COPTN(1))//'.expT.'//APPEND,FORM='UNFORMATTED')
    OPEN(300+N,FILE=TRIM(COPTN(1))//'.HexpT.'//APPEND,FORM='UNFORMATTED')
    OPEN(400+N,FILE=TRIM(COPTN(1))//'.delta.'//APPEND,FORM='UNFORMATTED')
    OPEN(900+N,FILE=TRIM(COPTN(1))//'.expTexact.'//APPEND,FORM='UNFORMATTED')
   ENDDO
   OPEN(90,FILE=TRIM(COPTN(1))//'.tmp1',FORM='UNFORMATTED')
   OPEN(91,FILE=TRIM(COPTN(1))//'.tmp2',FORM='UNFORMATTED')
   OPEN(92,FILE=TRIM(COPTN(1))//'.tmp3',FORM='UNFORMATTED')

   ! SIGNS ASSOCIATED WITH THE PERMUTATION OF THE CLUSTER OPERATORS
   DO I=0,2*IALL(0,0,0)
    KSIGN(I)=(-1)**((I*(I-1))/2)
   ENDDO

   ! COUPLED-CLUSTER ITERATION
   ! FILE 100: COUPLED-CLUSTER T AMPLITUDES
   ! FILE 200: COUPLED-CLUSTER WAVE FUNCTION EXP(T)|0>
   ! FILE 300: H EXP(T)|0>

   ! INITIAL GUESS OF T AMPLITUDES
   DO N=1,NDEGEN
    IF (LGUESS.AND.(MAXORDER > 0)) THEN
!    CALL CLEAN(ICFA(N),ICFB(N),100+N,ORDER)
     WRITE(FULLAPPEND,'(I2.2,A,I2.2,A,I5.5,A,I3.3)') NELEA,'.',NELEB,'.',KTARGET,'.',N
     WRITE(6,'(A,A)') 'READING INITIAL T-AMPLITUDES FROM FILE ',TRIM(COPTN(1))//'.T.'//FULLAPPEND
     REWIND(100+N)
     READ(100+N,IOSTAT=EOF) VEC1
     IF (EOF /= 0) THEN
      WRITE(6,'(A,A)') 'READING FAILED','; ZERO INITIAL T-AMPLITUDES'
      VEC1=0.0D0
      REWIND(100+N)
      WRITE(100+N) VEC1
     ENDIF 
    ELSE
     VEC1=0.0D0
     WRITE(6,'(A)') 'ZERO INITIAL T-AMPLITUDES'
     REWIND(100+N)
     WRITE(100+N) VEC1
    ENDIF
   ENDDO

   WRITE(6,'(A)') '-----------------------------------------------------------------------------------------------'
   WRITE(6,'(A)') 'ITR    DEV(INTRNL)    DEV(EXTRNL)    CORRELATION               TOTAL ENERGY           CPU / SEC'
   DO ITER=1,MAXITER
!  DO ITER=1,3

    ! FORM EXP(T)|0> AND H EXP(T)|0>
    DO N=1,NDEGEN

     ! REFERENCE STATE
     VEC2=0.0D0
     VEC2(ICFB(N),ICFA(N))=1.0D0
     REWIND(90)
     WRITE(90) VEC2
!write(*,*) '*** initial |icfa,icfb> ',n
!do ia=1,ncfa
!do ib=1,ncfb
!write(*,'(2i3,f20.10)') ia,ib,vec2(ib,ia)
!enddo
!enddo

     ! T AMPLITUDES
     REWIND(100+N)
     IF (ITER >= 2) THEN
      DO I=1,ITER-1
       READ(100+N) VEC2
      ENDDO
     ENDIF
     READ(100+N) VEC2
     REWIND(91) 
     WRITE(91) VEC2

!rewind(100+n)
!read(100+n) vec2
!write(*,*) '*** T |icfa,icfb> ',n
!do ia=1,ncfa
!do ib=1,ncfb
!write(*,'(2i3,f20.10)') ia,ib,vec2(ib,ia)
!enddo
!enddo

     CALL THERMAL_EXPONENTIAL_OPERATOR(ICFA(N),ICFB(N),91,90,200+N,ORDER,.FALSE.,.FALSE.)
!rewind(200+n)
!read(200+n) vec2
!rewind(900+n)
!read(900+n) vec3
!write(*,*) '*** exp(T)|icfa,icfb>, exact exp(T)|icfa,icfb> ',n
!do ia=1,ncfa
!do ib=1,ncfb
!write(*,'(2i3,2f20.10)') ia,ib,vec2(ib,ia),vec3(ib,ia)
!enddo
!enddo
     CALL THERMAL_HAMILTONIAN_PRODUCT(200+N,300+N,0,1.0D0)
!rewind(300+n)
!read(300+n) vec2
!write(*,*) '*** H exp(T)|icfa,icfb> ',n
!do ia=1,ncfa
!do ib=1,ncfb
!write(*,'(2i3,f20.10)') ia,ib,vec2(ib,ia)
!enddo
!enddo

    ENDDO

    ! FORM <0|H EXP(T)|0> AND <0|EXP(T)|0> MATRICES
    CCS=0.0D0
    CCE=0.0D0

    DO N=1,NDEGEN
     DO M=1,NDEGEN

      REWIND(300+N)
      READ(300+N) VEC1
      CCE(M,N)=VEC1(ICFB(M),ICFA(M))

      REWIND(200+N)
      READ(200+N) VEC1
      CCS(M,N)=VEC1(ICFB(M),ICFA(M))

      ! EXCITATION RANK RESTRICTIONS
      IF ((.NOT.LIPALDUS).AND.(CCO(M,N) > ORDER)) THEN
       CCE(M,N)=0.0D0
       CCS(M,N)=0.0D0
!      WRITE(6,'(A)') '**** WARNING: DEGENERATE-SPACE ENERGY/OVERLAP MATRIX BEYOND T EXCITATION RANK IS ERASED'
      ELSE IF (LIPALDUS.AND.(CCO(M,N) > ORDER)) THEN
       WRITE(6,'(A)') '**** WARNING: DEGENERATE-SPACE ENERGY/OVERLAP MATRIX BEYOND T EXCITATION RANK IS CONSIDERED (LI-PALDUS)'
      ENDIF

     ENDDO
    ENDDO

    IF (IOPTN(9) > 1) THEN
!   IF (LIPALDUS) THEN
     WRITE(6,'(A)') 'OVERLAP MATRIX'
     CALL DUMP5LONG(CCS,NDEGEN)
     CCE_PRINT=CCE
     DO M=1,NDEGEN
      CCE_PRINT(M,M)=CCE_PRINT(M,M)+NUCLEAR_REPULSION
     ENDDO
     WRITE(6,'(A)') 'HAMILTONIAN MATRIX'
     CALL DUMP5LONG(CCE_PRINT,NDEGEN)
    ENDIF

!-------------------------------------
!   ! SYMMETRIZE CCS AND CCE
!   DO N=1,NDEGEN
!    DO M=1,NDEGEN
!     CCE_PRINT(M,N)=(CCS(M,N)+CCS(N,M))/2.0D0
!    ENDDO
!   ENDDO
!   CCS=CCE_PRINT
!   DO N=1,NDEGEN
!    DO M=1,NDEGEN
!     CCE_PRINT(M,N)=(CCE(M,N)+CCE(N,M))/2.0D0
!    ENDDO
!   ENDDO
!   CCE=CCE_PRINT

!   WRITE(6,'(A)') 'OVERLAP MATRIX (SYMMETRIZED)'
!   CALL DUMP5(CCS,NDEGEN)
!   CCE_PRINT=CCE
!   DO M=1,NDEGEN
!    CCE_PRINT(M,M)=CCE_PRINT(M,M)+NUCLEAR_REPULSION
!   ENDDO
!   WRITE(6,'(A)') 'HAMILTONIAN MATRIX (SYMMETRIZED)'
!   CALL DUMP5(CCE_PRINT,NDEGEN)
!-------------------------------------

    ! MULTIPLY CCS INVERSE WITH CCE
    B=CCS
    BS=B
    DO N=1,NDEGEN
     C=CCE(:,N)
     CS=C
     CALL LUDCMP(B,NDEGEN,NDEGEN,INDX,D)
     CALL LUBKSB(B,NDEGEN,NDEGEN,INDX,C)
     CALL MPROVE(BS,B,NDEGEN,NDEGEN,INDX,CS,C)
     CCE(:,N)=C
    ENDDO

    CCE_PRINT=CCE
    DO M=1,NDEGEN
!    CCE_PRINT(M,M)=CCE_PRINT(M,M)+NUCLEAR_REPULSION-EHFKS
     CCE_PRINT(M,M)=CCE_PRINT(M,M)+NUCLEAR_REPULSION
    ENDDO
!   WRITE(6,'(A)') 'ENERGY MATRIX'
!   CALL DUMP5(CCE_PRINT,NDEGEN)

    ! UPDATE T AMPLITUDES
    CALL THERMAL_T_UPDATE(ITER,NDEGEN,ICFA,ICFB,100,200,300,400,ORDER,CCE,CCS,DEVSQ1,DEVSQ2,REFOCCA,REFOCCB,REFVIRA,REFVIRB,&
                          LIPALDUS)

    ! DIAGONALIZE EFFECTIVE ENERGY MATRIX
    CALL DGEEV('N','V',NDEGEN,CCE,NDEGEN,ER,EI,VL,1,VR,NDEGEN,WK,4*NDEGEN,INFO)
    IF (INFO /= 0) THEN
     WRITE(6,'(A)') '***** WARNING : COUPLED-CLUSTER ITERATION FAILED TO CONVERGE (DGEEV FAILED TO DIAGONALIZE A MATRIX)'
     EXIT
    ENDIF
    CALL PIKSRT2(NDEGEN,NDEGEN,ER,EI,VR,WK)
    LEXIST=.FALSE.
    DO N=1,NDEGEN
     IF (DABS(EI(N)) > 1.0D-9) THEN
!     WRITE(6,'(I3,2F20.10,A)') N,ER(N)+NUCLEAR_REPULSION,EI(N),'i COMPLEX-VALUED ENERGY DETECTED!'
      LEXIST=.TRUE.
     ELSE
!     WRITE(6,'(I3,2F20.10,A)') N,ER(N)+NUCLEAR_REPULSION,EI(N),'i'
     ENDIF
    ENDDO
    SUM1=0.0D0
    SUM2=0.0D0
    DO M=1,NDEGEN
     SUM1=SUM1+CCE(M,M)
     SUM2=SUM2+ER(M)
    ENDDO
!   WRITE(6,'(A,3F20.10)') 'TRACE, SUM EIGENVALUES, DIFFERENCE ',SUM1,SUM2,DABS(SUM1-SUM2) 

    CALL CPU_TIME(ICPUE)
    DO N=1,NDEGEN
     IF (N==1) THEN
      WRITE(6,'(I3,2F15.10,F15.10,F20.10,A,F13.10,A,F11.1)') &
       ITER,DSQRT(DEVSQ1(N)),DSQRT(DEVSQ2(N)),ER(N)+NUCLEAR_REPULSION-EHFKS,ER(N)+NUCLEAR_REPULSION,' +',EI(N),'i',ICPUE-ICPUS
     ELSE
      WRITE(6,'(3X,2F15.10,F15.10,F20.10,A,F13.10,A,12X)') &
       DSQRT(DEVSQ1(N)),DSQRT(DEVSQ2(N)),ER(N)+NUCLEAR_REPULSION-EHFKS,ER(N)+NUCLEAR_REPULSION,' +',EI(N),'i'
     ENDIF
    ENDDO
    IF (LEXIST) THEN
     WRITE(6,'(A)') '***** WARNING : COUPLED-CLUSTER ITERATION FAILED TO CONVERGE (COMPLEX-VALUED ENERGY DETECTED)'
     EXIT
    ENDIF
    WRITE(6,'(A)') '...............................................................................................'
    CALL CPU_TIME(ICPUS)

!   WRITE(6,'(A,F20.10)') 'INTERNAL DEVIATION ',DSQRT(DEVSQ1)
!   WRITE(6,'(A,F20.10)') 'EXTERNAL DEVIATION ',DSQRT(DEVSQ2)
    MAXDEV=0.0D0
    DO N=1,NDEGEN
     MAXDEV=MAX(MAXDEV,DSQRT(DEVSQ1(N)))
     MAXDEV=MAX(MAXDEV,DSQRT(DEVSQ2(N)))
    ENDDO
!   IF (MAXDEV > 1.0D2) CALL PABORT('COUPLED-CLUSTER ITERATION FAILED TO CONVERGE')
    IF (MAXDEV > 1.0D2) THEN
     CALL WARNING('COUPLED-CLUSTER ITERATION FAILED TO CONVERGE (RESIDUAL TOO LARGE)')
     EXIT
    ENDIF
    IF (MAXDEV < DOPTN(62)) THEN
     IF (LIPALDUS) THEN
      WRITE(6,'(A)') '---------------------------------- STRING-BASED (LI-PALDUS) -----------------------------------'
     ELSE
      WRITE(6,'(A)') '---------------------------------------- STRING-BASED -----------------------------------------'
     ENDIF
     WRITE(6,'(A)') 'CONVERGENCE IS ACHIEVED'
     EXIT
    ENDIF

!   IF (ITER==MAXITER) CALL PABORT('COUPLED-CLUSTER ITERATION FAILED TO CONVERGE')
    IF (ITER==MAXITER) CALL WARNING('COUPLED-CLUSTER ITERATION FAILED TO CONVERGE (MAXITER REACHED)')
   ENDDO

   DEALLOCATE(INDX,B,BS,C,CS)
   DEALLOCATE(VEC1,VEC2,VEC3)
   DEALLOCATE(REFOCCA,REFOCCB,REFVIRA,REFVIRB)
   DEALLOCATE(CCO)
   DEALLOCATE(CCE,CCS,ER,EI,VR,VL,WK)
   DEALLOCATE(CCE_PRINT,DEVSQ1,DEVSQ2)
   DO N=1,NDEGEN
    CLOSE(100+N)
    CLOSE(200+N)
    CLOSE(300+N)
    CLOSE(400+N)
    CLOSE(900+N)
   ENDDO
   CLOSE(90)
   CLOSE(91)
   CLOSE(92)

   RETURN
END SUBROUTINE



SUBROUTINE THERMAL_EXPONENTIAL_OPERATOR(ICFA,ICFB,TFILE,INFILE,OUTFILE,ORDER,LMINUS,LDAGGER)
! OPERATE WITH AN EXPONENTIAL OPERATOR ON ANY GIVEN WAVEFUNCTION.  THE T-AMPLITUDES
! ARE STORED IN TFILE, THE WAVEFUNCTION ON WHICH THE EXPONENTIAL OPERATOR ACTS IS 
! IN INFILE, AND THE EXPONENTIAL WAVEFUNCTION IS IN OUTFILE.  IF LMINUS=.TRUE.
! THE OPERATOR IS EXP(-T), OTHERWISE, EXP(T).  IF LDAGGER=.TRUE., THE OPERATOR IS
! THE CONJUGATE COMPLEX OF EXP(T), OTHERWISE, JUST EXP(T).

   USE CONTROL
   USE GRADIENT
   USE STRUCTURE
   USE INTEGRAL
   USE BASISSET
   USE THR_FULLCI

   IMPLICIT NONE
   INTEGER :: ICFA,ICFB ! REFERENCE HALF CONFIGURATIONS
   LOGICAL :: LDAGGER
   LOGICAL :: LMINUS
   LOGICAL :: LCYCLE
   INTEGER :: TFILE,INFILE,OUTFILE
   INTEGER :: ORDER
   INTEGER :: I,J,IPOWER
   INTEGER :: IA,IB,IC,ID
   INTEGER :: REFOCCA(IALL(0,0,0)),REFOCCB(IALL(0,0,0)),IOCCA,IVIRA,NORDA
   INTEGER :: REFVIRA(IALL(0,0,0)),REFVIRB(IALL(0,0,0)),IOCCB,IVIRB,NORDB
   INTEGER :: HOLEA(ORDER),HOLEB(ORDER),PARTA(ORDER),PARTB(ORDER)
   INTEGER :: KSIGN(0:2*IALL(0,0,0)),ISIGN,JSIGN
   INTEGER(4) :: CFALPH,CFBETA
   DOUBLE PRECISION,ALLOCATABLE :: VEC1(:,:),VEC2(:,:),VEC3(:,:)
   INTEGER,ALLOCATABLE :: AD1(:),AD2(:),SN1(:),SN2(:)
   LOGICAL,ALLOCATABLE :: LC1(:),LC2(:)

   ALLOCATE(VEC1(NCFB,NCFA),VEC2(NCFB,NCFA),VEC3(NCFB,NCFA))
   ALLOCATE(AD1(NCFA),AD2(NCFB),SN1(NCFA),SN2(NCFB),LC1(NCFA),LC2(NCFB))

   ! SIGNS ASSOCIATED WITH THE PERMUTATION OF THE CLUSTER OPERATORS
   DO I=0,2*IALL(0,0,0)
    KSIGN(I)=(-1)**((I*(I-1))/2)
   ENDDO

   ! DETERMINE OCCUPIED AND VIRTUAL ORBITALS IN REF
!write(*,*) 'Reference state ',icfa,icfb
   REFOCCA=0
   REFVIRA=0
   IOCCA=0
   IVIRA=0
   REFOCCB=0
   REFVIRB=0
   IOCCB=0
   IVIRB=0
   DO I=1,IALL(0,0,0)-IVIRTCORE
    IF (BTEST(CFHALFA(ICFA),I-1)) THEN
     IOCCA=IOCCA+1
     REFOCCA(IOCCA)=I
    ELSE
     IVIRA=IVIRA+1
     REFVIRA(IVIRA)=I
    ENDIF
    IF (BTEST(CFHALFB(ICFB),I-1)) THEN
     IOCCB=IOCCB+1
     REFOCCB(IOCCB)=I
    ELSE
     IVIRB=IVIRB+1
     REFVIRB(IVIRB)=I
    ENDIF
   ENDDO
   IF (IOCCA /= NELEA) CALL PABORT('ERROR')
   IF (IOCCB /= NELEB) CALL PABORT('ERROR')
!write(*,*) 'occupied alpha = ',(REFOCCA(I),I=1,IOCCA)
!write(*,*) 'occupied beta  = ',(REFOCCB(I),I=1,IOCCB)
!write(*,*) 'virtual  alpha = ',(REFVIRA(I),I=1,IVIRA)
!write(*,*) 'virtual  beta  = ',(REFVIRB(I),I=1,IVIRB)
 
   ! RETRIEVE T-AMPLITUDES FROM FILE
   REWIND(TFILE)
   READ(TFILE) VEC1
   IF (LMINUS) VEC1=-VEC1
!write(*,*) 'T amplitude'
!do ia=1,ncfa
!do ib=1,ncfb
!write(*,*) 'ia,ib = ',ia,ib,' T = ',vec1(ib,ia)
!enddo
!enddo
   ! RETRIEVE INITIAL WAVEFUNCTION FROM FILE
   REWIND(INFILE)
   READ(INFILE) VEC2
!write(*,*) 'initial wave function'
!do ia=1,ncfa
!do ib=1,ncfb
!write(*,*) 'ia,ib = ',ia,ib,' |icfa,icfb> = ',vec2(ib,ia)
!enddo
!enddo
   ! INITIALIZE OUTFILE WITH THE INITIAL WAVEFUNCTION
   REWIND(OUTFILE)
   WRITE(OUTFILE) VEC2

   ! LOOP OVER THE POWER
   DO IPOWER=1,MIN(NELEA+NELEB-2*ICORE,2*IALL(0,0,0)-NELEA-NELEB-2*IVIRTCORE)
!do ipower=1,1
!write(*,*) 'ipower=',ipower,'/',MIN(NELEA+NELEB-2*ICORE,2*IALL(0,0,0)-NELEA-NELEB-2*IVIRTCORE)
    VEC3=0.0D0

    ! LOOP OVER ALPHA T-AMPLITUDE
    DO IA=1,NCFA
     J=0
     DO I=1,IOCCA
      IF (.NOT.BTEST(CFHALFA(IA),REFOCCA(I)-1)) THEN
       J=J+1
       HOLEA(J)=REFOCCA(I)
      ENDIF
     ENDDO
     NORDA=J
     J=0
     DO I=1,IVIRA
      IF (BTEST(CFHALFA(IA),REFVIRA(I)-1)) THEN
       J=J+1
       PARTA(J)=REFVIRA(I)
      ENDIF
     ENDDO
     IF (J /= NORDA) CALL PABORT('ERROR')
     IF (NORDA > ORDER) CYCLE

     ! LOOP OVER ALPHA CONFIGURATIONS
     DO IC=1,NCFA
      LCYCLE=.FALSE.
      CFALPH=CFHALFA(IC)
      IF (.NOT.LDAGGER) THEN
       DO I=1,NORDA
        IF (.NOT.BTEST(CFALPH,HOLEA(I)-1)) LCYCLE=.TRUE.
        IF (BTEST(CFALPH,PARTA(I)-1)) LCYCLE=.TRUE.
       ENDDO
      ELSE
       DO I=1,NORDA
        IF (BTEST(CFALPH,HOLEA(I)-1)) LCYCLE=.TRUE.
        IF (.NOT.BTEST(CFALPH,PARTA(I)-1)) LCYCLE=.TRUE.
       ENDDO
      ENDIF
      LC1(IC)=LCYCLE
      IF (LCYCLE) CYCLE
      ISIGN=1
      IF (.NOT.LDAGGER) THEN
       DO I=1,NORDA
        IF (HOLEA(I) /= 1) THEN
         DO J=1,HOLEA(I)-1
          IF (BTEST(CFALPH,J-1)) ISIGN=-ISIGN
         ENDDO
        ENDIF
        CFALPH=IBCLR(CFALPH,HOLEA(I)-1)
       ENDDO
       DO I=1,NORDA
        DO J=1,PARTA(I)-1
         IF (BTEST(CFALPH,J-1)) ISIGN=-ISIGN
        ENDDO
        CFALPH=IBSET(CFALPH,PARTA(I)-1)
       ENDDO
      ELSE
       DO I=NORDA,1,-1
        DO J=1,PARTA(I)-1
         IF (BTEST(CFALPH,J-1)) ISIGN=-ISIGN
        ENDDO
        CFALPH=IBCLR(CFALPH,PARTA(I)-1)
       ENDDO
       DO I=NORDA,1,-1
        IF (HOLEA(I) /= 1) THEN
         DO J=1,HOLEA(I)-1
          IF (BTEST(CFALPH,J-1)) ISIGN=-ISIGN
         ENDDO
        ENDIF
        CFALPH=IBSET(CFALPH,HOLEA(I)-1)
       ENDDO
      ENDIF
      AD1(IC)=ADDRSSA(CFALPH)
      SN1(IC)=ISIGN*KSIGN(NORDA)
     ENDDO

     ! LOOP OVER BETA T-AMPLITUDE
     DO IB=1,NCFB
      IF (DABS(VEC1(IB,IA)) < 1.0D-15) CYCLE
      J=0
      DO I=1,IOCCB
       IF (.NOT.BTEST(CFHALFB(IB),REFOCCB(I)-1)) THEN
        J=J+1
        HOLEB(J)=REFOCCB(I)
       ENDIF
      ENDDO
      NORDB=J
      J=0
      DO I=1,IVIRB
       IF (BTEST(CFHALFB(IB),REFVIRB(I)-1)) THEN
        J=J+1
        PARTB(J)=REFVIRB(I)
       ENDIF
      ENDDO
      IF (J /= NORDB) CALL PABORT('ERROR')
!if ((ia==1).and.(ib==1).and.(ipower==1).and.(order==2)) write(*,*) "==== caution: CCD actived!!!"
!if (NORDA+NORDB /= 2) CYCLE
      IF (NORDA+NORDB > ORDER) CYCLE

      ! LOOP OVER BETA CONFIGURATIONS
      DO ID=1,NCFB
       LCYCLE=.FALSE.
       CFBETA=CFHALFB(ID)
       IF (.NOT.LDAGGER) THEN
        DO I=1,NORDB
         IF (.NOT.BTEST(CFBETA,HOLEB(I)-1)) LCYCLE=.TRUE.
         IF (BTEST(CFBETA,PARTB(I)-1)) LCYCLE=.TRUE.
        ENDDO
       ELSE
        DO I=1,NORDB
         IF (BTEST(CFBETA,HOLEB(I)-1)) LCYCLE=.TRUE.
         IF (.NOT.BTEST(CFBETA,PARTB(I)-1)) LCYCLE=.TRUE.
        ENDDO
       ENDIF
       LC2(ID)=LCYCLE
       IF (LCYCLE) CYCLE
       JSIGN=1
       IF (.NOT.LDAGGER) THEN
        DO I=1,NORDB
         IF (HOLEB(I) /= 1) THEN
          DO J=1,HOLEB(I)-1
           IF (BTEST(CFBETA,J-1)) JSIGN=-JSIGN
          ENDDO
         ENDIF
         CFBETA=IBCLR(CFBETA,HOLEB(I)-1)
        ENDDO
        DO I=1,NORDB
         DO J=1,PARTB(I)-1
          IF (BTEST(CFBETA,J-1)) JSIGN=-JSIGN
         ENDDO
         CFBETA=IBSET(CFBETA,PARTB(I)-1)
        ENDDO
       ELSE
        DO I=NORDB,1,-1
         DO J=1,PARTB(I)-1
          IF (BTEST(CFBETA,J-1)) JSIGN=-JSIGN
         ENDDO
         CFBETA=IBCLR(CFBETA,PARTB(I)-1)
        ENDDO
        DO I=NORDB,1,-1
         IF (HOLEB(I) /= 1) THEN
          DO J=1,HOLEB(I)-1
           IF (BTEST(CFBETA,J-1)) JSIGN=-JSIGN
          ENDDO
         ENDIF
         CFBETA=IBSET(CFBETA,HOLEB(I)-1)
        ENDDO
       ENDIF
       AD2(ID)=ADDRSSB(CFBETA)
       SN2(ID)=JSIGN*KSIGN(NORDB)
      ENDDO

      ! LOOP OVER ALPHA CONFIGURATIONS
      DO IC=1,NCFA
       IF (LC1(IC)) CYCLE
       ! LOOP OVER BETA CONFIGURATIONS
       DO ID=1,NCFB
        IF (LC2(ID)) CYCLE
        IF (DABS(VEC2(ID,IC)) < 1.0D-15) CYCLE
        VEC3(AD2(ID),AD1(IC))=VEC3(AD2(ID),AD1(IC))+DFLOAT(SN1(IC)*SN2(ID))*VEC1(IB,IA)*VEC2(ID,IC)
       ENDDO
      ENDDO

     ENDDO
    ENDDO
    ! AT THIS POINT, VEC3 CONTAINS T TO THE POWER OF IPOWER.  VEC3 IS COPIED TO VEC2 FOR NEXT ITERATION,
    ! AND VEC3 IS ADDED TO THE VECTOR STORED IN 91.
    VEC3=VEC3/DFLOAT(IPOWER)
    REWIND(OUTFILE)
    READ(OUTFILE) VEC2
    VEC2=VEC2+VEC3
!do ia=1,ncfa
!do ib=1,ncfb
!write(*,*) 'ia,ib = ',ia,ib,' (1+T+...T^',ipower,') |icfa,icfb> = ',vec2(ib,ia)
!enddo
!enddo
    REWIND(OUTFILE)
    WRITE(OUTFILE) VEC2
    VEC2=VEC3
   ENDDO
!rewind(outfile)
!read(outfile) vec2
!do ia=1,ncfa
!do ib=1,ncfb
!write(*,*) 'ia,ib = ',ia,ib,' expT|icfa,icfb> = ',vec2(ib,ia)
!enddo
!enddo

   DEALLOCATE(VEC1,VEC2,VEC3)
   DEALLOCATE(AD1,AD2,SN1,SN2,LC1,LC2)

   RETURN
END SUBROUTINE



SUBROUTINE THERMAL_T_UPDATE(ITER,NDEGEN,ICFA,ICFB,TFILE,EXPTFILE,HEXPTFILE,DELTAFILE,ORDER,CCE,CCS,DEVSQ1,DEVSQ2,&
                            REFOCCA,REFOCCB,REFVIRA,REFVIRB,LIPALDUS)
! UPDATE T AMPLITUDES AND OVERWRITE TFILE BASED ON THE DIFFERENCES
! <A|H EXP(T)|0> - <A|E EXP(T)|0> FOR EXTERNALS <A| OR 
! <I|  EXP(T)|0> - <I|        |0> FOR INTERNALS <I|.

   USE CONTROL
   USE GRADIENT
   USE STRUCTURE
   USE INTEGRAL
   USE BASISSET
   USE THR_FULLCI

   IMPLICIT NONE
   LOGICAL :: LIPALDUS
   INTEGER :: ITER
   INTEGER :: NDEGEN
   INTEGER :: ICFA(NDEGEN),ICFB(NDEGEN) ! REFERENCE HALF CONFIGURATIONS
   INTEGER :: TFILE,EXPTFILE,HEXPTFILE,DELTAFILE
   INTEGER :: ORDER
   DOUBLE PRECISION :: CCE(NDEGEN,NDEGEN),CCS(NDEGEN,NDEGEN)
   DOUBLE PRECISION :: DEVSQ1(NDEGEN),DEVSQ2(NDEGEN)
   INTEGER :: REFOCCA(IALL(0,0,0),NDEGEN),REFOCCB(IALL(0,0,0),NDEGEN)
   INTEGER :: REFVIRA(IALL(0,0,0),NDEGEN),REFVIRB(IALL(0,0,0),NDEGEN)
   INTEGER :: I,J,N,M
   INTEGER :: IA,IB,IC,ID
   INTEGER :: IOCCA,IVIRA,NORDA
   INTEGER :: IOCCB,IVIRB,NORDB
   INTEGER :: HOLEA(ORDER),HOLEB(ORDER),PARTA(ORDER),PARTB(ORDER)
   INTEGER :: D_NORDA(NDEGEN),D_NORDB(NDEGEN)
   INTEGER :: KSIGN(0:2*IALL(0,0,0)),ISIGN,JSIGN
   INTEGER(4) :: CFALPH,CFBETA
   DOUBLE PRECISION :: HA,HB,DEV1,DEV2
   DOUBLE PRECISION,ALLOCATABLE :: VEC1(:,:),VEC2(:,:),VEC3(:,:),VEC4(:,:),VEC0(:,:)
!  DOUBLE PRECISION,ALLOCATABLE :: DEVVEC(:,:,:),PARITYVEC(:,:,:),DIAGVEC(:,:,:),TVEC(:,:,:)
   DOUBLE PRECISION,ALLOCATABLE :: ER(:),EI(:),VR(:,:),VL(:,:),WK(:)
   LOGICAL :: LDIIS
   INTEGER :: IDIIS,IORDER
   DOUBLE PRECISION :: B(21,21),BS(21,21),C(21),CS(21)
   INTEGER :: INDX(21)
   DOUBLE PRECISION :: D
   DOUBLE PRECISION,ALLOCATABLE :: VEC5(:,:,:)

   LOGICAL :: LCHECK

!  ALLOCATE(DEVVEC(NCFB,NCFA,NDEGEN),PARITYVEC(NCFB,NCFA,NDEGEN),DIAGVEC(NCFB,NCFA,NDEGEN),TVEC(NCFB,NCFA,NDEGEN))
!do i=1,ndegen
! write(*,*) 'degenerate ref ',i,' energy = ',cce(i,i),' overlap = ',ccs(i,i)
!enddo

   ! DIIS
   IDIIS=IOPTN(54)
   IF (IDIIS > 0) THEN
    LDIIS=.TRUE.
!   WRITE(6,'(A,I3,A)') 'DIIS EXTRAPOLATION WILL BE PERFORMED ONCE IN',IDIIS,' ITERATIONS'
   ELSE
    LDIIS=.FALSE.
    IDIIS=1
   ENDIF

   ! -----------------
   ! SIMPLE RELAXATION
   ! -----------------

   ALLOCATE(VEC1(NCFB,NCFA),VEC2(NCFB,NCFA),VEC3(NCFB,NCFA),VEC4(NCFB,NCFA),VEC0(NCFB,NCFA))

   ! SIGNS ASSOCIATED WITH THE PERMUTATION OF THE CLUSTER OPERATORS
   DO I=0,2*IALL(0,0,0)
    KSIGN(I)=(-1)**((I*(I-1))/2)
   ENDDO

   DO N=1,NDEGEN

    DEVSQ1(N)=0.0D0
    DEVSQ2(N)=0.0D0

    IOCCA=NELEA
    IOCCB=NELEB
    IVIRA=IALL(0,0,0)-IVIRTCORE-NELEA
    IVIRB=IALL(0,0,0)-IVIRTCORE-NELEB

    ! RETRIEVE T-AMPLITUDES FROM FILE
    REWIND(TFILE+N)
    DO I=1,ITER
     READ(TFILE+N) VEC1
    ENDDO
    ! RETRIEVE EXP(T)|0> WAVEFUNCTION FROM FILE
    REWIND(EXPTFILE+N)
    READ(EXPTFILE+N) VEC2
    ! RETRIEVE H EXP(T)|0> WAVEFUNCTION FROM FILE
    REWIND(HEXPTFILE+N)
    READ(HEXPTFILE+N) VEC3
    ! ZERO SCRATCH RESIDUAL VECTOR
    VEC0=0.0D0
 
    D=0.0D0

    ! LOOP OVER ALPHA T-AMPLITUDES
    D_NORDA=0
    DO IA=1,NCFA
     J=0
     DO I=1,IOCCA
      IF (.NOT.BTEST(CFHALFA(IA),REFOCCA(I,N)-1)) THEN
       J=J+1
       HOLEA(J)=REFOCCA(I,N)
      ENDIF
     ENDDO
     NORDA=J
     J=0
     DO I=1,IVIRA
      IF (BTEST(CFHALFA(IA),REFVIRA(I,N)-1)) THEN
       J=J+1
       PARTA(J)=REFVIRA(I,N)
      ENDIF
     ENDDO
     IF (J /= NORDA) CALL PABORT('ERROR')
     IF (NORDA > ORDER) CYCLE
     DO M=1,NDEGEN
      D_NORDA(M)=0
      DO I=1,IOCCA
       IF (.NOT.BTEST(CFHALFA(IA),REFOCCA(I,M)-1)) D_NORDA(M)=D_NORDA(M)+1
      ENDDO
     ENDDO
     IF (D_NORDA(N) /= NORDA) CALL PABORT('ERROR 8/29/25')

     ! GENERATE ALPHA T|0>
     CFALPH=CFHALFA(ICFA(N))
     HA=0.0D0
     ISIGN=1
     DO I=1,NORDA
      IF (HOLEA(I) /= 1) THEN
       DO J=1,HOLEA(I)-1
        IF (BTEST(CFALPH,J-1)) ISIGN=-ISIGN
       ENDDO
      ENDIF
      CFALPH=IBCLR(CFALPH,HOLEA(I)-1)
!write(*,*) 'ALPH HALF CONFIG ',IA,' HAS A HOLE ',HOLEA(I)
      HA=HA+EPSILON(HOLEA(I),0,0,0)
     ENDDO
     DO I=1,NORDA
      DO J=1,PARTA(I)-1
       IF (BTEST(CFALPH,J-1)) ISIGN=-ISIGN
      ENDDO
      CFALPH=IBSET(CFALPH,PARTA(I)-1)
!write(*,*) 'ALPH HALF CONFIG ',IA,' HAS A PART ',PARTA(I)
      HA=HA-EPSILON(PARTA(I),0,0,0)
     ENDDO
     IF (ADDRSSA(CFALPH) /= IA) CALL PABORT('ERROR XYZ')
 
     ! LOOP OVER BETA T-AMPLITUDES
     D_NORDB=0
     DO IB=1,NCFB
      J=0
      DO I=1,IOCCB
       IF (.NOT.BTEST(CFHALFB(IB),REFOCCB(I,N)-1)) THEN
        J=J+1
        HOLEB(J)=REFOCCB(I,N)
       ENDIF
      ENDDO
      NORDB=J
      J=0
      DO I=1,IVIRB
       IF (BTEST(CFHALFB(IB),REFVIRB(I,N)-1)) THEN
        J=J+1
        PARTB(J)=REFVIRB(I,N)
       ENDIF
      ENDDO
      IF (J /= NORDB) CALL PABORT('ERROR')
!if ((ia==1).and.(ib==1).and.(order==2)) write(*,*) '**** CCD is activated!'    
!if (NORDA+NORDB /= 2) CYCLE
      IF (NORDA+NORDB > ORDER) CYCLE
      DO M=1,NDEGEN
       D_NORDB(M)=0
       DO I=1,IOCCB
        IF (.NOT.BTEST(CFHALFB(IB),REFOCCB(I,M)-1)) D_NORDB(M)=D_NORDB(M)+1
       ENDDO
      ENDDO
      IF (D_NORDB(N) /= NORDB) CALL PABORT('ERROR 8/29/25-2')

      ! GENERATE BETA T|0>
      CFBETA=CFHALFB(ICFB(N))
      JSIGN=1
      HB=0.0D0
      DO I=1,NORDB
       IF (HOLEB(I) /= 1) THEN
        DO J=1,HOLEB(I)-1
         IF (BTEST(CFBETA,J-1)) JSIGN=-JSIGN
        ENDDO
       ENDIF
       CFBETA=IBCLR(CFBETA,HOLEB(I)-1)
!write(*,*) 'BETA HALF CONFIG ',IB,' HAS A HOLE ',HOLEB(I)
       HB=HB+EPSILON(HOLEB(I),0,0,0)
      ENDDO
      DO I=1,NORDB
       DO J=1,PARTB(I)-1
        IF (BTEST(CFBETA,J-1)) JSIGN=-JSIGN
       ENDDO
       CFBETA=IBSET(CFBETA,PARTB(I)-1)
!write(*,*) 'BETA HALF CONFIG ',IB,' HAS A PART ',PARTB(I)
       HB=HB-EPSILON(PARTB(I),0,0,0)
      ENDDO
      IF (ADDRSSB(CFBETA) /= IB) CALL PABORT('ERROR XYZ2')

!write(*,*) 'n=',n,'ib,ia=',ib,ia,'ha+hb=',ha+hb,'norda,nordb=',norda,nordb
!     DIAGVEC(IB,IA,N)=HA+HB

!if ((ia==1).and.(ib==1)) write(*,*) '-----------------------'
      IF (DABS(HA+HB) < 1.0D-9) THEN
!write(*,*) 'degeneracy detected for ',ia,ib
       ! INTERNAL
       ! CHECK
       LCHECK=.FALSE.
       DO M=1,NDEGEN
!write(*,*) m,icfa(m),icfb(m)
        IF ((IA==ICFA(M)).AND.(IB==ICFB(M))) LCHECK=.TRUE.
       ENDDO
       IF (.NOT.LCHECK) CALL PABORT('ERROR 12')
       IF ((IA==ICFA(N)).AND.(IB==ICFB(N))) THEN
       ! DIAGONAL
        DEV1=VEC2(IB,IA)-1.0D0
       ELSE
       ! OFF-DIAGONAL
        DEV1=VEC2(IB,IA)
       ENDIF
!if (dabs(dev1) > 1.0D-5) write(*,*) '****** internal dev',dev1
!      DEVVEC(IB,IA,N)=DEV1
!      PARITYVEC(IB,IA,N)=DFLOAT(ISIGN*JSIGN*KSIGN(NORDA)*KSIGN(NORDB))
!---------------- caution
       VEC1(IB,IA)=VEC1(IB,IA)-DEV1/DFLOAT(ISIGN*JSIGN*KSIGN(NORDA)*KSIGN(NORDB))*DOPTN(63)
       VEC0(IB,IA)=-DEV1
!if (norda+nordb==1) write(*,'(2i5,f20.10,a)') ia,ib,dev1,' <<<< internal'
!---------------- caution
       DEVSQ1(N)=DEVSQ1(N)+DEV1**2
!write(*,'(3i3,f20.10,a,i3)') n,ia,ib,dev1,' int',norda+nordb
      ELSE
       ! EXTERNAL
       ! CHECK
       LCHECK=.FALSE.
       DO M=1,NDEGEN
        IF ((IA==ICFA(M)).AND.(IB==ICFB(M))) LCHECK=.TRUE.
       ENDDO
       IF (LCHECK) CALL PABORT('ERROR 22')
       DEV2=VEC3(IB,IA)
!if ((ia==4).and.(ib==9)) &
!write(6,'(a,1f20.10)') 'delta fresh',dev2
       DO M=1,NDEGEN
        REWIND(EXPTFILE+M)
        READ(EXPTFILE+M) VEC4
        IF (LIPALDUS.AND.(D_NORDA(N)+D_NORDB(N) <= ORDER)) DEV2=DEV2-VEC4(IB,IA)*CCE(M,N)
        IF ((.NOT.LIPALDUS).AND.(D_NORDA(M)+D_NORDB(M) <= ORDER)) DEV2=DEV2-VEC4(IB,IA)*CCE(M,N)
       ENDDO
!      IF (DABS(DEV2) > D) THEN
!       IC=IA
!       ID=IB
!       D=DABS(DEV2)
!      ENDIF
!write(*,'(3i3,f20.10,a,i3)') n,ia,ib,dev2,'     ext',norda+nordb
!      DEVVEC(IB,IA,N)=DEV2
!      PARITYVEC(IB,IA,N)=DFLOAT(ISIGN*JSIGN*KSIGN(NORDA)*KSIGN(NORDB))
!write(*,*) 'external dev',dev2
! NOTE: HA+HB = epsilon_i + epsilon_j - epsilon_a - epsilon_b, etc. and negative.
!---------------- caution
!if ((ia==4).and.(ib==9)) &
!write(6,'(a,3f20.10)') 't2,delta,delta/den',vec1(ib,ia),dev2,&
!DEV2/DFLOAT(ISIGN*JSIGN*KSIGN(NORDA)*KSIGN(NORDB))/(HA+HB)
       VEC1(IB,IA)=VEC1(IB,IA)+DEV2/DFLOAT(ISIGN*JSIGN*KSIGN(NORDA)*KSIGN(NORDB))/(HA+HB)*DOPTN(63)
       VEC0(IB,IA)=DEV2
!if (norda+nordb==1) write(*,'(2i5,2f20.10,a)') ia,ib,tmp,dev2,' .... external'
!      VEC1(IB,IA)=VEC1(IB,IA)+DEV2/(HA+HB)*DOPTN(63)
!---------------- caution
!write(*,*) 'ib,ia,n,deltaT=',ib,ia,n,DEV2/DFLOAT(ISIGN*JSIGN*KSIGN(NORDA)*KSIGN(NORDB))/(HA+HB)*DOPTN(63)
!write(*,*) 'ia,ib = ',ia,ib,' ha+hb = ',ha+hb, ' dev2 = ',dev2
!write(*,*) 'ia,ib = ',ia,ib,' T amp = ',vec1(ia,ib)
!write(*,'(a,2i3,4f20.10)') 'ext ',ia,ib,vec3(ib,ia),devvec(ib,ia,n),diagvec(ib,ia,n),vec1(ib,ia)
       DEVSQ2(N)=DEVSQ2(N)+DEV2**2
      ENDIF
  
     ENDDO
    ENDDO

!   WRITE(6,'(A,F20.10)') 'INTERNAL DEVIATION ',DSQRT(DEVSQ1(N))
!   WRITE(6,'(2I3,A,2I3,F20.10)') ICFA(N),ICFB(N),' MAX EXTERNAL DEVIATION ',IC,ID,D
 
!---------------- caution
    REWIND(TFILE+N)
    DO I=1,ITER
     READ(TFILE+N) VEC2
    ENDDO
    WRITE(TFILE+N) VEC1

!write(*,*) 'residual for root',N
!do ia=1,ncfa
!do ib=1,ncfb
!write(*,*) 'ia,ib = ',ia,ib,' |icfa,icfb> = ',vec0(ib,ia)
!enddo
!enddo

    REWIND(DELTAFILE+N)
    IF (ITER > 1) THEN
     DO I=1,ITER-1
      READ(DELTAFILE+N) VEC2
     ENDDO
    ENDIF
    WRITE(DELTAFILE+N) VEC0
!---------------- caution
 
   ENDDO

   IF ((LDIIS).AND.(MOD(ITER,IDIIS) == 0)) THEN

    ! ----
    ! DIIS
    ! ----

    ALLOCATE(VEC5(NCFB,NCFA,20))

    IORDER=MIN(ITER,20)

    DO N=1,NDEGEN

     REWIND(DELTAFILE+N)
     IF (ITER > IORDER) THEN
      DO I=1,ITER-IORDER
       READ(DELTAFILE+N) VEC2
      ENDDO
     ENDIF
     DO I=1,IORDER
      READ(DELTAFILE+N) VEC5(:,:,I)
     ENDDO

     B=0.0D0
     DO I=1,IORDER
      DO J=1,IORDER
       DO IA=1,NCFA
        DO IB=1,NCFB
         B(J,I)=B(J,I)+VEC5(IB,IA,IORDER-J+1)*VEC5(IB,IA,IORDER-I+1)
        ENDDO
       ENDDO
      ENDDO
      B(I,IORDER+1)=-1.0D0
      B(IORDER+1,I)=-1.0D0
      C(I)=0.0D0
     ENDDO
     B(IORDER+1,IORDER+1)=0.0D0
     C(IORDER+1)=-1.0D0
     BS=B
     CS=C
!    WRITE(6,'(A)') 'PULAY MATRIX'
!    CALL DUMP5(B,21)
     CALL LUDCMP(B,IORDER+1,21,INDX,D)
     CALL LUBKSB(B,IORDER+1,21,INDX,C)
     CALL MPROVE(BS,B,IORDER+1,21,INDX,CS,C)
     WRITE(6,'(A,100F7.4:)') 'DIIS VECTOR',(C(I),I=1,IORDER+1)

     VEC1=0.0D0
     REWIND(TFILE+N)
     IF (ITER > IORDER) THEN
      DO I=1,ITER-IORDER
       READ(TFILE+N) VEC2
      ENDDO
     ENDIF
     DO I=1,IORDER
      READ(TFILE+N) VEC2
      VEC1=VEC1+VEC2*C(IORDER-I+1)
     ENDDO

     REWIND(TFILE+N)
     DO I=1,ITER
      READ(TFILE+N) VEC2
     ENDDO
     WRITE(TFILE+N) VEC1

    ENDDO

    DEALLOCATE(VEC5)

   ENDIF

   DEALLOCATE(VEC1,VEC2,VEC3,VEC4,VEC0)
 
   RETURN
END SUBROUTINE



SUBROUTINE DEGENERATE_CI
! FULL CI.

   USE CONSTANTS
   USE CONTROL
   USE STRUCTURE
   USE INTEGRAL
   USE BASISSET
   USE GRADIENT
   USE THR_FULLCI

   IMPLICIT NONE
!integer,parameter :: itarget=0    ! debug mode turned off
!integer,parameter :: itarget=4033 ! ground state , nondegenerate
!integer,parameter :: itarget=4036 ! excited state, 2-fold degenerate
!integer,parameter :: itarget=4018 ! excited state, 2-fold degenerate uncoupled
!integer,parameter :: itarget=4021 ! excited state, 1-fold degenerate
!integer,parameter :: itarget=3818 ! ionized state, 2-fold degenerate uncoupled
!integer,parameter :: itarget=2610 ! ionized state, 5-fold degenerate
!integer,parameter :: itarget=3438 ! 4-alpha,4-beta,2-fold,coupled x 2
!integer,parameter :: itarget=3440 ! 2-fold, coupled, divergent off the bat!
!integer,parameter :: itarget=4034 ! excited state, 4-fold
   LOGICAL :: LGUESS
   LOGICAL :: LALL
   INTEGER :: NDEGEN
   INTEGER,PARAMETER :: MAXNDEGEN=99
   INTEGER :: REFA(MAXNDEGEN),REFB(MAXNDEGEN)
   INTEGER :: I,J,K,L,M,N
   INTEGER :: ISTATE,JSTATE
   INTEGER :: IA,IB
   REAL :: ICPUS,ICPUE
   DOUBLE PRECISION,ALLOCATABLE :: E0(:)
   DOUBLE PRECISION,ALLOCATABLE :: FACTORIAL(:)
   DOUBLE PRECISION,ALLOCATABLE :: ALLE_LAMBDA(:,:)
   DOUBLE PRECISION,ALLOCATABLE :: A(:,:),ER(:),EI(:),VR(:,:),VL(:,:),WK(:)
   DOUBLE PRECISION :: OVLP,OVLP2
   INTEGER,ALLOCATABLE :: IFCI(:)
   INTEGER :: ICFA(MAXNDEGEN),ICFB(MAXNDEGEN)
   LOGICAL :: LUSED
   INTEGER :: INFO
   INTEGER :: LIST(MAXNDEGEN)
   CHARACTER(40) :: CBITSA,CBITSB
   DOUBLE PRECISION,ALLOCATABLE :: B(:,:),BS(:,:),C(:),CS(:)
   DOUBLE PRECISION :: D
   INTEGER,ALLOCATABLE :: INDX(:)
   DOUBLE PRECISION,ALLOCATABLE :: VEC1(:,:),VEC2(:,:),VEC3(:,:)
   CHARACTER(3)  :: APPEND
   CHARACTER(15) :: FULLAPPEND
   INTEGER :: TORDER
   INTEGER :: HOLEA(2*IALL(0,0,0)),HOLEB(2*IALL(0,0,0)),PARTA(2*IALL(0,0,0)),PARTB(2*IALL(0,0,0))
   INTEGER :: KSIGN(0:2*IALL(0,0,0)),ISIGN,JSIGN
   INTEGER(4) :: CFALPH,CFBETA
   INTEGER :: REFOCCA(IALL(0,0,0)),REFOCCB(IALL(0,0,0)),IOCCA,IVIRA,NORDA
   INTEGER :: REFVIRA(IALL(0,0,0)),REFVIRB(IALL(0,0,0)),IOCCB,IVIRB,NORDB
   DOUBLE PRECISION :: HA,HB
   INTEGER :: ORDER
   INTEGER :: JTARGET,JDEGEN
   INTEGER :: NELEA_TARGET,NELEB_TARGET
   INTEGER :: NTARGETS,MTARGETS
   INTEGER,ALLOCATABLE :: ITARGETS(:)
   DOUBLE PRECISION :: PREVIOUSMIN,CURRENTMIN
   LOGICAL :: LEXIST
   INTEGER,ALLOCATABLE :: REFMAP(:),NREFMAP(:)
   INTEGER,ALLOCATABLE :: MDEGEN(:),MLIST(:,:)
   DOUBLE PRECISION :: X

   WRITE(6,'(/,A)') '***********'
   WRITE(6,'(A)')   '* FULL CI *'
   WRITE(6,'(A)')   '***********'

   IF ((KVCX /= 0).OR.(KVCY /= 0).OR.(KVCZ /= 0)) CALL PABORT('FOR MOLECULES ONLY')
   IF (LOPTN(25)) CALL PABORT('USE NON-DIRECT ALGORITHM')
   IF (IALL(0,0,0)-IOCC-IVIRTCORE <= 0) CALL PABORT('NO VIRTUAL ORBITAL')
!if (itarget /= 0) write(*,*) 'debug mode ******************** for state ',itarget
   CALL CPU_TIME(ICPUS)

   LGUESS=LOPTN(111)

   IF (IOPTN(59) <= 0) THEN
    WRITE(6,'(A)') 'ALL ROOTS ARE SOUGHT'
    WRITE(6,'(A,I10)') 'NUMBER OF ROOTS = ',2**(2*(IALLMAX-IVIRTCORE-ICORE))
    LALL=.TRUE.
 nelea_target=3
 neleb_target=3
!   LGUESS=.FALSE.
    IF (IALL(0,0,0)-IOCC-IVIRTCORE > 15) CALL PABORT('INTEGER*4 ARGUMENT OVERFLOW')
   ELSE IF (LOPTN(60)) THEN
    NELEA_TARGET=IOCC-1
    NELEB_TARGET=IOCC
    WRITE(6,'(A)') 'IP ROOTS ARE SOUGHT'
    WRITE(6,'(A,2I3)') 'NELEA,NELEB = ',NELEA_TARGET,NELEB_TARGET
    WRITE(6,'(A,I3)') 'NUMBER OF ROOTS = ',IOPTN(59)
    LALL=.FALSE.
   ELSE IF (LOPTN(61)) THEN
    NELEA_TARGET=IOCC+1
    NELEB_TARGET=IOCC
    WRITE(6,'(A)') 'EA ROOTS ARE SOUGHT'
    WRITE(6,'(A,2I3)') 'NELEA,NELEB = ',NELEA_TARGET,NELEB_TARGET
    WRITE(6,'(A,I3)') 'NUMBER OF ROOTS = ',IOPTN(59)
    LALL=.FALSE.
   ELSE
    NELEA_TARGET=IOCC
    NELEB_TARGET=IOCC
    WRITE(6,'(A)') 'EXCITED ROOTS ARE SOUGHT'
    WRITE(6,'(A,2I3)') 'NELEA,NELEB = ',NELEA_TARGET,NELEB_TARGET
    WRITE(6,'(A,I3)') 'NUMBER OF ROOTS = ',IOPTN(59)
    LALL=.FALSE.
   ENDIF

   ALLOCATE(H(IALLMAX-IVIRTCORE,IALLMAX-IVIRTCORE))
   ALLOCATE(G(IALLMAX-IVIRTCORE,IALLMAX-IVIRTCORE,IALLMAX-IVIRTCORE,IALLMAX-IVIRTCORE))
   CALL THERMAL_ONE_ELECTRON_INTEGRALS
   CALL THERMAL_TWO_ELECTRON_INTEGRALS

   ! SIGNS ASSOCIATED WITH THE PERMUTATION OF THE CLUSTER OPERATORS
   DO I=0,2*IALL(0,0,0)
    KSIGN(I)=(-1)**((I*(I-1))/2)
   ENDDO

   ! ====================================
   ! GENERATE DEGENERATE CI ENERGY MATRIX
   ! ====================================
   ESHIFT=1.0D9
   DO NELE=2*ICORE,2*(IALL(0,0,0)-IVIRTCORE)
    DO NELEA=ICORE,NELE
     NELEB=NELE-NELEA
     IF ((.NOT.LALL).AND.((NELEA /= NELEA_TARGET).OR.(NELEB /= NELEB_TARGET))) CYCLE
 if ((lall).AND.((nelea /= nelea_target).OR.(neleb /= neleb_target))) CYCLE
     IF (NELEA > IALL(0,0,0)-IVIRTCORE) CYCLE
     IF (NELEB > IALL(0,0,0)-IVIRTCORE) CYCLE
     IF (NELEA < ICORE) CYCLE
     IF (NELEB < ICORE) CYCLE
     WRITE(6,'(/,A,2I3)') '-----------------------'
     WRITE(6,'(A,2I3)')   'No.ELECTRONS ARE ',NELEA,NELEB
     WRITE(6,'(A,2I3)')   '-----------------------'
     CALL THERMAL_GENERATE_CONFIGURATIONSA(NELEA,MIN(NELEA,IALL(0,0,0)-IVIRTCORE-NELEA))
     CALL THERMAL_GENERATE_CONFIGURATIONSB(NELEB,MIN(NELEB,IALL(0,0,0)-IVIRTCORE-NELEB))
     WRITE(6,'(A,I10)') 'DIMENSION OF E0 ARRAY = ',NCFA*NCFB
     !
     ! ZEROTH-ORDER ENERGIES UNSORTED
     !                       ^^^^^^^^
     ALLOCATE(E0(NCFA*NCFB),ALLE(NCFA*NCFB),ALLN(NCFA*NCFB),ALL_M(NCFA*NCFB),REFMAP(NCFA*NCFB),NREFMAP(NCFA*NCFB))
     DO IA=1,NCFA
      DO IB=1,NCFB
       E0((IA-1)*NCFB+IB)=NUCLEAR_REPULSION
       DO I=1,IALL(0,0,0)-IVIRTCORE
        IF (BTEST(CFHALFA(IA),I-1)) &
         E0((IA-1)*NCFB+IB)=E0((IA-1)*NCFB+IB)+EPSILON(I,0,0,0)
        IF (BTEST(CFHALFB(IB),I-1)) &
         E0((IA-1)*NCFB+IB)=E0((IA-1)*NCFB+IB)+EPSILON(I,0,0,0)
       ENDDO
      ENDDO
     ENDDO
     DO I=1,NCFA*NCFB
      ALLN(I)=NELE
      IF (E0(I) < ESHIFT) ESHIFT=E0(I)
!     WRITE(6,'(I3,F20.10)') I,E0(I)
     ENDDO
     ! DETERMINE TOTAL NUMBER OF NONDEGENERATE REFS
     MTARGETS=0
     DO I=1,NCFA*NCFB
      LEXIST=.FALSE.
      IF (I > 1) THEN
       DO J=1,I-1
        IF (DABS(E0(J)-E0(I)) < 1.0D-9) LEXIST=.TRUE.
       ENDDO
      ENDIF
      IF (.NOT.LEXIST) MTARGETS=MTARGETS+1
     ENDDO
     WRITE(6,'(A,I5)') 'TOTAL NUMBER OF NONDEGENERATE REFS = ',MTARGETS
     IF (LALL) THEN
      NTARGETS=MTARGETS
     ELSE
      NTARGETS=MIN(IOPTN(59),MTARGETS)
     ENDIF
     IF (IOPTN(59) > NTARGETS) THEN
      WRITE(6,'(A,I5,A,I5)') 'NUMBER OF TARGETS REDUCED FROM ',IOPTN(59),' TO ',NTARGETS
     ELSE
      WRITE(6,'(A,I5)') 'NUMBER OF TARGETS = ',NTARGETS
     ENDIF
     !
     ! POPULATE TARGET STATES
     ! 
     ALLOCATE(ITARGETS(NTARGETS),MDEGEN(NTARGETS),MLIST(MAXNDEGEN,NTARGETS))
     PREVIOUSMIN=-1.0D99
     DO I=1,NTARGETS
      CURRENTMIN=1.0D99
      DO J=1,NCFA*NCFB
       IF ((E0(J) < CURRENTMIN).AND.(DABS(E0(J)-CURRENTMIN) > 1.0D-9).AND.(E0(J)-PREVIOUSMIN > 1.0D-9)) THEN
!      IF ((E0(J)-PREVIOUSMIN > 1.0D-9).AND.(E0(J) < CURRENTMIN)) THEN
        CURRENTMIN=E0(J)
        ITARGETS(I)=J
       ENDIF
      ENDDO
      PREVIOUSMIN=CURRENTMIN
     ENDDO
     L=0
     DO I=1,NTARGETS
      K=0
      DO J=1,NCFA*NCFB
       IF (DABS(E0(J)-E0(ITARGETS(I))) < 1.0D-9) THEN
        K=K+1
        MLIST(K,I)=J
       ENDIF
      ENDDO
      IF (K > MAXNDEGEN) CALL PABORT('INCREASE MAXNDEGEN')
      MDEGEN(I)=K
      L=L+K
      WRITE(6,'(A,I3,A,I10,A,F15.10,I5,A,100I5:)') 'TARGET',I,' = STATE',ITARGETS(I),' ZEROTH-ORDER ENERGY = ',E0(ITARGETS(I)),&
                                                   MDEGEN(I),'-FOLD DEGENERATE:',(MLIST(J,I),J=1,MDEGEN(I))
     ENDDO
     IF (LALL.AND.(L /= NCFA*NCFB)) CALL PABORT('ERROR TRAP IN DEGENERATE_CI')
     !
     ! SOLVE DEGENERATE CI
     !
     ALLOCATE(EDCI(NCFA*NCFB,NCFA*NCFB))
     CALL DCI_GEN(0)
     ALLOCATE(A(NCFA*NCFB,NCFA*NCFB),ER(NCFA*NCFB),EI(NCFA*NCFB),VR(NCFA*NCFB,NCFA*NCFB),&
              VL(1,NCFA*NCFB),WK(4*NCFA*NCFB))
     A=0.0D0
     DO J=1,NCFA*NCFB
      DO L=1,NCFA*NCFB
       A(L,J)=EDCI(L,J)
      ENDDO
     ENDDO
     DEALLOCATE(EDCI)
!    WRITE(6,'(A)') 'FULL CI MATRIX'
!    CALL DUMP5(A,NCFA*NCFB)
!------------------------------- DIAGONALIZATION
     CALL DGEEV('N','V',NCFA*NCFB,A,NCFA*NCFB,ER,EI,VL,1,VR,NCFA*NCFB,WK,4*NCFA*NCFB,INFO)
     IF (INFO /= 0) CALL PABORT('DGEEV FAILED TO DIAGONALIZE A MATRIX')
     CALL PIKSRT(NCFA*NCFB,NCFA*NCFB,ER,VR,EI)
     CALL SCHMIDT_EIGENVECTORS(NCFA*NCFB,VR) ! VERY IMPORTANT !
!------------------------------- CHECK OVERLAP
     DO I=1,NCFA*NCFB
      DO J=1,NCFA*NCFB
       A(I,J)=0.0D0
       DO L=1,NCFA*NCFB
        A(I,J)=A(I,J)+VR(L,I)*VR(L,J)
       ENDDO
      ENDDO
     ENDDO
     DO I=1,NCFA*NCFB
      IF (DABS(A(I,I)-1.0D0) > 1.0D-12) CALL PABORT('ERROR 543')
      DO J=1,NCFA*NCFB
       IF (I==J) CYCLE
       IF (DABS(A(I,J)-0.0D0) > 1.0D-12) CALL PABORT('ERROR 542')
      ENDDO
     ENDDO
!    WRITE(6,'(A)') 'FULL OVERLAP MATRIX'
!    CALL DUMP5(A,NCFA*NCFB)

!    ----------------------------
!    FIRST MAP FCI STATES TO REFS
!    ----------------------------
!    CALL DUMP5(VR,NCFA*NCFB)
! -- VERSION 1
!    REFMAP=-999999
!    DO I=1,NCFA*NCFB
!     OVLP=0.0D0
!     DO J=1,NCFA*NCFB
!      IF (VR(I,J)**2 > OVLP) THEN
!       LUSED=.FALSE.
!       IF (I >= 2) THEN
!        DO L=1,I-1
!         IF (REFMAP(L)==J) LUSED=.TRUE.
!        ENDDO
!       ENDIF
!       IF (.NOT.LUSED) THEN
!        OVLP=VR(I,J)**2
!        REFMAP(I)=J
!       ENDIF
!      ENDIF
!     ENDDO
!    ENDDO
! -- VERSION 2
     REFMAP=-999999
     DO I=1,NTARGETS
      ! ASSIGN A DEGENERATE MANIFOLD TO FCI STATES
      ALLOCATE(B(MDEGEN(I),MDEGEN(I)))
      B=0.0D0
      DO N=1,MDEGEN(I)
       OVLP=0.0D0
       DO J=1,NCFA*NCFB
        OVLP2=0.0D0
        DO K=1,MDEGEN(I)
         OVLP2=OVLP2+VR(MLIST(K,I),J)**2 ! UNITARY FCI COEFF MATRIX INVERSE IS USED HERE.
        ENDDO
        IF (OVLP2 > OVLP) THEN
         LUSED=.FALSE.
         IF (I >= 2) THEN
          DO L=1,I-1
           DO M=1,MDEGEN(L)
            IF (REFMAP(MLIST(M,L))==J) LUSED=.TRUE.
           ENDDO
          ENDDO
         ENDIF
         IF (N >= 2) THEN
          DO M=1,N-1
           IF (REFMAP(MLIST(M,I))==J) LUSED=.TRUE.
          ENDDO
         ENDIF
         IF (.NOT.LUSED) THEN
          DO K=1,MDEGEN(I)
           B(K,N)=VR(MLIST(K,I),J)
          ENDDO
          CALL SCHMIDT2(MDEGEN(I),B,N,X)
          IF (X > 1.0D-9) THEN
           OVLP=OVLP2
           REFMAP(MLIST(N,I))=J
!          WRITE(6,'(A,I3)') 'SMALL FCI COEFF MATRIX @',N
!          CALL DUMP5(B,MDEGEN(I))
          ENDIF
         ENDIF
        ENDIF
       ENDDO
      ENDDO
      DEALLOCATE(B)
      ! REORDER WITHIN THE DEGENERATE MANIFOLD
      NREFMAP=REFMAP
      DO N=1,MDEGEN(I)
       OVLP=0.0D0
       DO M=1,MDEGEN(I)
        LUSED=.FALSE.
        IF (N > 1) THEN
         DO J=1,N-1
          IF (REFMAP(MLIST(J,I))==NREFMAP(MLIST(M,I))) LUSED=.TRUE.
         ENDDO
        ENDIF
        IF ((.NOT.LUSED).AND.(VR(MLIST(N,I),NREFMAP(MLIST(M,I)))**2 > OVLP)) THEN
         OVLP=VR(MLIST(N,I),NREFMAP(MLIST(M,I)))**2
         REFMAP(MLIST(N,I))=NREFMAP(MLIST(M,I))
        ENDIF
       ENDDO
      ENDDO
     ENDDO
!    WRITE(*,'(A,A,A,A)') ' TARGET',' DEGEN',' STATE',' DETERMINANT'
     DO I=1,NTARGETS
      DO J=1,MDEGEN(I)
!      WRITE(*,'(I7,I6,I6,I12)') I,J,MLIST(J,I),REFMAP(MLIST(J,I))
      ENDDO
     ENDDO

!    -----------------
!    LOOP OVER TARGETS
!    -----------------
     NREFMAP=0
     DO ISTATE=1,NTARGETS
!if (istate /= 25) cycle
      NDEGEN=0
      LIST=0
      WRITE(6,'(/,A,I5,A,I5)') '***** TARGET ',ISTATE,' = STATE ',ITARGETS(ISTATE)
      DO J=1,NCFA*NCFB
       IF (DABS(E0(J)-E0(ITARGETS(ISTATE))) < 1.0D-9) THEN
        NDEGEN=NDEGEN+1
        LIST(NDEGEN)=J
       ENDIF
      ENDDO
      IF (NDEGEN > MAXNDEGEN) CALL PABORT('ERROR')
      DO I=1,NDEGEN
       IB=MOD(LIST(I)-1,NCFB)+1
       IA=(LIST(I)-IB)/NCFB+1
       IF ((IA-1)*NCFB+IB /= LIST(I)) CALL PABORT('ERROR 311')
       CBITSA=""
       CBITSB=""
       DO J=1,IALL(0,0,0)-IVIRTCORE
        IF (BTEST(CFHALFA(IA),J-1)) THEN
         CBITSA="1"//CBITSA
        ELSE
         CBITSA="0"//CBITSA
        ENDIF
        IF (BTEST(CFHALFB(IB),J-1)) THEN
         CBITSB="1"//CBITSB
          ELSE
         CBITSB="0"//CBITSB
        ENDIF
       ENDDO
       WRITE(6,'(I3,A,I5,A,2(I3,A,A,A))') I,'-TH DEGENERATE REF',LIST(I),':',IA,' (',TRIM(CBITSA),')',IB,' (',TRIM(CBITSB),')'
      ENDDO
      WRITE(6,'(I3,A,10X,128I10)') NDEGEN,'-FOLD DEGENERATE:',(LIST(J),J=1,NDEGEN)
!     -----------------------------------------------------------------
!     GENERATE FULL CC T-AMPLITUDES (Li & Paldus, JCP, 119, 5320, 2003)
!     -----------------------------------------------------------------
      ALLOCATE(IFCI(NDEGEN))
      DO I=1,NDEGEN
       LUSED=.FALSE.
       DO IA=1,NCFA
        DO IB=1,NCFB
         J=(IA-1)*NCFB+IB
         IF (J==LIST(I)) THEN
          ICFA(I)=IA
          ICFB(I)=IB
          LUSED=.TRUE.
         ENDIF
        ENDDO
       ENDDO
       IF (.NOT.LUSED) CALL PABORT('ERROR 1369')
! .... FOLLOWING FAULTY LOGIC (OVERLAP MAPPING) IS REPLACED FROM HERE ...
!      OVLP=0.0D0
!      IFCI(I)=-1
!      DO IA=1,NCFA
!       DO IB=1,NCFB
!        J=(IA-1)*NCFB+IB
!        IF (VR(LIST(I),J)**2 > OVLP) THEN
!         LUSED=.FALSE.
!         IF (I >= 2) THEN
!          DO L=1,I-1
!           IF (IFCI(L)==J) LUSED=.TRUE.
!          ENDDO
!         ENDIF
!         IF (.NOT.LUSED) THEN
!          OVLP=VR(LIST(I),J)**2
!          IFCI(I)=J
!         ENDIF
!        ENDIF
!       ENDDO
!      ENDDO
!      IF (IFCI(I)==-1) CALL PABORT('ERROR 1234')
! ... TO HERE BY FROM HERE ... 
       IFCI(I)=REFMAP(LIST(I))
! ... TO HERE
      ENDDO
      DO J=1,NCFA*NCFB
       LUSED=.FALSE.
       DO I=1,NDEGEN
        IF (J==IFCI(I)) THEN
         WRITE(*,'(I5,F20.10,I5,128F10.4:)') J,ER(J)+NUCLEAR_REPULSION,LIST(I),(VR(LIST(L),J),L=1,NDEGEN)
         LUSED=.TRUE.
         NREFMAP(J)=NREFMAP(J)+1
        ENDIF
       ENDDO
!      IF (.NOT.LUSED) WRITE(*,'(I5,F20.10,5X,128F10.4:)') J,ER(J)+NUCLEAR_REPULSION,(VR(LIST(L),J),L=1,NDEGEN)
      ENDDO
      CALL CPU_TIME(ICPUE)
      WRITE(6,'(A,F10.2)') 'CPU/SEC =',ICPUE-ICPUS
      CALL CPU_TIME(ICPUS)
      CALL PFLUSH(6)

!     NEXT DETERMINE THE EXACT WAVE FUNCTION FOR EACH DEGENERATE REF
      ALLOCATE(INDX(NDEGEN),B(NDEGEN,NDEGEN),BS(NDEGEN,NDEGEN),C(NDEGEN),CS(NDEGEN))
      ALLOCATE(VEC1(NCFB,NCFA),VEC2(NCFB,NCFA),VEC3(NCFB,NCFA))
      DO I=1,NDEGEN
       WRITE(APPEND,'(I3)') I
       WRITE(FULLAPPEND,'(I2.2,A,I2.2,A,I5.5,A,I3.3)') NELEA,'.',NELEB,'.',ISTATE,'.',I
       OPEN(100+I,FILE=TRIM(COPTN(1))//'.T.'//FULLAPPEND,FORM='UNFORMATTED')
       OPEN(200+I,FILE=TRIM(COPTN(1))//'.expT.'//APPEND,FORM='UNFORMATTED')
       OPEN(900+I,FILE=TRIM(COPTN(1))//'.expTexact.'//APPEND,FORM='UNFORMATTED')
       WRITE(6,'(A,A)') 'EXACT T-AMPLITUDES WRITTEN TO ',TRIM(COPTN(1))//'.T.'//FULLAPPEND
      ENDDO
      OPEN(90,FILE=TRIM(COPTN(1))//'.tmp1',FORM='UNFORMATTED')
      DO I=1,NDEGEN
       DO J=1,NDEGEN
        B(I,J)=VR(LIST(I),IFCI(J))
       ENDDO
      ENDDO
!     WRITE(6,'(A)') 'FULL CI COEFF MATRIX'
!     CALL DUMP5(B,NDEGEN)
      BS=B
      CALL LUDCMP(B,NDEGEN,NDEGEN,INDX,D)
!     WRITE(6,'(A)') 'LU DECOMPOSITION'
!     CALL DUMP5(B,NDEGEN)
!     WRITE(6,'(A)') 'LU DECOMPOSITION DIAGONAL'
!     WRITE(6,'(100F8.4:)') (B(I,I),I=1,NDEGEN)
      LEXIST=.FALSE.
      DO I=1,NDEGEN
       IF (DABS(B(I,I)) < 1.0D-9) LEXIST=.TRUE.
      ENDDO
      IF (LEXIST) THEN
       WRITE(6,'(A)') 'SINGULAR PARTIAL FULL CI MATRIX DETECTED; EXACT T-AMPLITUDES CANNOT BE DETERMINED'
!      CALL PABORT('SINGULAR PARTIAL FULL CI MATRIX DETECTED; EXACT T-AMPLITUDES CANNOT BE DETERMINED')
      ELSE
       DO I=1,NDEGEN
        C=0.0D0
        C(I)=1.0D0
        CS=C
        CALL LUBKSB(B,NDEGEN,NDEGEN,INDX,C)
        CALL MPROVE(BS,B,NDEGEN,NDEGEN,INDX,CS,C)
!write(*,'(i3,128f10.5:)') i,(c(j),j=1,ndegen)
        VEC1=0.0D0
        DO J=1,NDEGEN
         DO IA=1,NCFA
          DO IB=1,NCFB
           VEC1(IB,IA)=VEC1(IB,IA)+C(J)*VR((IA-1)*NCFB+IB,IFCI(J))
          ENDDO
         ENDDO
        ENDDO
        REWIND(900+I)
        WRITE(900+I) VEC1
       ENDDO
      ENDIF

      ! NEXT REVERSE-COMPUTE T AMPLITUDES FROM EXACT WAVE FUNCTION
      TORDER=MIN(2*(IALL(0,0,0)-IVIRTCORE)-NELEA-NELEB,NELEA+NELEB)
      WRITE(6,'(A,I3)') 'MAX CC ORDER = ',TORDER

      DO N=1,NDEGEN
!write(*,*) 'now working on ref ',n

       ! DETERMINE OCCUPIED AND VIRTUAL ORBITALS IN REF
       REFOCCA=0
       REFVIRA=0
       IOCCA=0
       IVIRA=0
       REFOCCB=0
       REFVIRB=0
       IOCCB=0
       IVIRB=0
       DO I=1,IALL(0,0,0)-IVIRTCORE
        IF (BTEST(CFHALFA(ICFA(N)),I-1)) THEN
         IOCCA=IOCCA+1
         REFOCCA(IOCCA)=I
        ELSE
         IVIRA=IVIRA+1
         REFVIRA(IVIRA)=I
        ENDIF
        IF (BTEST(CFHALFB(ICFB(N)),I-1)) THEN
         IOCCB=IOCCB+1
         REFOCCB(IOCCB)=I
        ELSE
         IVIRB=IVIRB+1
         REFVIRB(IVIRB)=I
        ENDIF
       ENDDO
       IF (IOCCA /= NELEA) CALL PABORT('ERROR')
       IF (IOCCB /= NELEB) CALL PABORT('ERROR')
!write(*,*) 'occupied alpha = ',(REFOCCA(I),I=1,IOCCA)
!write(*,*) 'occupied beta  = ',(REFOCCB(I),I=1,IOCCB)
!write(*,*) 'virtual  alpha = ',(REFVIRA(I),I=1,IVIRA)
!write(*,*) 'virtual  beta  = ',(REFVIRB(I),I=1,IVIRB)

       ! RETRIEVE EXP(T)|0> WAVEFUNCTION FROM FILE
       REWIND(900+N)
       READ(900+N) VEC1 ! CONTAINS THE EXACT WAVE FUNCTION
 
       VEC2=0.0D0 ! WILL CONTAIN Tn AMPLITUDES
 
       ! DETERMINE T1 AMPLITUDES FIRST AND GO UP
       DO ORDER=1,TORDER
 
        ! LOOP OVER ALPHA T-AMPLITUDES
        DO IA=1,NCFA
         J=0
         DO I=1,IOCCA
          IF (.NOT.BTEST(CFHALFA(IA),REFOCCA(I)-1)) THEN
           J=J+1
           HOLEA(J)=REFOCCA(I)
          ENDIF
         ENDDO
         NORDA=J
         J=0
         DO I=1,IVIRA
          IF (BTEST(CFHALFA(IA),REFVIRA(I)-1)) THEN
           J=J+1
           PARTA(J)=REFVIRA(I)
          ENDIF
         ENDDO
         IF (J /= NORDA) CALL PABORT('ERROR')
        
         ! GENERATE ALPHA T|0>
         CFALPH=CFHALFA(ICFA(N))
         HA=0.0D0
         ISIGN=1
         DO I=1,NORDA
          IF (HOLEA(I) /= 1) THEN
           DO J=1,HOLEA(I)-1
            IF (BTEST(CFALPH,J-1)) ISIGN=-ISIGN
           ENDDO
          ENDIF
          CFALPH=IBCLR(CFALPH,HOLEA(I)-1)
          HA=HA+EPSILON(HOLEA(I),0,0,0)
         ENDDO
         DO I=1,NORDA
          DO J=1,PARTA(I)-1
           IF (BTEST(CFALPH,J-1)) ISIGN=-ISIGN
          ENDDO
          CFALPH=IBSET(CFALPH,PARTA(I)-1)
          HA=HA-EPSILON(PARTA(I),0,0,0)
         ENDDO
          
         ! LOOP OVER BETA T-AMPLITUDES
         DO IB=1,NCFB
          J=0
          DO I=1,IOCCB
           IF (.NOT.BTEST(CFHALFB(IB),REFOCCB(I)-1)) THEN
            J=J+1
            HOLEB(J)=REFOCCB(I)
           ENDIF
          ENDDO
          NORDB=J
          J=0
          DO I=1,IVIRB
           IF (BTEST(CFHALFB(IB),REFVIRB(I)-1)) THEN
            J=J+1
            PARTB(J)=REFVIRB(I)
           ENDIF
          ENDDO
          IF (J /= NORDB) CALL PABORT('ERROR')
          IF (NORDA+NORDB /= ORDER) CYCLE
  
          ! GENERATE BETA T|0>
          CFBETA=CFHALFB(ICFB(N))
          JSIGN=1
          HB=0.0D0
          DO I=1,NORDB
           IF (HOLEB(I) /= 1) THEN
            DO J=1,HOLEB(I)-1
             IF (BTEST(CFBETA,J-1)) JSIGN=-JSIGN
            ENDDO
           ENDIF
           CFBETA=IBCLR(CFBETA,HOLEB(I)-1)
           HB=HB+EPSILON(HOLEB(I),0,0,0)
          ENDDO
          DO I=1,NORDB
           DO J=1,PARTB(I)-1
            IF (BTEST(CFBETA,J-1)) JSIGN=-JSIGN
           ENDDO
           CFBETA=IBSET(CFBETA,PARTB(I)-1)
           HB=HB-EPSILON(PARTB(I),0,0,0)
          ENDDO
 
          VEC2(IB,IA)=VEC2(IB,IA)+VEC1(IB,IA)/DFLOAT(ISIGN*JSIGN*KSIGN(NORDA)*KSIGN(NORDB))
 
         ENDDO
        ENDDO
      
        ! REFERENCE STATE
        VEC3=0.0D0
        VEC3(ICFB(N),ICFA(N))=1.0D0
        REWIND(90)
        WRITE(90) VEC3

        REWIND(100+N)
        WRITE(100+N) VEC2

        CALL THERMAL_EXPONENTIAL_OPERATOR(ICFA(N),ICFB(N),100+N,90,200+N,ORDER,.FALSE.,.FALSE.)

        REWIND(200+N)
        READ(200+N) VEC3
        REWIND(900+N)
        READ(900+N) VEC1
!write(*,*) '*** partial expT |icfa,icfb>, exact wfn ',n,' at order ',order
!do ia=1,ncfa
!do ib=1,ncfb
!write(*,'(2i3,2f20.10)') ia,ib,vec3(ib,ia),vec1(ib,ia)
!enddo
!enddo

        VEC1=VEC1-VEC3

       ENDDO
!rewind(100+n)
!read(100+n) vec3
!write(*,*) '*** exact T |icfa,icfb> ',n
!do ia=1,ncfa
!do ib=1,ncfb
!write(*,'(2i3,f20.10)') ia,ib,vec3(ib,ia)
!enddo
!enddo

      ENDDO

      DO I=1,NDEGEN
       CLOSE(100+I)
       CLOSE(200+I)
       CLOSE(900+I)
      ENDDO

      DEALLOCATE(VEC1,VEC2,VEC3) 
      DEALLOCATE(INDX,B,BS,C,CS)
      DEALLOCATE(IFCI)

     ENDDO

!    WRITE(6,'(/,A)') 'NUMBER OF MAPPED REFERENCES'
     LEXIST=.FALSE.
     DO I=1,NCFA*NCFB
!     WRITE(6,'(2I3)') I,NREFMAP(I)
      IF (NREFMAP(I) /= 1) LEXIST=.TRUE.
     ENDDO
!write(*,*) 'mapping failure logic bypassed'
     IF (LALL.AND.LEXIST) CALL PABORT('MAPPING FAILURE')
 
     DEALLOCATE(ITARGETS,MDEGEN,MLIST)
     DEALLOCATE(A,ER,EI,VR,VL,WK)
     DEALLOCATE(CFHALFA,ADDRSSA,NORDERA)
     DEALLOCATE(CFHALFB,ADDRSSB,NORDERB)
     DEALLOCATE(ALL_M,E0,ALLE,ALLN,REFMAP,NREFMAP)
    ENDDO
   ENDDO

   DEALLOCATE(H,G)
   RETURN
END SUBROUTINE



SUBROUTINE DCI_GEN(NALL_CHECK)
! CALCULATE FULL CI MATRIX

   USE CONSTANTS
   USE CONTROL
   USE GRADIENT
   USE STRUCTURE
   USE INTEGRAL
   USE BASISSET
   USE THR_FULLCI

   IMPLICIT NONE
   INTEGER,PARAMETER :: MAXFILE = 100
   INTEGER :: NALL_CHECK
   INTEGER :: IA,IB,IC,ID,IE,IG
   INTEGER :: I,J,K
   REAL :: MEM,ICPUS,ICPUE
   DOUBLE PRECISION,ALLOCATABLE :: VEC1(:,:)

   CALL CPU_TIME(ICPUS)
   MEM=16.0*2.0*NCFA*NCFB
   IF (MEM > DOPTN(28)*1000000.0) CALL PABORT('OUT OF MEMORY')
   ALLOCATE(VEC1(NCFB,NCFA))

   OPEN(50,FILE=TRIM(COPTN(1))//'.fi0',FORM='UNFORMATTED')
   OPEN(51,FILE=TRIM(COPTN(1))//'.fo0',FORM='UNFORMATTED')

   ! LOOP OVER ALL STATES
   DO IA=1,NCFA
    DO IB=1,NCFB

     VEC1=0.0D0
     VEC1(IB,IA)=1.0D0

     REWIND(50)
     WRITE(50) VEC1
     CALL THERMAL_HAMILTONIAN_PRODUCT(50,51,0,1.0D0)
     REWIND(51)
     READ(51) VEC1

     DO IC=1,NCFA
      DO ID=1,NCFB
       EDCI((IA-1)*NCFB+IB+NALL_CHECK,(IC-1)*NCFB+ID+NALL_CHECK)=VEC1(ID,IC)
      ENDDO
     ENDDO

    ENDDO
   ENDDO
   CALL CPU_TIME(ICPUE)

   DEALLOCATE(VEC1)
   CLOSE(50)
   CLOSE(51)
   RETURN
END SUBROUTINE



SUBROUTINE CLEAN(ICFA,ICFB,TFILE,ORDER)
! ERASE HIGHER-THAN-ORDER T AMPLITUDES IN TFILE

   USE CONTROL
   USE GRADIENT
   USE STRUCTURE
   USE INTEGRAL
   USE BASISSET
   USE THR_FULLCI

   IMPLICIT NONE
   INTEGER :: ICFA,ICFB ! REFERENCE HALF CONFIGURATIONS
   INTEGER :: TFILE
   INTEGER :: ORDER
   INTEGER :: REFOCCA(IALL(0,0,0)),REFOCCB(IALL(0,0,0)),IOCCA,IVIRA,NORDA
   INTEGER :: REFVIRA(IALL(0,0,0)),REFVIRB(IALL(0,0,0)),IOCCB,IVIRB,NORDB
   INTEGER :: HOLEA(ORDER),HOLEB(ORDER),PARTA(ORDER),PARTB(ORDER)
   INTEGER :: I,J,IA,IB
   DOUBLE PRECISION,ALLOCATABLE :: VEC1(:,:)

   WRITE(6,'(A)') 'CLEANSING T-AMPLITUDES'

   ALLOCATE(VEC1(NCFB,NCFA))

   ! DETERMINE OCCUPIED AND VIRTUAL ORBITALS IN REF
   REFOCCA=0
   REFVIRA=0
   IOCCA=0
   IVIRA=0
   REFOCCB=0
   REFVIRB=0
   IOCCB=0
   IVIRB=0
   DO I=1,IALL(0,0,0)-IVIRTCORE
    IF (BTEST(CFHALFA(ICFA),I-1)) THEN
     IOCCA=IOCCA+1
     REFOCCA(IOCCA)=I
    ELSE
     IVIRA=IVIRA+1
     REFVIRA(IVIRA)=I
    ENDIF
    IF (BTEST(CFHALFB(ICFB),I-1)) THEN
     IOCCB=IOCCB+1
     REFOCCB(IOCCB)=I
    ELSE
     IVIRB=IVIRB+1
     REFVIRB(IVIRB)=I
    ENDIF
   ENDDO
   IF (IOCCA /= NELEA) CALL PABORT('ERROR')
   IF (IOCCB /= NELEB) CALL PABORT('ERROR')

   ! RETRIEVE T-AMPLITUDES FROM FILE
   REWIND(TFILE)
   READ(TFILE) VEC1
 
   ! LOOP OVER ALPHA T-AMPLITUDES
   DO IA=1,NCFA
    J=0
    DO I=1,IOCCA
     IF (.NOT.BTEST(CFHALFA(IA),REFOCCA(I)-1)) THEN
      J=J+1
      HOLEA(J)=REFOCCA(I)
     ENDIF
    ENDDO
    NORDA=J
    J=0
    DO I=1,IVIRA
     IF (BTEST(CFHALFA(IA),REFVIRA(I)-1)) THEN
      J=J+1
      PARTA(J)=REFVIRA(I)
     ENDIF
    ENDDO
    IF (J /= NORDA) CALL PABORT('ERROR')

    ! LOOP OVER BETA T-AMPLITUDES
    DO IB=1,NCFB
     J=0
     DO I=1,IOCCB
      IF (.NOT.BTEST(CFHALFB(IB),REFOCCB(I)-1)) THEN
       J=J+1
       HOLEB(J)=REFOCCB(I)
      ENDIF
     ENDDO
     NORDB=J
     J=0
     DO I=1,IVIRB
      IF (BTEST(CFHALFB(IB),REFVIRB(I)-1)) THEN
       J=J+1
       PARTB(J)=REFVIRB(I)
      ENDIF
     ENDDO
     IF (J /= NORDB) CALL PABORT('ERROR')

     IF (NORDA+NORDB > ORDER) VEC1(IB,IA)=0.0D0

    ENDDO
   ENDDO

   REWIND(TFILE)
   WRITE(TFILE) VEC1

   DEALLOCATE(VEC1)

   RETURN
END SUBROUTINE



SUBROUTINE SCHMIDT2(N,A,I,X)
! SUBTRACT 1 THROUGH (I-1)-TH NORMALIZED COLUMN VECTOR CONTRIBUTIONS 
! FROM THE I-TH COLUMN VECTOR AND NORMALIZE THE RESIDUAL VECTOR (X RETURNS THE NORM)

   IMPLICIT NONE
   INTEGER :: N,I
   DOUBLE PRECISION :: A(N,N)
   DOUBLE PRECISION :: X
   INTEGER :: J,K
   DOUBLE PRECISION :: Y

   IF (I > 1) THEN
    DO J=1,I-1
     Y=0.0D0
     DO K=1,N
      Y=Y+A(K,I)*A(K,J)
     ENDDO
     DO K=1,N
      A(K,I)=A(K,I)-Y*A(K,J)
     ENDDO
    ENDDO
   ENDIF
   X=0.0D0
   DO J=1,N
    X=X+A(J,I)**2
   ENDDO
   DO J=1,N
    A(J,I)=A(J,I)/DSQRT(X)
   ENDDO
   RETURN

END SUBROUTINE 
