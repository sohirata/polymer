SUBROUTINE FOCK_BUILD(ASYMMETRY,LOEP,LSLATER,LKLI)
! CONSTRUCT FOCK MATRIX IN THE AO BASIS, AND TRANSFORM IT INTO THE DELOCALIZED AO BASIS.
! SOLVE SEECULAR EQUATION BY CANONICAL TRANS-FORMATION OF OVERLAP MATRIX.  RETURNS THE
! FOCK MATRIX ASSYMMETRY (DEVIATION FROM THE HERMITIAN) AS AN ARGUMENT.

   USE MPI_F08
   USE CONTROL
   USE STRUCTURE
   USE BASISSET
   USE INTEGRAL
   USE GRADIENT
   USE CONSTANTS
   USE MULTIPOLE
   USE OEP

   IMPLICIT NONE
!  INCLUDE "mpif.h"
   LOGICAL :: LOEP,LSLATER,LKLI
   INTEGER :: QX,QY,QZ,IX,IY,IZ,I,J,K,L,N,JJ
   INTEGER :: REDUCED_NCGS
   INTEGER,ALLOCATABLE :: P2C(:)
   DOUBLE PRECISION :: ASYMMETRY,W,A,B
   DOUBLE PRECISION,ALLOCATABLE :: E(:)
   DOUBLE COMPLEX :: PX,PY,PZ,PQX,PQY,PQZ,AVE
   DOUBLE COMPLEX,ALLOCATABLE :: WS(:,:),WF(:,:),WC(:,:)
   DOUBLE COMPLEX,ALLOCATABLE :: WK(:,:)
   DOUBLE PRECISION :: MAXE,MINE,N1,N2,N12,F1,F2,F12
   DOUBLE PRECISION :: TEMPHF
   DOUBLE PRECISION,ALLOCATABLE :: MPE(:,:,:),W1(:,:)

   ALLOCATE(WS(NCGS,NCGS),WF(NCGS,NCGS),WC(NCGS,NCGS),E(NCGS),WK(NCGS,NCGS))
   ALLOCATE(MPE(NCGS,NCGS,-CEL1X:CEL1X),W1(NCGS,NCGS))
   ASYMMETRY=0.0D0

!  BUILD FOCK MATRIX
   IF (LOEP) THEN
    ! OPTIMIZED EFFECTIVE POTENTIAL METHOD
!3  F_C=T_C+N_C+C_C-0.5D0*O_C*DOPTN(19)
   ELSE IF (LSLATER.OR.LKLI) THEN
    ! SLATER51 OR KLI METHOD
!3  F_C=T_C+N_C+C_C
   ELSE
    ! REGULAR HARTREE-FOCK OR APPROXIMATE DFT METHOD
    F_C=T_C+N_C+C_C-0.5D0*X_C*DOPTN(19)
   ENDIF
   IF (LDFT.OR.LSLATER.OR.LKLI) F_C=F_C+Y_C

!  MULTIPOLE EXPANSION
   IF (IOPTN(18) == 1) THEN
    IF (LY) CALL PABORT('MULTIPOLE EXPANSION IN 2D & 3D NOT YET IMPLEMENTED')
    IF (LZ) CALL PABORT('MULTIPOLE EXPANSION IN 2D & 3D NOT YET IMPLEMENTED')
    NDIPOLEX=0.0D0
    NDIPOLEY=0.0D0
    NDIPOLEZ=0.0D0
    NQPOLEXX=0.0D0
    NQPOLEYY=0.0D0
    NQPOLEZZ=0.0D0
    NQPOLEXY=0.0D0
    NQPOLEYZ=0.0D0
    NQPOLEZX=0.0D0
    DO I=1,NATOM
     NDIPOLEX=NDIPOLEX-DFLOAT(IATOM(I))*ATOMX(I)
     NDIPOLEY=NDIPOLEY-DFLOAT(IATOM(I))*ATOMY(I)
     NDIPOLEZ=NDIPOLEZ-DFLOAT(IATOM(I))*ATOMZ(I)
     NQPOLEXX=NQPOLEXX-DFLOAT(IATOM(I))*ATOMX(I)*ATOMX(I)
     NQPOLEYY=NQPOLEYY-DFLOAT(IATOM(I))*ATOMY(I)*ATOMY(I)
     NQPOLEZZ=NQPOLEZZ-DFLOAT(IATOM(I))*ATOMZ(I)*ATOMZ(I)
     NQPOLEXY=NQPOLEXY-DFLOAT(IATOM(I))*ATOMX(I)*ATOMY(I)
     NQPOLEYZ=NQPOLEYZ-DFLOAT(IATOM(I))*ATOMY(I)*ATOMZ(I)
     NQPOLEZX=NQPOLEZX-DFLOAT(IATOM(I))*ATOMZ(I)*ATOMX(I)
    ENDDO
    DIPOLEX=NDIPOLEX
    DIPOLEY=NDIPOLEY
    DIPOLEZ=NDIPOLEZ
    QPOLEXX=NQPOLEXX
    QPOLEYY=NQPOLEYY
    QPOLEZZ=NQPOLEZZ
    QPOLEXY=NQPOLEXY
    QPOLEYZ=NQPOLEYZ
    QPOLEZX=NQPOLEZX
    DO QX=-CEL1X,CEL1X
    DO QY=-CEL1Y,CEL1Y
    DO QZ=-CEL1Z,CEL1Z
     DO I=1,NCGS
      DO J=1,NCGS
       DIPOLEX=DIPOLEX+P_C_HELIX(J,I,0,QX)*M_C(J,I,QX,QY,QZ,1)
       DIPOLEY=DIPOLEY+P_C_HELIX(J,I,0,QX)*M_C(J,I,QX,QY,QZ,2)
       DIPOLEZ=DIPOLEZ+P_C_HELIX(J,I,0,QX)*M_C(J,I,QX,QY,QZ,3)
       QPOLEXX=QPOLEXX+P_C_HELIX(J,I,0,QX)*M_C(J,I,QX,QY,QZ,4)
       QPOLEYY=QPOLEYY+P_C_HELIX(J,I,0,QX)*M_C(J,I,QX,QY,QZ,5)
       QPOLEZZ=QPOLEZZ+P_C_HELIX(J,I,0,QX)*M_C(J,I,QX,QY,QZ,6)
       QPOLEXY=QPOLEXY+P_C_HELIX(J,I,0,QX)*M_C(J,I,QX,QY,QZ,7)
       QPOLEYZ=QPOLEYZ+P_C_HELIX(J,I,0,QX)*M_C(J,I,QX,QY,QZ,8)
       QPOLEZX=QPOLEZX+P_C_HELIX(J,I,0,QX)*M_C(J,I,QX,QY,QZ,9)
      ENDDO
     ENDDO
    ENDDO
    ENDDO
    ENDDO
    ! OLD MPE CODE
!!  A=RIEMANN_ZETA3
!!  DO QX=1,CEL2X
!!   A=A-1.0D0/DFLOAT(QX**3)
!!  ENDDO
!!  A=A/(PERIODX**3)
!!  F_C=F_C+A*(2.0D0*M_C(:,:,:,:,:,2)*DIPOLEY+2.0D0*M_C(:,:,:,:,:,3)*DIPOLEZ &
!!  -4.0D0*M_C(:,:,:,:,:,1)*DIPOLEX+S_C*(2.0D0*QPOLEXX-QPOLEYY-QPOLEZZ))
    ! OLD MPE CODE END
    MPE=0.0D0
    DO QX=CEL2X+1,HUGECELL
     B=DCOS(DFLOAT(QX)*HELIX)
     A=1.0D0/((DFLOAT(QX)*PERIODX)**3)
     DO QY=-CEL1X,CEL1X
      DO I=1,NCGS
       DO J=1,NCGS
        MPE(J,I,QY)=MPE(J,I,QY)+A*(2.0D0*M_C(J,I,QY,0,0,2)*DIPOLEY*B+2.0D0*M_C(J,I,QY,0,0,3)*DIPOLEZ*B &
                                  -4.0D0*M_C(J,I,QY,0,0,1)*DIPOLEX)
!                                 -4.0D0*M_C(J,I,QY,0,0,1)*DIPOLEX+S_C(J,I,QY,0,0)*(2.0D0*QPOLEXX-QPOLEYY-QPOLEZZ))
       ENDDO
      ENDDO
     ENDDO
    ENDDO
    DO QX=-CEL1X,CEL1X
     DO I=1,NCGS
      DO J=1,NCGS
       W1(I,J)=0.0D0
       DO JJ=1,NCGS
        W1(I,J)=W1(I,J)+C2H(J,JJ,QX)*MPE(I,JJ,QX)
       ENDDO
      ENDDO
     ENDDO
     DO I=1,NCGS
      DO J=1,NCGS
       F_C(I,J,QX,0,0)=F_C(I,J,QX,0,0)+W1(I,J)
      ENDDO
     ENDDO
    ENDDO
  
    IF ((IOPTN(9) == 3).AND.(MYID == 0)) THEN

     ! CAUTION: The sign may be reversed. Also multipoles in an infinite system are not well defined.

     WRITE(6,'(A)') 'DIPOLE MOMENTS IN ATOMIC UNITS'
     WRITE(6,'(A)') '-------------------------------'
     WRITE(6,'(3(A,F15.10))') 'X',DIPOLEX,'  Y',DIPOLEY,'  Z',DIPOLEZ
     WRITE(6,'(A)') '-------------------------------'
     WRITE(6,'(A)') 'QUADRUPOLE MOMENTS IN ATOMIC UNITS'
     WRITE(6,'(A)') '----------------------------------'
     WRITE(6,'(3(A,F15.10))') 'XX',QPOLEXX,'  YY',QPOLEYY,'  ZZ',QPOLEZZ
     WRITE(6,'(3(A,F15.10))') 'XY',QPOLEXY,'  YZ',QPOLEYZ,'  ZX',QPOLEZX
     WRITE(6,'(A)') '----------------------------------'

!    WRITE(6,'(A)') 'DIPOLE MOMENTS IN UNITS OF DEBYE'
!    WRITE(6,'(A)') '-------------------------------'
!    WRITE(6,'(3(A,F8.4))') 'X',DIPOLEX*DEBYED,'  Y',DIPOLEY*DEBYED,'  Z',DIPOLEZ*DEBYED
!    WRITE(6,'(A)') '-------------------------------'
!    WRITE(6,'(A)') 'QUADRUPOLE MOMENTS IN UNITS OF DEBYE ANGSTROM'
!    WRITE(6,'(A)') '----------------------------------'
!    WRITE(6,'(3(A,F8.4))') 'XX',QPOLEXX*DEBYEQ,'  YY',QPOLEYY*DEBYEQ,'  ZZ',QPOLEZZ*DEBYEQ
!    WRITE(6,'(3(A,F8.4))') 'XY',QPOLEXY*DEBYEQ,'  YZ',QPOLEYZ*DEBYEQ,'  ZX',QPOLEZX*DEBYEQ
!    WRITE(6,'(A)') '----------------------------------'

    ENDIF
   ENDIF

!  DUMP FOCK MATRIX
   IF ((IOPTN(9) >= 2).AND.(MYID == 0)) THEN
    WRITE(6,'(A)') 'FOCK MATRIX FOR CONTRACTED GAUSSIANS'
    CALL DUMP1(F_C,NCGS,CEL1X,CEL1Y,CEL1Z)
   ENDIF

!  COUNT THE NUMBER OF ELECTRONS IN A UNIT CELL.  IF THE NUMBER IS ODD, THEN THE PROGRAM PABORTS.
   N=0
   DO I=1,NATOM
    N=N+IATOM(I)
   ENDDO
   N=N-IOPTN(5)
   IF (MOD(N,2) /= 0) CALL PABORT('ODD NUMBER OF ELECTRONS')
   IF ((IOPTN(9) == 3).AND.(MYID == 0)) WRITE(6,'(A,I3)') 'NUMBER OF ELECTRONS = ',N

!  ZERO SCRATCH DENSITY MATRIX
   P_C_OUT=0.0D0
   W_C=0.0D0

!  LOOP OVER K VECTORS
   DO IX=-KVCX,MAX(0,KVCX-1)
   DO IY=-KVCY,MAX(0,KVCY-1)
   DO IZ=-KVCZ,MAX(0,KVCZ-1)
    IF (IOPTN(9) == 3) WRITE(6,'(A,3I4)') 'K VECTORS = ',IX,IY,IZ

!   CONSTRUCT DYNAMICAL OVERLAP & FOCK MATRICES
    IF (KVCX == 0) THEN
     PX=DCMPLX(0.0D0,0.0D0)
    ELSE
     PX=DCMPLX(0.0D0,PI*DFLOAT(IX)/DFLOAT(KVCX))
    ENDIF
    IF (KVCY == 0) THEN
     PY=DCMPLX(0.0D0,0.0D0)
    ELSE
     PY=DCMPLX(0.0D0,PI*DFLOAT(IY)/DFLOAT(KVCY))
    ENDIF
    IF (KVCZ == 0) THEN
     PZ=DCMPLX(0.0D0,0.0D0)
    ELSE
     PZ=DCMPLX(0.0D0,PI*DFLOAT(IZ)/DFLOAT(KVCZ))
    ENDIF
    WS=DCMPLX(0.0D0,0.0D0)
    WF=DCMPLX(0.0D0,0.0D0)
    DO J=1,NCGS
     DO K=1,NCGS
      DO QX=-CEL1X,CEL1X
      DO QY=-CEL1Y,CEL1Y
      DO QZ=-CEL1Z,CEL1Z
       PQX=PX*DFLOAT(QX)
       PQY=PY*DFLOAT(QY)
       PQZ=PZ*DFLOAT(QZ)
       WS(K,J)=WS(K,J)+S_C(K,J,QX,QY,QZ)*CDEXP(PQX+PQY+PQZ)
       WF(K,J)=WF(K,J)+F_C(K,J,QX,QY,QZ)*CDEXP(PQX+PQY+PQZ)
      ENDDO
      ENDDO
      ENDDO
     ENDDO
    ENDDO
    DO J=1,NCGS
     DO K=1,NCGS
      IF (CDABS(WF(K,J)-DCONJG(WF(J,K))) > ASYMMETRY) THEN
       ASYMMETRY=CDABS(WF(K,J)-DCONJG(WF(J,K)))
      ENDIF
      AVE=(WF(K,J)+DCONJG(WF(J,K)))/2.0D0
      WF(K,J)=AVE
      WF(J,K)=DCONJG(AVE)
     ENDDO
    ENDDO

!   CONVERT DYNAMICAL FOCK & OVERLAP FROM CARTESIAN TO SPHERICAL GAUSSIANS
    DO J=1,NCGS
     DO K=1,NCGS
      WK(K,J)=DCMPLX(0.0D0,0.0D0)
      DO L=1,NCGS
       WK(K,J)=WK(K,J)+C2S(K,L)*WS(L,J)
      ENDDO
     ENDDO
    ENDDO
    DO J=1,NCGS
     DO K=1,NCGS
      WS(K,J)=DCMPLX(0.0D0,0.0D0)
      DO L=1,NCGS
       WS(K,J)=WS(K,J)+C2S(J,L)*WK(K,L)
      ENDDO
     ENDDO
    ENDDO
    DO J=1,NCGS
     DO K=1,NCGS
      WK(K,J)=DCMPLX(0.0D0,0.0D0)
      DO L=1,NCGS
       WK(K,J)=WK(K,J)+C2S(K,L)*WF(L,J)
      ENDDO
     ENDDO
    ENDDO
    DO J=1,NCGS
     DO K=1,NCGS
      WF(K,J)=DCMPLX(0.0D0,0.0D0)
      DO L=1,NCGS
       WF(K,J)=WF(K,J)+C2S(J,L)*WK(K,L)
      ENDDO
     ENDDO
    ENDDO

!   CANONICAL ORTHOGONALIZATION OF DYNAMICAL OVERLAP MATRIX
    CALL HHBS(NCGS,NCGS,WS,E,WC)
    IF (IOPTN(9) == 3) WRITE(6,'(A,100F10.5:)') 'METRIC  = ',(E(J),J=1,NCGS)
    REDUCED_NCGS=0
    DO J=1,NCGS
     IF (E(J) > DOPTN(85)) THEN
      REDUCED_NCGS=REDUCED_NCGS+1
      DO K=1,NCGS
       WS(K,REDUCED_NCGS)=WC(K,J)/DSQRT(E(J))
      ENDDO
     ENDIF
    ENDDO
    IF (REDUCED_NCGS /= IALL(IX,IY,IZ)) CALL PABORT('INTERNAL PROGRAM ERROR')

!   DIAGONALIZATION OF DYNAMICAL FOCK MATRIX
    DO J=1,REDUCED_NCGS
     DO K=1,NCGS
      WC(K,J)=DCMPLX(0.0D0,0.0D0)
      DO L=1,NCGS
       WC(K,J)=WC(K,J)+WF(K,L)*WS(L,J)
      ENDDO
     ENDDO
    ENDDO
    DO J=1,REDUCED_NCGS
     DO K=1,REDUCED_NCGS
      WF(K,J)=DCMPLX(0.0D0,0.0D0)
      DO L=1,NCGS
       WF(K,J)=WF(K,J)+DCONJG(WS(L,K))*WC(L,J)
      ENDDO
     ENDDO
    ENDDO
    CALL HHBS(NCGS,REDUCED_NCGS,WF,E,WC)
    DO J=1,REDUCED_NCGS
     EPSILON(J,IX,IY,IZ)=E(J)
     DO K=1,NCGS
      WF(K,J)=DCMPLX(0.0D0,0.0D0)
      DO L=1,REDUCED_NCGS
       WF(K,J)=WF(K,J)+WS(K,L)*WC(L,J)
      ENDDO
     ENDDO
    ENDDO

!   CONVERT CO FROM CARTESIAN TO SPHERICAL
    DO J=1,REDUCED_NCGS
     DO K=1,NCGS
      CO(K,J,IX,IY,IZ)=DCMPLX(0.0D0,0.0D0)
      DO L=1,NCGS
       CO(K,J,IX,IY,IZ)=CO(K,J,IX,IY,IZ)+WF(L,J)*C2S(L,K)
      ENDDO
     ENDDO
    ENDDO

!   ERROR TRAP EPSILON
    IF (REDUCED_NCGS < NCGS) THEN
     DO J=REDUCED_NCGS+1,NCGS
      EPSILON(J,IX,IY,IZ)=1.0D99
     ENDDO
    ENDIF

    ! OEP CONSTANT SHIFT IN ONE-ELECTRON ENERGIES
!   IF (LOEP) THEN
!    DO J=1,NCGS
!     EPSILON(J,I)=EPSILON(J,I)+OEPSHIFT
!    ENDDO
!   ENDIF

   ENDDO
   ENDDO
   ENDDO

!  DETERMINE THE FERMI ENERGY
   IF (DOPTN(108) > 0.0D0) THEN
    TEMPHF=DOPTN(108)
    IF (MYID == 0) WRITE(6,'(A,E10.4,A)') 'FOCK MATRIX IS FORMED AT T = ',TEMPHF,' K'
   ELSE IF (DOPTN(108) == 0.0D0) THEN
    TEMPHF=1.0D-4
   ELSE
    CALL PABORT('ILLEGAL HF TEMPERATURE')
   ENDIF
   MAXE=-1.0D99
   MINE=1.0D99
   DO IX=-KVCX,MAX(0,KVCX-1)
   DO IY=-KVCY,MAX(0,KVCY-1)
   DO IZ=-KVCZ,MAX(0,KVCZ-1)
    DO J=1,NCGS
     IF (EPSILON(J,IX,IY,IZ) > MAXE) MAXE=EPSILON(J,IX,IY,IZ)
     IF (EPSILON(J,IX,IY,IZ) < MINE) MINE=EPSILON(J,IX,IY,IZ)
    ENDDO
   ENDDO
   ENDDO
   ENDDO
   F1=MINE
   F12=(MINE+MAXE)/2.0D0
   F2=MAXE
   DO WHILE (.TRUE.)
    N1=0.0D0
    DO IX=-KVCX,MAX(0,KVCX-1)
    DO IY=-KVCY,MAX(0,KVCY-1)
    DO IZ=-KVCZ,MAX(0,KVCZ-1)
     DO J=1,NCGS
      N1=N1+2.0D0/(DEXP((EPSILON(J,IX,IY,IZ)-F1)/BOLTZMANN/TEMPHF)+1.0D0)
     ENDDO
    ENDDO
    ENDDO
    ENDDO
    N1=N1/DFLOAT(MAX(1,2*KVCX)*MAX(1,2*KVCY)*MAX(1,2*KVCZ))-DFLOAT(N)
    N2=0.0D0
    DO IX=-KVCX,MAX(0,KVCX-1)
    DO IY=-KVCY,MAX(0,KVCY-1)
    DO IZ=-KVCZ,MAX(0,KVCZ-1)
     DO J=1,NCGS
      N2=N2+2.0D0/(DEXP((EPSILON(J,IX,IY,IZ)-F2)/BOLTZMANN/TEMPHF)+1.0D0)
     ENDDO
    ENDDO
    ENDDO
    ENDDO
    N2=N2/DFLOAT(MAX(1,2*KVCX)*MAX(1,2*KVCY)*MAX(1,2*KVCZ))-DFLOAT(N)
    N12=0.0D0
    DO IX=-KVCX,MAX(0,KVCX-1)
    DO IY=-KVCY,MAX(0,KVCY-1)
    DO IZ=-KVCZ,MAX(0,KVCZ-1)
     DO J=1,NCGS
      N12=N12+2.0D0/(DEXP((EPSILON(J,IX,IY,IZ)-F12)/BOLTZMANN/TEMPHF)+1.0D0)
     ENDDO
    ENDDO
    ENDDO
    ENDDO
    N12=N12/DFLOAT(MAX(1,2*KVCX)*MAX(1,2*KVCY)*MAX(1,2*KVCZ))-DFLOAT(N)

    IF (IOPTN(9) >= 2) WRITE(6,'(3(A,F7.3,A,F10.7))') 'MUMIN=',F1, ': DeltaN=',N1, &
                                                  '    MUMID=',F12,': DeltaN=',N12,&
                                                  '    MUMAX=',F2, ': DeltaN=',N2
    IF (N1 > N12) CALL PABORT('DETERMINATION OF FERMI ENERGY FAILED 2')
    IF (N12 > N2) CALL PABORT('DETERMINATION OF FERMI ENERGY FAILED 3')
    IF (DABS(N12) < 1.0D-10) THEN
     FERMI=F12
     IF (IOPTN(9) >= 2) WRITE(6,'(A,F20.15,A)') 'FERMI ENERGY = ',FERMI
     EXIT
    ELSE IF ((N1 > 0.0D0).AND.(N2 > 0.0D0)) THEN
     F2=F1
     F1=F1-0.1D0
    ELSE IF ((N1 < 0.0D0).AND.(N2 < 0.0D0)) THEN
     F1=F2
     F2=F2+0.1D0
    ELSE IF ((N1 < 0.0D0).AND.(N12 >= 0.0D0)) THEN
     F2=F12
    ELSE IF ((N12 <= 0.0D0).AND.(N2 > 0.0D0)) THEN
     F1=F12
    ELSE
     CALL PABORT('DETERMINATION OF FERMI ENERGY FAILED 4')
    ENDIF
    F12=(F1+F2)/2.0D0

!   IF (F2 > MAXE) CALL PABORT('DETERMINATION OF FERMI ENERGY FAILED')
   ENDDO
   IF (IOPTN(9) >= 2) THEN
    IF (MYID == 0) WRITE(6,'(A,F20.15,A)') 'FERMI ENERGY = ',FERMI
    DO IX=-KVCX,MAX(0,KVCX-1)
    DO IY=-KVCY,MAX(0,KVCY-1)
    DO IZ=-KVCZ,MAX(0,KVCZ-1)
     IF (MYID == 0) WRITE(6,'(A,100F10.5:)') 'EPSILON = ',(EPSILON(J,IX,IY,IZ),J=1,NCGS)
     IF (MYID == 0) WRITE(6,'(A,100F10.5:)') 'WEIGHT =  ', &
                    (2.0D0/(DEXP((EPSILON(J,IX,IY,IZ)-FERMI)/BOLTZMANN/TEMPHF)+1.0D0),J=1,NCGS)
    ENDDO
    ENDDO
    ENDDO
   ENDIF

!  LOOP OVER K VECTORS
   DO IX=-KVCX,MAX(0,KVCX-1)
   DO IY=-KVCY,MAX(0,KVCY-1)
   DO IZ=-KVCZ,MAX(0,KVCZ-1)
    IF (IOPTN(9) == 3) WRITE(6,'(A,3I4)') 'K VECTORS = ',IX,IY,IZ
    IF (KVCX == 0) THEN
     PX=DCMPLX(0.0D0,0.0D0)
    ELSE
     PX=DCMPLX(0.0D0,PI*DFLOAT(IX)/DFLOAT(KVCX))
    ENDIF
    IF (KVCY == 0) THEN
     PY=DCMPLX(0.0D0,0.0D0)
    ELSE
     PY=DCMPLX(0.0D0,PI*DFLOAT(IY)/DFLOAT(KVCY))
    ENDIF
    IF (KVCZ == 0) THEN
     PZ=DCMPLX(0.0D0,0.0D0)
    ELSE
     PZ=DCMPLX(0.0D0,PI*DFLOAT(IZ)/DFLOAT(KVCZ))
    ENDIF
    W=1.0D0/DFLOAT(MAX(1,2*KVCX)*MAX(1,2*KVCY)*MAX(1,2*KVCZ))

!   CONSTRUCT A NEW DENSITY MATRIX
!   IF (DOPTN(98) == 0.0D0) THEN
!    DO J=1,NCGS
!     DO K=1,NCGS
!      WS(K,J)=DCMPLX(0.0D0,0.0D0)
!      WC(K,J)=DCMPLX(0.0D0,0.0D0)
!      DO L=1,N/2
!       WS(K,J)=WS(K,J)+2.0D0*DCONJG(CO(K,L,IX,IY,IZ))*CO(J,L,IX,IY,IZ)
!       WC(K,J)=WC(K,J)+2.0D0*DCONJG(CO(K,L,IX,IY,IZ))*CO(J,L,IX,IY,IZ)*DCMPLX(EPSILON(L,IX,IY,IZ),0.0D0)
!      ENDDO
!     ENDDO
!    ENDDO
!   ELSE
!    IF ((MYID == 0).AND.(DOPTN(108) > 0.0D0)) WRITE(6,'(A,E10.4,A)') 'DENSITY MATRIX IS FORMED AT T = ',TEMPHF,' K'
     DO J=1,NCGS
      DO K=1,NCGS
       WS(K,J)=DCMPLX(0.0D0,0.0D0)
       WC(K,J)=DCMPLX(0.0D0,0.0D0)
       DO L=1,NCGS
        WS(K,J)=WS(K,J)+2.0D0/(DEXP((EPSILON(L,IX,IY,IZ)-FERMI)/BOLTZMANN/TEMPHF)+1.0D0) &
                       *DCONJG(CO(K,L,IX,IY,IZ))*CO(J,L,IX,IY,IZ)
        WC(K,J)=WC(K,J)+2.0D0/(DEXP((EPSILON(L,IX,IY,IZ)-FERMI)/BOLTZMANN/TEMPHF)+1.0D0) &
                       *DCONJG(CO(K,L,IX,IY,IZ))*CO(J,L,IX,IY,IZ) &
                       *DCMPLX(EPSILON(L,IX,IY,IZ),0.0D0)
       ENDDO
      ENDDO
     ENDDO
!   ENDIF

    DO QX=-CEL1X,CEL1X
    DO QY=-CEL1Y,CEL1Y
    DO QZ=-CEL1Z,CEL1Z
     PQX=PX*DFLOAT(QX)
     PQY=PY*DFLOAT(QY)
     PQZ=PZ*DFLOAT(QZ)
     DO K=1,NCGS
      DO L=1,NCGS
       P_C_OUT(L,K,QX,QY,QZ)=P_C_OUT(L,K,QX,QY,QZ)+WS(L,K)*CDEXP(PQX+PQY+PQZ)*W
       W_C(L,K,QX,QY,QZ)    =W_C(L,K,QX,QY,QZ)    +WC(L,K)*CDEXP(PQX+PQY+PQZ)*W
      ENDDO
     ENDDO
    ENDDO
    ENDDO
    ENDDO

   ENDDO
   ENDDO
   ENDDO

   IF ((IOPTN(9) == 3).AND.(MYID == 0)) THEN
    WRITE(6,'(A)') 'OUTPUT DENSITY MATRIX'
    CALL DUMP1(P_C_OUT,NCGS,CEL1X,CEL1Y,CEL1Z)
    WRITE(6,'(A)') 'ENERGY-WEIGHTED DENSITY MATRIX'
    CALL DUMP1(W_C,NCGS,CEL1X,CEL1Y,CEL1Z)
   ENDIF
   DEALLOCATE(MPE,W1)
   DEALLOCATE(WS,WF,WC,E)

   RETURN
END SUBROUTINE



SUBROUTINE LINEAR_DEPENDENCE
! CONSTRUCT DYNAMICAL OVERLAP MATRICES AND FIND THE NUMBER OF LINEAR DEPENDENCE FOR EACH WAVEVECTOR.

   USE MPI_F08
   USE CONTROL
   USE STRUCTURE
   USE BASISSET
   USE INTEGRAL
   USE GRADIENT
   USE CONSTANTS
   USE MULTIPOLE
   USE OEP

   IMPLICIT NONE
!  INCLUDE "mpif.h"
   INTEGER :: QX,QY,QZ,IX,IY,IZ,I,J,K,L,N
   INTEGER :: REDUCED_NCGS
   INTEGER,ALLOCATABLE :: P2C(:)
   DOUBLE PRECISION,ALLOCATABLE :: E(:)
   DOUBLE COMPLEX :: PX,PY,PZ,PQX,PQY,PQZ
   DOUBLE COMPLEX,ALLOCATABLE :: WS(:,:),WC(:,:),WK(:,:)

   ALLOCATE(WS(NCGS,NCGS),WC(NCGS,NCGS),E(NCGS),WK(NCGS,NCGS))

!  LOOP OVER K VECTORS
   DO IX=-KVCX,MAX(0,KVCX-1)
   DO IY=-KVCY,MAX(0,KVCY-1)
   DO IZ=-KVCZ,MAX(0,KVCZ-1)
    IF (IOPTN(9) == 3) WRITE(6,'(A,3I4)') 'K VECTORS = ',IX,IY,IZ

!   CONSTRUCT DYNAMICAL OVERLAP MATRICES
    IF (KVCX == 0) THEN
     PX=DCMPLX(0.0D0,0.0D0)
    ELSE
     PX=DCMPLX(0.0D0,PI*DFLOAT(IX)/DFLOAT(KVCX))
    ENDIF
    IF (KVCY == 0) THEN
     PY=DCMPLX(0.0D0,0.0D0)
    ELSE
     PY=DCMPLX(0.0D0,PI*DFLOAT(IY)/DFLOAT(KVCY))
    ENDIF
    IF (KVCZ == 0) THEN
     PZ=DCMPLX(0.0D0,0.0D0)
    ELSE
     PZ=DCMPLX(0.0D0,PI*DFLOAT(IZ)/DFLOAT(KVCZ))
    ENDIF
    WS=DCMPLX(0.0D0,0.0D0)
    DO J=1,NCGS
     DO K=1,NCGS
      DO QX=-CEL1X,CEL1X
      DO QY=-CEL1Y,CEL1Y
      DO QZ=-CEL1Z,CEL1Z
       PQX=PX*DFLOAT(QX)
       PQY=PY*DFLOAT(QY)
       PQZ=PZ*DFLOAT(QZ)
       WS(K,J)=WS(K,J)+S_C(K,J,QX,QY,QZ)*CDEXP(PQX+PQY+PQZ)
      ENDDO
      ENDDO
      ENDDO
     ENDDO
    ENDDO

!   CONVERT DYNAMICAL OVERLAP FROM CARTESIAN TO SPHERICAL GAUSSIANS
    DO J=1,NCGS
     DO K=1,NCGS
      WK(K,J)=DCMPLX(0.0D0,0.0D0)
      DO L=1,NCGS
       WK(K,J)=WK(K,J)+C2S(K,L)*WS(L,J)
      ENDDO
     ENDDO
    ENDDO
    DO J=1,NCGS
     DO K=1,NCGS
      WS(K,J)=DCMPLX(0.0D0,0.0D0)
      DO L=1,NCGS
       WS(K,J)=WS(K,J)+C2S(J,L)*WK(K,L)
      ENDDO
     ENDDO
    ENDDO

!   CANONICAL ORTHOGONALIZATION OF DYNAMICAL OVERLAP MATRIX
    IALLMAX=0
    CALL HHBS(NCGS,NCGS,WS,E,WC)
    IF (IOPTN(9) == 3) WRITE(6,'(A,100F10.5:)') 'METRIC  = ',(E(J),J=1,NCGS)
    REDUCED_NCGS=0
    DO J=1,NCGS
     IF (E(J) > DOPTN(85)) THEN
      REDUCED_NCGS=REDUCED_NCGS+1
      DO K=1,NCGS
       WS(K,REDUCED_NCGS)=WC(K,J)/DSQRT(E(J))
      ENDDO
!else
!write(*,*) j,e(j)
!do k=1,ncgs
!write(*,'(A,I3,F15.7)') '...',k,dreal(WC(k,j))
!enddo
     ENDIF
    ENDDO
    IF ((REDUCED_NCGS < NCGS).AND.(MYID == 0)) THEN
     WRITE(6,'(A,I3,A,3I3)') '***** WARNING :',NCGS-REDUCED_NCGS, &
     ' LINEARLY DEPENDENT AND/OR REDUNDANT CARTESIAN FUNCTIONS FOR K =',IX,IY,IZ
    ENDIF
    IALL(IX,IY,IZ)=REDUCED_NCGS
    IF (IALL(IX,IY,IZ) > IALLMAX) IALLMAX=IALL(IX,IY,IZ)

   ENDDO
   ENDDO
   ENDDO
   IALL(KVCX,:,:)=IALL(-KVCX,:,:)
   IALL(:,KVCY,:)=IALL(:,-KVCY,:)
   IALL(:,:,KVCZ)=IALL(:,:,-KVCZ)

   DEALLOCATE(WS,WC,E)

   RETURN
END SUBROUTINE



SUBROUTINE HHBS(NP,N,W,E,V)
! FULL DIAGONALIZATION OF A COMPLEX HERMITIAN MATRIX BY HOUSEHOLDER METHOD.
! THIS SUBROUTINE PASSES THE NECESSARY DATA TO EISPACK SUBROUTINES.

   IMPLICIT NONE
   INTEGER :: N,NP,JERR
   DOUBLE COMPLEX :: W(NP,NP),V(NP,NP)
   DOUBLE PRECISION :: WR(NP,N),WI(NP,N),VR(NP,N),VI(NP,N)
   DOUBLE PRECISION :: E(N),D(N),T(2,N)

   INTEGER :: I,J

   DO I=1,N
    DO J=1,N
     WR(J,I)=DREAL(W(J,I))
     WI(J,I)=DIMAG(W(J,I))
     VR(J,I)=0.0D0
     VI(J,I)=0.0D0
    ENDDO
    VR(I,I)=1.0D0
    VI(I,I)=0.0D0
   ENDDO

   CALL EPAC1(NP,N,WR,WI,E,D,D,T)
   CALL EPAC2(NP,N,E,D,VR,JERR)
   IF (JERR /= 0) CALL PABORT('EIGENVECTORS NOT CONVERGED')
   CALL EPAC3(NP,N,WR,WI,T,N,VR,VI)

   DO I=1,N
    DO J=1,N
     V(J,I)=DCMPLX(VR(J,I),VI(J,I))
    ENDDO
   ENDDO

   RETURN
END SUBROUTINE



SUBROUTINE EPAC1(NM,N,AR,AI,D,E,E2,TAU)

! EISPACK SUBROUTINE HTRIDI

   IMPLICIT NONE
   INTEGER :: I,J,K,L,N,II,NM,JP1
   DOUBLE PRECISION :: AR(NM,N),AI(NM,N),D(N),E(N),E2(N),TAU(2,N)
   DOUBLE PRECISION :: F,G,H,FI,GI,HH,SI,SCALE

   TAU(1,N)=1.0D0
   TAU(2,N)=0.0D0
   DO 10 I=1,N
10 D(I)=AR(I,I)
   DO 30 II=1,N
    I=N+1-II
    L=I-1
    H=0.0D0
    SCALE=0.0D0
    IF (L.LT.1) GOTO 13
    DO 12 K=1,L
12  SCALE=SCALE+DABS(AR(I,K))+DABS(AI(I,K))
    IF (SCALE.NE.0.0D0) GOTO 14
    TAU(1,L)=1.0D0
    TAU(2,L)=0.0D0
13  E(I)=0.0D0
    E2(I)=0.0D0
    GOTO 29
14  DO 15 K=1,L
     AR(I,K)=AR(I,K)/SCALE
     AI(I,K)=AI(I,K)/SCALE
     H=H+AR(I,K)*AR(I,K)+AI(I,K)*AI(I,K)
15  CONTINUE
    E2(I)=SCALE*SCALE*H
    G=DSQRT(H)
    E(I)=SCALE*G
    F=DSQRT(AR(I,L)**2+AI(I,L)**2)
    IF (F.EQ.0.0D0) GOTO 16
    TAU(1,L)=(AI(I,L)*TAU(2,I)-AR(I,L)*TAU(1,I))/F
    SI=(AR(I,L)*TAU(2,I)+AI(I,L)*TAU(1,I))/F
    H=H+F*G
    G=1.0D0+G/F
    AR(I,L)=G*AR(I,L)
    AI(I,L)=G*AI(I,L)
    IF (L.EQ.1) GOTO 27
    GOTO 17
16  TAU(1,L)=-TAU(1,I)
    SI=TAU(2,I)
    AR(I,L)=G
17  F=0.0D0
    DO 24 J=1,L
     G=0.0D0
     GI=0.0D0
     DO 18 K=1,J
      G=G+AR(J,K)*AR(I,K)+AI(J,K)*AI(I,K)
      GI=GI-AR(J,K)*AI(I,K)+AI(J,K)*AR(I,K)
18   CONTINUE
     JP1=J+1
     IF (L.LT.JP1) GOTO 22
     DO 20 K=JP1,L
      G=G+AR(K,J)*AR(I,K)-AI(K,J)*AI(I,K)
      GI=GI-AR(K,J)*AI(I,K)-AI(K,J)*AR(I,K)
20   CONTINUE
22   E(J)=G/H
     TAU(2,J)=GI/H
     F=F+E(J)*AR(I,J)-TAU(2,J)*AI(I,J)
24  CONTINUE
    HH=F/(H+H)
    DO 26 J=1,L
     F=AR(I,J)
     G=E(J)-HH*F
     E(J)=G
     FI=-AI(I,J)
     GI=TAU(2,J)-HH*FI
     TAU(2,J)=-GI
     DO 26 K=1,J
      AR(J,K)=AR(J,K)-F*E(K)-G*AR(I,K)+FI*TAU(2,K)+GI*AI(I,K)
      AI(J,K)=AI(J,K)-F*TAU(2,K)-G*AI(I,K)-FI*E(K)-GI*AR(I,K)
26  CONTINUE
27  DO 28 K=1,L
     AR(I,K)=SCALE*AR(I,K)
     AI(I,K)=SCALE*AI(I,K)
28  CONTINUE
    TAU(2,L)=-SI
29  HH=D(I)
    D(I)=AR(I,I)
    AR(I,I)=HH
    AI(I,I)=SCALE*DSQRT(H)
30 CONTINUE

   RETURN
END SUBROUTINE



SUBROUTINE EPAC2(NM,N,D,E,Z,JERR)

! EISPACK SUBROUTINE TQL2

   IMPLICIT NONE
   INTEGER :: I,J,K,L,M,N,II,L1,NM,MML,JERR
   DOUBLE PRECISION :: D(N),E(N),Z(NM,N)
   DOUBLE PRECISION :: B,C,F,G,H,P,R,S
   DOUBLE PRECISION,PARAMETER :: MACHEP = 1.0D-30

   JERR=0
   IF (N.EQ.1) GOTO 90
   DO 10 I=2,N
10 E(I-1)=E(I)
   F=0.0D0
   B=0.0D0
   E(N)=0.0D0
   DO 24 L=1,N
    J=0
    H=MACHEP*(DABS(D(L))+DABS(E(L)))
    IF (B.LT.H) B=H
    DO 11 M=L,N
     IF (DABS(E(M)).LE.B) GOTO 12
11  CONTINUE
12  IF (M.EQ.L) GOTO 22
13  IF (J.EQ.30) GOTO 80
    J=J+1
    L1=L+1
    G=D(L)
    P=(D(L1)-G)/(2.0D0*E(L))
    R=DSQRT(P*P+1.0D0)
    D(L)=E(L)/(P+DSIGN(R,P))
    H=G-D(L)
    DO 14 I=L1,N
14  D(I)=D(I)-H
    F=F+H
    P=D(M)
    C=1.0D0
    S=0.0D0
    MML=M-L
    DO 20 II=1,MML
     I=M-II
     G=C*E(I)
     H=C*P
     IF (DABS(P).LT.DABS(E(I))) GOTO 15
     C=E(I)/P
     R=DSQRT(C*C+1.0D0)
     E(I+1)=S*P*R
     S=C/R
     C=1.0D0/R
     GOTO 16
15   C=P/E(I)
     R=DSQRT(C*C+1.0D0)
     E(I+1)=S*E(I)*R
     S=1.0D0/R
     C=C*S
16   P=C*D(I)-S*G
     D(I+1)=H+S*(C*G+S*D(I))
     DO 18 K=1,N
      H=Z(K,I+1)
      Z(K,I+1)=S*Z(K,I)+C*H
      Z(K,I)=C*Z(K,I)-S*H
18   CONTINUE
20  CONTINUE
    E(L)=S*P
    D(L)=C*P
    IF (DABS(E(L)).GT.B) GOTO 13
22  D(L)=D(L)+F
24 CONTINUE
   DO 30 II=2,N
    I=II-1
    K=I
    P=D(I)
    DO 26 J=II,N
     IF (D(J).GE.P) GOTO 26
     K=J
     P=D(J)
26  CONTINUE
    IF (K.EQ.I) GOTO 30
    D(K)=D(I)
    D(I)=P
    DO 28 J=1,N
     P=Z(J,I)
     Z(J,I)=Z(J,K)
     Z(J,K)=P
28  CONTINUE
30 CONTINUE
   GOTO 90
80 JERR=L
90 RETURN
END SUBROUTINE



SUBROUTINE EPAC3(NM,N,AR,AI,TAU,M,ZR,ZI)
! EISPACK SUBROUTINE HTRIBK

   IMPLICIT NONE
   INTEGER :: I,J,K,L,M,N,NM
   DOUBLE PRECISION :: AR(NM,N),AI(NM,N),TAU(2,N),ZR(NM,M),ZI(NM,M)
   DOUBLE PRECISION :: H,S,SI

   IF (M.EQ.0) GOTO 20
   DO 5 K=1,N
    DO 5 J=1,M
     ZI(K,J)=-ZR(K,J)*TAU(2,K)
     ZR(K,J)=ZR(K,J)*TAU(1,K)
 5 CONTINUE
   IF (N.EQ.1) GOTO 20
   DO 14 I=2,N
    L=I-1
    H=AI(I,I)
    IF (H.EQ.0.0D0) GOTO 14
    DO 13 J=1,M
     S=0.0D0
     SI=0.0D0
     DO 11 K=1,L
      S=S+AR(I,K)*ZR(K,J)-AI(I,K)*ZI(K,J)
      SI=SI+AR(I,K)*ZI(K,J)+AI(I,K)*ZR(K,J)
11   CONTINUE
     S=(S/H)/H
     SI=(SI/H)/H
     DO 12 K=1,L
      ZR(K,J)=ZR(K,J)-S*AR(I,K)-SI*AI(I,K)
      ZI(K,J)=ZI(K,J)-SI*AR(I,K)+S*AI(I,K)
12   CONTINUE
13  CONTINUE
14 CONTINUE
20 RETURN
END SUBROUTINE
